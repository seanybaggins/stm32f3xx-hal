#![feature(prelude_import)]
#![doc = "\n # stm32f3xx-hal\n\n `stm32f3xx-hal` contains a multi device hardware abstraction on top of the\n peripheral access API for the STMicro [STM32F3][stm] series microcontrollers. The\n selection of the MCU is done by [feature][f] gates\n\n [f]: #selecting-the-right-chip\n [stm]: https://www.st.com/en/microcontrollers-microprocessors/stm32f3-series.html\n\n # Selecting the right chip\n\n   This crate requires you to specify your target chip as a feature.\n\n   Please select one of the following\n\n   (Note: `x` denotes any character in [a-z])\n   *   stm32f301\n   *   stm32f318\n   *   stm32f302xb\n   *   stm32f302xc\n   *   stm32f302xd\n   *   stm32f302xe\n   *   stm32f302x6\n   *   stm32f302x8\n   *   stm32f303xb\n   *   stm32f303xc\n   *   stm32f303xd\n   *   stm32f303xe\n   *   stm32f303x6\n   *   stm32f303x8\n   *   stm32f373\n   *   stm32f378\n   *   stm32f334\n   *   stm32f328\n   *   stm32f358\n   *   stm32f398\n\n   Example: The STM32F3Discovery board has a STM32F303VCT6 chip.\n   So you want to expand your call to `cargo` with `--features stm32f303xc`.\n\n   For more information, see the [README](https://github.com/stm32-rs/stm32f3xx-hal/blob/master/README.md#selecting-the-right-chip)\n"]
#![no_std]
#![allow(non_camel_case_types)]
#![warn(missing_docs)]
#![deny(macro_use_extern_crate)]
#[prelude_import]
use core::prelude::v1::*;
#[macro_use]
extern crate core;
#[macro_use]
extern crate compiler_builtins;
pub use embedded_hal as hal;
pub use nb;
pub use nb::block;
#[cfg(not(feature = "defmt"))]
pub(crate) use core::{assert, panic, unreachable};
#[cfg(not(feature = "defmt"))]
mod macros {}
#[cfg(feature = "stm32f303")]
#[doc = " Peripheral access"]
pub use stm32f3::stm32f303 as pac;
#[cfg(feature = "device-selected")]
#[deprecated(since = "0.5.0", note = "please use `pac` instead")]
#[doc = " Peripheral access"]
pub use crate::pac as stm32;
pub mod delay {
    #![doc = " Delays"]
    use core::convert::From;
    use cortex_m::peripheral::syst::SystClkSource;
    use cortex_m::peripheral::SYST;
    use crate::hal::blocking::delay::{DelayMs, DelayUs};
    use crate::rcc::Clocks;
    #[doc = " System timer (SysTick) as a delay provider"]
    pub struct Delay {
        clocks: Clocks,
        syst: SYST,
    }
    impl Delay {
        #[doc = " Configures the system timer (SysTick) as a delay provider"]
        pub fn new(mut syst: SYST, clocks: Clocks) -> Self {
            syst.set_clock_source(SystClkSource::Core);
            Delay { syst, clocks }
        }
        #[doc = " Releases the system timer (SysTick) resource"]
        pub fn free(self) -> SYST {
            self.syst
        }
    }
    impl DelayMs<u32> for Delay {
        fn delay_ms(&mut self, ms: u32) {
            self.delay_us(ms * 1_000);
        }
    }
    impl DelayMs<u16> for Delay {
        fn delay_ms(&mut self, ms: u16) {
            self.delay_ms(u32::from(ms));
        }
    }
    impl DelayMs<u8> for Delay {
        fn delay_ms(&mut self, ms: u8) {
            self.delay_ms(u32::from(ms));
        }
    }
    impl DelayUs<u32> for Delay {
        fn delay_us(&mut self, us: u32) {
            let rvr = us * (self.clocks.sysclk().0 / 1_000_000);
            if !(rvr < (1 << 24)) {
                ::core::panicking::panic("assertion failed: rvr < (1 << 24)")
            };
            self.syst.set_reload(rvr);
            self.syst.clear_current();
            self.syst.enable_counter();
            while !self.syst.has_wrapped() {}
            self.syst.disable_counter();
        }
    }
    impl DelayUs<u16> for Delay {
        fn delay_us(&mut self, us: u16) {
            self.delay_us(u32::from(us))
        }
    }
    impl DelayUs<u8> for Delay {
        fn delay_us(&mut self, us: u8) {
            self.delay_us(u32::from(us))
        }
    }
}
pub mod flash {
    #![doc = " Flash memory"]
    use crate::pac::{flash, FLASH};
    #[doc = " Extension trait to constrain the FLASH peripheral"]
    pub trait FlashExt {
        #[doc = " Constrains the FLASH peripheral to play nicely with the other abstractions"]
        fn constrain(self) -> Parts;
    }
    impl FlashExt for FLASH {
        fn constrain(self) -> Parts {
            Parts {
                acr: ACR { _0: () },
            }
        }
    }
    #[doc = " Constrained FLASH peripheral"]
    pub struct Parts {
        #[doc = " Opaque ACR register"]
        pub acr: ACR,
    }
    #[doc = " Opaque ACR register"]
    pub struct ACR {
        _0: (),
    }
    impl ACR {
        pub(crate) fn acr(&mut self) -> &flash::ACR {
            unsafe { &(*FLASH::ptr()).acr }
        }
    }
}
pub mod gpio {
    #![doc = " General Purpose Input / Output"]
    #![doc = ""]
    #![doc = " To use the GPIO pins, you first need to configure the GPIO bank (GPIOA, GPIOB, ...) that you"]
    #![doc = " are interested in. This is done using the [`GpioExt::split`] function."]
    #![doc = ""]
    #![doc = " ```"]
    #![doc = " let dp = pac::Peripherals::take().unwrap();"]
    #![doc = " let rcc = dp.RCC.constrain();"]
    #![doc = ""]
    #![doc = " let mut gpioa = dp.GPIOA.split(&mut rcc.ahb);"]
    #![doc = " ```"]
    #![doc = ""]
    #![doc = " The resulting [Parts](gpioa::Parts) struct contains one field for each"]
    #![doc = " pin, as well as some shared registers."]
    #![doc = ""]
    #![doc = " To use a pin, first use the relevant `into_...` method of the [pin](gpioa::PA0)."]
    #![doc = ""]
    #![doc = " ```rust"]
    #![doc = " let pa0 = gpioa.pa0.into_push_pull_output(&mut gpioa.moder, &mut gpioa.otyper);"]
    #![doc = " ```"]
    #![doc = ""]
    #![doc = " And finally, you can use the functions from the [InputPin] or [OutputPin] traits in"]
    #![doc = " `embedded_hal`"]
    #![doc = ""]
    #![doc = " For a complete example, see [examples/toggle.rs]"]
    #![doc = ""]
    #![doc = " [InputPin]: embedded_hal::digital::v2::InputPin"]
    #![doc = " [OutputPin]: embedded_hal::digital::v2::OutputPin"]
    #![doc = " [examples/toggle.rs]: https://github.com/stm32-rs/stm32f3xx-hal/blob/v0.6.0/examples/toggle.rs"]
    use core::convert::Infallible;
    use core::marker::PhantomData;
    #[cfg(feature = "unproven")]
    use crate::hal::digital::v2::toggleable;
    #[cfg(feature = "unproven")]
    use crate::hal::digital::v2::InputPin;
    #[cfg(feature = "unproven")]
    use crate::hal::digital::v2::OutputPin;
    #[cfg(feature = "unproven")]
    use crate::hal::digital::v2::StatefulOutputPin;
    use crate::rcc::AHB;
    #[doc = " Extension trait to split a GPIO peripheral in independent pins and registers"]
    pub trait GpioExt {
        #[doc = " The Parts to split the GPIO peripheral into"]
        type Parts;
        #[doc = " Splits the GPIO block into independent pins and registers"]
        fn split(self, ahb: &mut AHB) -> Self::Parts;
    }
    #[doc = " Input mode (type state)"]
    pub struct Input<MODE> {
        _mode: PhantomData<MODE>,
    }
    #[doc = " Floating input (type state)"]
    pub struct Floating;
    #[doc = " Pulled down input (type state)"]
    pub struct PullDown;
    #[doc = " Pulled up input (type state)"]
    pub struct PullUp;
    #[doc = " Output mode (type state)"]
    pub struct Output<MODE> {
        _mode: PhantomData<MODE>,
    }
    #[doc = " Push pull output (type state)"]
    pub struct PushPull;
    #[doc = " Open drain output (type state)"]
    pub struct OpenDrain;
    #[doc = " Analog mode (type state)"]
    pub struct Analog;
    #[doc = " Alternate function 0 (type state)"]
    pub struct AF0;
    #[doc = " Alternate function 1 (type state)"]
    pub struct AF1;
    #[doc = " Alternate function 2 (type state)"]
    pub struct AF2;
    #[doc = " Alternate function 3 (type state)"]
    pub struct AF3;
    #[doc = " Alternate function 4 (type state)"]
    pub struct AF4;
    #[doc = " Alternate function 5 (type state)"]
    pub struct AF5;
    #[doc = " Alternate function 6 (type state)"]
    pub struct AF6;
    #[doc = " Alternate function 7 (type state)"]
    pub struct AF7;
    #[doc = " Alternate function 8 (type state)"]
    pub struct AF8;
    #[doc = " Alternate function 9 (type state)"]
    pub struct AF9;
    #[doc = " Alternate function 10 (type state)"]
    pub struct AF10;
    #[doc = " Alternate function 11 (type state)"]
    pub struct AF11;
    #[doc = " Alternate function 12 (type state)"]
    pub struct AF12;
    #[doc = " Alternate function 13 (type state)"]
    pub struct AF13;
    #[doc = " Alternate function 14 (type state)"]
    pub struct AF14;
    #[doc = " Alternate function 15 (type state)"]
    pub struct AF15;
    pub enum Edge {
        RISING,
        FALLING,
        RISING_FALLING,
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::fmt::Debug for Edge {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            match (&*self,) {
                (&Edge::RISING,) => {
                    let mut debug_trait_builder = f.debug_tuple("RISING");
                    debug_trait_builder.finish()
                }
                (&Edge::FALLING,) => {
                    let mut debug_trait_builder = f.debug_tuple("FALLING");
                    debug_trait_builder.finish()
                }
                (&Edge::RISING_FALLING,) => {
                    let mut debug_trait_builder = f.debug_tuple("RISING_FALLING");
                    debug_trait_builder.finish()
                }
            }
        }
    }
    impl ::core::marker::StructuralPartialEq for Edge {}
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::cmp::PartialEq for Edge {
        #[inline]
        fn eq(&self, other: &Edge) -> bool {
            {
                let __self_vi = ::core::intrinsics::discriminant_value(&*self);
                let __arg_1_vi = ::core::intrinsics::discriminant_value(&*other);
                if true && __self_vi == __arg_1_vi {
                    match (&*self, &*other) {
                        _ => true,
                    }
                } else {
                    false
                }
            }
        }
    }
    #[doc = " External Interrupt Pin"]
    pub trait ExtiPin {
        fn make_interrupt_source(&mut self, syscfg: &mut SYSCFG);
        fn trigger_on_edge(&mut self, exti: &mut EXTI, level: Edge);
        fn enable_interrupt(&mut self, exti: &mut EXTI);
        fn disable_interrupt(&mut self, exti: &mut EXTI);
        fn clear_interrupt_pending_bit(&mut self);
    }
    use crate::pac::GPIOA;
    use crate::pac::GPIOB;
    use crate::pac::GPIOC;
    use crate::pac::GPIOD;
    use crate::pac::GPIOE;
    use crate::pac::GPIOF;
    use crate::stm32::{EXTI, SYSCFG};
    #[doc = " GPIO discriminator enum."]
    #[doc = ""]
    #[doc = " Use to store the gpio bank, when using"]
    #[doc = " fully erased pins [`PXx`]"]
    pub enum Gpio {
        #[doc = " GPIO Bank"]
        GPIOA,
        #[doc = " GPIO Bank"]
        GPIOB,
        #[doc = " GPIO Bank"]
        GPIOC,
        #[doc = " GPIO Bank"]
        GPIOD,
        #[doc = " GPIO Bank"]
        GPIOE,
        #[doc = " GPIO Bank"]
        GPIOF,
    }
    #[doc = " Fully erased pin"]
    #[doc = ""]
    #[doc = " This moves the pin type information to be known"]
    #[doc = " at runtime, and erases the specific compile time type of the GPIO."]
    #[doc = " It does only matter, that it is a GPIO pin with a specific MODE."]
    #[doc = ""]
    #[doc = " See [examples/gpio_erased.rs] as an example."]
    #[doc = ""]
    #[doc = " [examples/gpio_erased.rs]: https://github.com/stm32-rs/stm32f3xx-hal/blob/v0.6.0/examples/gpio_erased.rs"]
    pub struct PXx<MODE> {
        i: u8,
        gpio: Gpio,
        _mode: PhantomData<MODE>,
    }
    impl<MODE> OutputPin for PXx<Output<MODE>> {
        type Error = Infallible;
        fn set_high(&mut self) -> Result<(), Self::Error> {
            unsafe {
                match &self.gpio {
                    Gpio::GPIOA => (*GPIOA::ptr()).bsrr.write(|w| w.bits(1 << self.i)),
                    Gpio::GPIOB => (*GPIOB::ptr()).bsrr.write(|w| w.bits(1 << self.i)),
                    Gpio::GPIOC => (*GPIOC::ptr()).bsrr.write(|w| w.bits(1 << self.i)),
                    Gpio::GPIOD => (*GPIOD::ptr()).bsrr.write(|w| w.bits(1 << self.i)),
                    Gpio::GPIOE => (*GPIOE::ptr()).bsrr.write(|w| w.bits(1 << self.i)),
                    Gpio::GPIOF => (*GPIOF::ptr()).bsrr.write(|w| w.bits(1 << self.i)),
                }
            }
            Ok(())
        }
        fn set_low(&mut self) -> Result<(), Self::Error> {
            unsafe {
                match &self.gpio {
                    Gpio::GPIOA => (*GPIOA::ptr()).bsrr.write(|w| w.bits(1 << (16 + self.i))),
                    Gpio::GPIOB => (*GPIOB::ptr()).bsrr.write(|w| w.bits(1 << (16 + self.i))),
                    Gpio::GPIOC => (*GPIOC::ptr()).bsrr.write(|w| w.bits(1 << (16 + self.i))),
                    Gpio::GPIOD => (*GPIOD::ptr()).bsrr.write(|w| w.bits(1 << (16 + self.i))),
                    Gpio::GPIOE => (*GPIOE::ptr()).bsrr.write(|w| w.bits(1 << (16 + self.i))),
                    Gpio::GPIOF => (*GPIOF::ptr()).bsrr.write(|w| w.bits(1 << (16 + self.i))),
                }
            }
            Ok(())
        }
    }
    #[cfg(feature = "unproven")]
    impl<MODE> InputPin for PXx<Input<MODE>> {
        type Error = Infallible;
        fn is_high(&self) -> Result<bool, Self::Error> {
            Ok(!self.is_low()?)
        }
        fn is_low(&self) -> Result<bool, Self::Error> {
            Ok(unsafe {
                match &self.gpio {
                    Gpio::GPIOA => (*GPIOA::ptr()).idr.read().bits() & (1 << self.i) == 0,
                    Gpio::GPIOB => (*GPIOB::ptr()).idr.read().bits() & (1 << self.i) == 0,
                    Gpio::GPIOC => (*GPIOC::ptr()).idr.read().bits() & (1 << self.i) == 0,
                    Gpio::GPIOD => (*GPIOD::ptr()).idr.read().bits() & (1 << self.i) == 0,
                    Gpio::GPIOE => (*GPIOE::ptr()).idr.read().bits() & (1 << self.i) == 0,
                    Gpio::GPIOF => (*GPIOF::ptr()).idr.read().bits() & (1 << self.i) == 0,
                }
            })
        }
    }
    impl<MODE> ExtiPin for PXx<Input<MODE>> {
        #[doc = " Make corresponding EXTI line sensitive to this pin"]
        fn make_interrupt_source(&mut self, syscfg: &mut SYSCFG) {
            let offset = 4 * (self.i % 4);
            let extigpionr = match &self.gpio {
                Gpio::GPIOA => 0,
                Gpio::GPIOB => 1,
                Gpio::GPIOC => 2,
                Gpio::GPIOD => 3,
                Gpio::GPIOE => 4,
                Gpio::GPIOF => 5,
            };
            match self.i {
                0..=3 => {
                    syscfg.exticr1.modify(|r, w| unsafe {
                        w.bits((r.bits() & !(0xf << offset)) | (extigpionr << offset))
                    });
                }
                4..=7 => {
                    syscfg.exticr2.modify(|r, w| unsafe {
                        w.bits((r.bits() & !(0xf << offset)) | (extigpionr << offset))
                    });
                }
                8..=11 => {
                    syscfg.exticr3.modify(|r, w| unsafe {
                        w.bits((r.bits() & !(0xf << offset)) | (extigpionr << offset))
                    });
                }
                12..=15 => {
                    syscfg.exticr4.modify(|r, w| unsafe {
                        w.bits((r.bits() & !(0xf << offset)) | (extigpionr << offset))
                    });
                }
                _ => {}
            }
        }
        #[doc = " Generate interrupt on rising edge, falling edge or both"]
        fn trigger_on_edge(&mut self, exti: &mut EXTI, edge: Edge) {
            match edge {
                Edge::RISING => {
                    exti.rtsr1
                        .modify(|r, w| unsafe { w.bits(r.bits() | (1 << self.i)) });
                    exti.ftsr1
                        .modify(|r, w| unsafe { w.bits(r.bits() & !(1 << self.i)) });
                }
                Edge::FALLING => {
                    exti.ftsr1
                        .modify(|r, w| unsafe { w.bits(r.bits() | (1 << self.i)) });
                    exti.rtsr1
                        .modify(|r, w| unsafe { w.bits(r.bits() & !(1 << self.i)) });
                }
                Edge::RISING_FALLING => {
                    exti.rtsr1
                        .modify(|r, w| unsafe { w.bits(r.bits() | (1 << self.i)) });
                    exti.ftsr1
                        .modify(|r, w| unsafe { w.bits(r.bits() | (1 << self.i)) });
                }
            }
        }
        #[doc = " Enable external interrupts from this pin."]
        fn enable_interrupt(&mut self, exti: &mut EXTI) {
            exti.imr1
                .modify(|r, w| unsafe { w.bits(r.bits() | (1 << self.i)) });
        }
        #[doc = " Disable external interrupts from this pin"]
        fn disable_interrupt(&mut self, exti: &mut EXTI) {
            exti.imr1
                .modify(|r, w| unsafe { w.bits(r.bits() & !(1 << self.i)) });
        }
        #[doc = " Clear the interrupt pending bit for this pin"]
        fn clear_interrupt_pending_bit(&mut self) {
            unsafe { (*EXTI::ptr()).pr1.write(|w| w.bits(1 << self.i)) };
        }
    }
    #[cfg(feature = "unproven")]
    impl InputPin for PXx<Output<OpenDrain>> {
        type Error = Infallible;
        fn is_high(&self) -> Result<bool, Self::Error> {
            Ok(!self.is_low()?)
        }
        fn is_low(&self) -> Result<bool, Self::Error> {
            Ok(unsafe {
                match &self.gpio {
                    Gpio::GPIOA => (*GPIOA::ptr()).idr.read().bits() & (1 << self.i) == 0,
                    Gpio::GPIOB => (*GPIOB::ptr()).idr.read().bits() & (1 << self.i) == 0,
                    Gpio::GPIOC => (*GPIOC::ptr()).idr.read().bits() & (1 << self.i) == 0,
                    Gpio::GPIOD => (*GPIOD::ptr()).idr.read().bits() & (1 << self.i) == 0,
                    Gpio::GPIOE => (*GPIOE::ptr()).idr.read().bits() & (1 << self.i) == 0,
                    Gpio::GPIOF => (*GPIOF::ptr()).idr.read().bits() & (1 << self.i) == 0,
                }
            })
        }
    }
    #[cfg(feature = "unproven")]
    impl<MODE> StatefulOutputPin for PXx<Output<MODE>> {
        fn is_set_high(&self) -> Result<bool, Self::Error> {
            self.is_set_low().map(|b| !b)
        }
        fn is_set_low(&self) -> Result<bool, Self::Error> {
            Ok(unsafe {
                match &self.gpio {
                    Gpio::GPIOA => (*GPIOA::ptr()).odr.read().bits() & (1 << self.i) == 0,
                    Gpio::GPIOB => (*GPIOB::ptr()).odr.read().bits() & (1 << self.i) == 0,
                    Gpio::GPIOC => (*GPIOC::ptr()).odr.read().bits() & (1 << self.i) == 0,
                    Gpio::GPIOD => (*GPIOD::ptr()).odr.read().bits() & (1 << self.i) == 0,
                    Gpio::GPIOE => (*GPIOE::ptr()).odr.read().bits() & (1 << self.i) == 0,
                    Gpio::GPIOF => (*GPIOF::ptr()).odr.read().bits() & (1 << self.i) == 0,
                }
            })
        }
    }
    #[cfg(feature = "unproven")]
    impl<MODE> toggleable::Default for PXx<Output<MODE>> {}
    #[doc = "All Pins and associated functions for GPIO Bank: `GPIOA`"]
    pub mod gpioa {
        use core::marker::PhantomData;
        use core::convert::Infallible;
        use crate::hal::digital::v2::OutputPin;
        #[cfg(feature = "unproven")]
        use crate::hal::digital::v2::InputPin;
        #[cfg(feature = "unproven")]
        use crate::hal::digital::v2::StatefulOutputPin;
        #[cfg(feature = "unproven")]
        use crate::hal::digital::v2::toggleable;
        use crate::pac::{gpioa, GPIOA};
        use crate::rcc::AHB;
        #[allow(unused_imports)]
        use super::{
            AF0, AF1, AF2, AF3, AF4, AF5, AF6, AF7, AF8, AF9, AF10, AF11, AF12, AF13, AF14, AF15,
        };
        use super::{
            Floating, GpioExt, Input, OpenDrain, Output, Analog, PullDown, PullUp, PushPull, PXx,
            Gpio,
        };
        #[doc = " GPIO parts"]
        pub struct Parts {
            #[doc = " Opaque AFRH register"]
            pub afrh: AFRH,
            #[doc = " Opaque AFRL register"]
            pub afrl: AFRL,
            #[doc = " Opaque MODER register"]
            pub moder: MODER,
            #[doc = " Opaque OTYPER register"]
            pub otyper: OTYPER,
            #[doc = " Opaque PUPDR register"]
            pub pupdr: PUPDR,
            #[doc = " Pin"]
            pub pa0: PA0<Input<Floating>>,
            #[doc = " Pin"]
            pub pa1: PA1<Input<Floating>>,
            #[doc = " Pin"]
            pub pa2: PA2<Input<Floating>>,
            #[doc = " Pin"]
            pub pa3: PA3<Input<Floating>>,
            #[doc = " Pin"]
            pub pa4: PA4<Input<Floating>>,
            #[doc = " Pin"]
            pub pa5: PA5<Input<Floating>>,
            #[doc = " Pin"]
            pub pa6: PA6<Input<Floating>>,
            #[doc = " Pin"]
            pub pa7: PA7<Input<Floating>>,
            #[doc = " Pin"]
            pub pa8: PA8<Input<Floating>>,
            #[doc = " Pin"]
            pub pa9: PA9<Input<Floating>>,
            #[doc = " Pin"]
            pub pa10: PA10<Input<Floating>>,
            #[doc = " Pin"]
            pub pa11: PA11<Input<Floating>>,
            #[doc = " Pin"]
            pub pa12: PA12<Input<Floating>>,
            #[doc = " Pin"]
            pub pa13: PA13<AF0>,
            #[doc = " Pin"]
            pub pa14: PA14<AF0>,
            #[doc = " Pin"]
            pub pa15: PA15<AF0>,
        }
        impl GpioExt for GPIOA {
            type Parts = Parts;
            fn split(self, ahb: &mut AHB) -> Parts {
                ahb.enr().modify(|_, w| w.iopaen().set_bit());
                ahb.rstr().modify(|_, w| w.ioparst().set_bit());
                ahb.rstr().modify(|_, w| w.ioparst().clear_bit());
                Parts {
                    afrh: AFRH { _0: () },
                    afrl: AFRL { _0: () },
                    moder: MODER { _0: () },
                    otyper: OTYPER { _0: () },
                    pupdr: PUPDR { _0: () },
                    pa0: PA0 { _mode: PhantomData },
                    pa1: PA1 { _mode: PhantomData },
                    pa2: PA2 { _mode: PhantomData },
                    pa3: PA3 { _mode: PhantomData },
                    pa4: PA4 { _mode: PhantomData },
                    pa5: PA5 { _mode: PhantomData },
                    pa6: PA6 { _mode: PhantomData },
                    pa7: PA7 { _mode: PhantomData },
                    pa8: PA8 { _mode: PhantomData },
                    pa9: PA9 { _mode: PhantomData },
                    pa10: PA10 { _mode: PhantomData },
                    pa11: PA11 { _mode: PhantomData },
                    pa12: PA12 { _mode: PhantomData },
                    pa13: PA13 { _mode: PhantomData },
                    pa14: PA14 { _mode: PhantomData },
                    pa15: PA15 { _mode: PhantomData },
                }
            }
        }
        #[doc = " Opaque AFRL register"]
        pub struct AFRL {
            _0: (),
        }
        impl AFRL {
            #[allow(dead_code)]
            pub(crate) fn afr(&mut self) -> &gpioa::AFRL {
                unsafe { &(*GPIOA::ptr()).afrl }
            }
        }
        #[doc = " Opaque AFRH register"]
        pub struct AFRH {
            _0: (),
        }
        impl AFRH {
            #[allow(dead_code)]
            pub(crate) fn afr(&mut self) -> &gpioa::AFRH {
                unsafe { &(*GPIOA::ptr()).afrh }
            }
        }
        #[doc = " Opaque MODER register"]
        pub struct MODER {
            _0: (),
        }
        impl MODER {
            pub(crate) fn moder(&mut self) -> &gpioa::MODER {
                unsafe { &(*GPIOA::ptr()).moder }
            }
        }
        #[doc = " Opaque OTYPER register"]
        pub struct OTYPER {
            _0: (),
        }
        impl OTYPER {
            pub(crate) fn otyper(&mut self) -> &gpioa::OTYPER {
                unsafe { &(*GPIOA::ptr()).otyper }
            }
        }
        #[doc = " Opaque PUPDR register"]
        pub struct PUPDR {
            _0: (),
        }
        impl PUPDR {
            pub(crate) fn pupdr(&mut self) -> &gpioa::PUPDR {
                unsafe { &(*GPIOA::ptr()).pupdr }
            }
        }
        #[doc = " Partially erased pin"]
        pub struct PAx<MODE> {
            i: u8,
            _mode: PhantomData<MODE>,
        }
        impl<MODE> PAx<MODE> {
            #[doc = " Erases the port letter from the type"]
            #[doc = ""]
            #[doc = " This is useful when you want to collect the pins into an array where you"]
            #[doc = " need all the elements to have the same type"]
            pub fn downgrade(self) -> PXx<MODE> {
                PXx {
                    i: self.i,
                    gpio: Gpio::GPIOA,
                    _mode: self._mode,
                }
            }
        }
        impl<MODE> OutputPin for PAx<Output<MODE>> {
            type Error = Infallible;
            fn set_high(&mut self) -> Result<(), Self::Error> {
                unsafe { (*GPIOA::ptr()).bsrr.write(|w| w.bits(1 << self.i)) }
                Ok(())
            }
            fn set_low(&mut self) -> Result<(), Self::Error> {
                unsafe { (*GPIOA::ptr()).bsrr.write(|w| w.bits(1 << (16 + self.i))) }
                Ok(())
            }
        }
        #[cfg(feature = "unproven")]
        impl<MODE> InputPin for PAx<Input<MODE>> {
            type Error = Infallible;
            fn is_high(&self) -> Result<bool, Self::Error> {
                Ok(!self.is_low()?)
            }
            fn is_low(&self) -> Result<bool, Self::Error> {
                Ok(unsafe { (*GPIOA::ptr()).idr.read().bits() & (1 << self.i) == 0 })
            }
        }
        #[cfg(feature = "unproven")]
        impl InputPin for PAx<Output<OpenDrain>> {
            type Error = Infallible;
            fn is_high(&self) -> Result<bool, Self::Error> {
                Ok(!self.is_low()?)
            }
            fn is_low(&self) -> Result<bool, Self::Error> {
                Ok(unsafe { (*GPIOA::ptr()).idr.read().bits() & (1 << self.i) == 0 })
            }
        }
        #[cfg(feature = "unproven")]
        impl<MODE> StatefulOutputPin for PAx<Output<MODE>> {
            fn is_set_high(&self) -> Result<bool, Self::Error> {
                self.is_set_low().map(|b| !b)
            }
            fn is_set_low(&self) -> Result<bool, Self::Error> {
                Ok(unsafe { (*GPIOA::ptr()).odr.read().bits() & (1 << self.i) == 0 })
            }
        }
        #[cfg(feature = "unproven")]
        impl<MODE> toggleable::Default for PAx<Output<MODE>> {}
        #[doc = "Pin `PA0`"]
        pub struct PA0<MODE> {
            _mode: PhantomData<MODE>,
        }
        impl<MODE> PA0<MODE> {
            #[doc = "Configures `PA0` to serve as alternate function: `AF1`"]
            pub fn into_af1(self, moder: &mut MODER, afr: &mut AFRL) -> PA0<AF1> {
                moder.moder().modify(|_, w| w.moder0().alternate());
                afr.afr().modify(|_, w| w.afrl0().af1());
                PA0 { _mode: PhantomData }
            }
            #[doc = "Configures `PA0` to serve as alternate function: `AF3`"]
            pub fn into_af3(self, moder: &mut MODER, afr: &mut AFRL) -> PA0<AF3> {
                moder.moder().modify(|_, w| w.moder0().alternate());
                afr.afr().modify(|_, w| w.afrl0().af3());
                PA0 { _mode: PhantomData }
            }
            #[doc = "Configures `PA0` to serve as alternate function: `AF7`"]
            pub fn into_af7(self, moder: &mut MODER, afr: &mut AFRL) -> PA0<AF7> {
                moder.moder().modify(|_, w| w.moder0().alternate());
                afr.afr().modify(|_, w| w.afrl0().af7());
                PA0 { _mode: PhantomData }
            }
            #[doc = "Configures `PA0` to serve as alternate function: `AF8`"]
            pub fn into_af8(self, moder: &mut MODER, afr: &mut AFRL) -> PA0<AF8> {
                moder.moder().modify(|_, w| w.moder0().alternate());
                afr.afr().modify(|_, w| w.afrl0().af8());
                PA0 { _mode: PhantomData }
            }
            #[doc = "Configures `PA0` to serve as alternate function: `AF9`"]
            pub fn into_af9(self, moder: &mut MODER, afr: &mut AFRL) -> PA0<AF9> {
                moder.moder().modify(|_, w| w.moder0().alternate());
                afr.afr().modify(|_, w| w.afrl0().af9());
                PA0 { _mode: PhantomData }
            }
            #[doc = "Configures `PA0` to serve as alternate function: `AF10`"]
            pub fn into_af10(self, moder: &mut MODER, afr: &mut AFRL) -> PA0<AF10> {
                moder.moder().modify(|_, w| w.moder0().alternate());
                afr.afr().modify(|_, w| w.afrl0().af10());
                PA0 { _mode: PhantomData }
            }
            #[doc = "Configures `PA0` to serve as alternate function: `AF15`"]
            pub fn into_af15(self, moder: &mut MODER, afr: &mut AFRL) -> PA0<AF15> {
                moder.moder().modify(|_, w| w.moder0().alternate());
                afr.afr().modify(|_, w| w.afrl0().af15());
                PA0 { _mode: PhantomData }
            }
            #[doc = " Configures the pin to operate as a floating input pin"]
            pub fn into_floating_input(
                self,
                moder: &mut MODER,
                pupdr: &mut PUPDR,
            ) -> PA0<Input<Floating>> {
                moder.moder().modify(|_, w| w.moder0().input());
                pupdr.pupdr().modify(|_, w| w.pupdr0().floating());
                PA0 { _mode: PhantomData }
            }
            #[doc = " Configures the pin to operate as a pulled down input pin"]
            pub fn into_pull_down_input(
                self,
                moder: &mut MODER,
                pupdr: &mut PUPDR,
            ) -> PA0<Input<PullDown>> {
                moder.moder().modify(|_, w| w.moder0().input());
                pupdr.pupdr().modify(|_, w| w.pupdr0().pull_down());
                PA0 { _mode: PhantomData }
            }
            #[doc = " Configures the pin to operate as a pulled up input pin"]
            pub fn into_pull_up_input(
                self,
                moder: &mut MODER,
                pupdr: &mut PUPDR,
            ) -> PA0<Input<PullUp>> {
                moder.moder().modify(|_, w| w.moder0().input());
                pupdr.pupdr().modify(|_, w| w.pupdr0().pull_up());
                PA0 { _mode: PhantomData }
            }
            #[doc = " Configures the pin to operate as an open drain output pin"]
            pub fn into_open_drain_output(
                self,
                moder: &mut MODER,
                otyper: &mut OTYPER,
            ) -> PA0<Output<OpenDrain>> {
                moder.moder().modify(|_, w| w.moder0().output());
                otyper.otyper().modify(|_, w| w.ot0().open_drain());
                PA0 { _mode: PhantomData }
            }
            #[doc = " Configures the pin to operate as an push pull output pin"]
            pub fn into_push_pull_output(
                self,
                moder: &mut MODER,
                otyper: &mut OTYPER,
            ) -> PA0<Output<PushPull>> {
                moder.moder().modify(|_, w| w.moder0().output());
                otyper.otyper().modify(|_, w| w.ot0().push_pull());
                PA0 { _mode: PhantomData }
            }
            #[doc = " Configures the pin to operate as analog, with disabled schmitt trigger."]
            #[doc = " This mode is suitable when the pin is connected to the DAC or ADC."]
            pub fn into_analog(self, moder: &mut MODER, pupdr: &mut PUPDR) -> PA0<Analog> {
                moder.moder().modify(|_, w| w.moder0().analog());
                pupdr.pupdr().modify(|_, w| w.pupdr0().floating());
                PA0 { _mode: PhantomData }
            }
        }
        impl PA0<Output<OpenDrain>> {
            #[doc = " Enables / disables the internal pull up"]
            pub fn internal_pull_up(&mut self, pupdr: &mut PUPDR, on: bool) {
                pupdr.pupdr().modify(|_, w| {
                    if on {
                        w.pupdr0().pull_up()
                    } else {
                        w.pupdr0().floating()
                    }
                });
            }
        }
        impl<MODE> PA0<Output<MODE>> {
            #[doc = " Erases the pin number from the type"]
            #[doc = ""]
            #[doc = " This is useful when you want to collect the pins into an array where you"]
            #[doc = " need all the elements to have the same type"]
            pub fn downgrade(self) -> PAx<Output<MODE>> {
                PAx {
                    i: 0,
                    _mode: self._mode,
                }
            }
        }
        impl<MODE> PA0<Input<MODE>> {
            #[doc = " Erases the pin number from the type"]
            #[doc = ""]
            #[doc = " This is useful when you want to collect the pins into an array where you"]
            #[doc = " need all the elements to have the same type"]
            pub fn downgrade(self) -> PAx<Input<MODE>> {
                PAx {
                    i: 0,
                    _mode: self._mode,
                }
            }
        }
        impl<MODE> OutputPin for PA0<Output<MODE>> {
            type Error = Infallible;
            fn set_high(&mut self) -> Result<(), Self::Error> {
                unsafe { (*GPIOA::ptr()).bsrr.write(|w| w.bs0().set()) }
                Ok(())
            }
            fn set_low(&mut self) -> Result<(), Self::Error> {
                unsafe { (*GPIOA::ptr()).bsrr.write(|w| w.br0().reset()) }
                Ok(())
            }
        }
        #[cfg(feature = "unproven")]
        impl<MODE> InputPin for PA0<Input<MODE>> {
            type Error = Infallible;
            fn is_high(&self) -> Result<bool, Self::Error> {
                Ok(!self.is_low()?)
            }
            fn is_low(&self) -> Result<bool, Self::Error> {
                Ok(unsafe { (*GPIOA::ptr()).idr.read().idr0().is_low() })
            }
        }
        #[cfg(feature = "unproven")]
        impl InputPin for PA0<Output<OpenDrain>> {
            type Error = Infallible;
            fn is_high(&self) -> Result<bool, Self::Error> {
                Ok(!self.is_low()?)
            }
            fn is_low(&self) -> Result<bool, Self::Error> {
                Ok(unsafe { (*GPIOA::ptr()).idr.read().idr0().is_low() })
            }
        }
        #[cfg(feature = "unproven")]
        impl<MODE> StatefulOutputPin for PA0<Output<MODE>> {
            fn is_set_high(&self) -> Result<bool, Self::Error> {
                self.is_set_low().map(|b| !b)
            }
            fn is_set_low(&self) -> Result<bool, Self::Error> {
                Ok(unsafe { (*GPIOA::ptr()).odr.read().odr0().is_low() })
            }
        }
        #[cfg(feature = "unproven")]
        impl<MODE> toggleable::Default for PA0<Output<MODE>> {}
        #[doc = "Pin `PA1`"]
        pub struct PA1<MODE> {
            _mode: PhantomData<MODE>,
        }
        impl<MODE> PA1<MODE> {
            #[doc = "Configures `PA1` to serve as alternate function: `AF0`"]
            pub fn into_af0(self, moder: &mut MODER, afr: &mut AFRL) -> PA1<AF0> {
                moder.moder().modify(|_, w| w.moder1().alternate());
                afr.afr().modify(|_, w| w.afrl1().af0());
                PA1 { _mode: PhantomData }
            }
            #[doc = "Configures `PA1` to serve as alternate function: `AF1`"]
            pub fn into_af1(self, moder: &mut MODER, afr: &mut AFRL) -> PA1<AF1> {
                moder.moder().modify(|_, w| w.moder1().alternate());
                afr.afr().modify(|_, w| w.afrl1().af1());
                PA1 { _mode: PhantomData }
            }
            #[doc = "Configures `PA1` to serve as alternate function: `AF3`"]
            pub fn into_af3(self, moder: &mut MODER, afr: &mut AFRL) -> PA1<AF3> {
                moder.moder().modify(|_, w| w.moder1().alternate());
                afr.afr().modify(|_, w| w.afrl1().af3());
                PA1 { _mode: PhantomData }
            }
            #[doc = "Configures `PA1` to serve as alternate function: `AF7`"]
            pub fn into_af7(self, moder: &mut MODER, afr: &mut AFRL) -> PA1<AF7> {
                moder.moder().modify(|_, w| w.moder1().alternate());
                afr.afr().modify(|_, w| w.afrl1().af7());
                PA1 { _mode: PhantomData }
            }
            #[doc = "Configures `PA1` to serve as alternate function: `AF9`"]
            pub fn into_af9(self, moder: &mut MODER, afr: &mut AFRL) -> PA1<AF9> {
                moder.moder().modify(|_, w| w.moder1().alternate());
                afr.afr().modify(|_, w| w.afrl1().af9());
                PA1 { _mode: PhantomData }
            }
            #[doc = "Configures `PA1` to serve as alternate function: `AF15`"]
            pub fn into_af15(self, moder: &mut MODER, afr: &mut AFRL) -> PA1<AF15> {
                moder.moder().modify(|_, w| w.moder1().alternate());
                afr.afr().modify(|_, w| w.afrl1().af15());
                PA1 { _mode: PhantomData }
            }
            #[doc = " Configures the pin to operate as a floating input pin"]
            pub fn into_floating_input(
                self,
                moder: &mut MODER,
                pupdr: &mut PUPDR,
            ) -> PA1<Input<Floating>> {
                moder.moder().modify(|_, w| w.moder1().input());
                pupdr.pupdr().modify(|_, w| w.pupdr1().floating());
                PA1 { _mode: PhantomData }
            }
            #[doc = " Configures the pin to operate as a pulled down input pin"]
            pub fn into_pull_down_input(
                self,
                moder: &mut MODER,
                pupdr: &mut PUPDR,
            ) -> PA1<Input<PullDown>> {
                moder.moder().modify(|_, w| w.moder1().input());
                pupdr.pupdr().modify(|_, w| w.pupdr1().pull_down());
                PA1 { _mode: PhantomData }
            }
            #[doc = " Configures the pin to operate as a pulled up input pin"]
            pub fn into_pull_up_input(
                self,
                moder: &mut MODER,
                pupdr: &mut PUPDR,
            ) -> PA1<Input<PullUp>> {
                moder.moder().modify(|_, w| w.moder1().input());
                pupdr.pupdr().modify(|_, w| w.pupdr1().pull_up());
                PA1 { _mode: PhantomData }
            }
            #[doc = " Configures the pin to operate as an open drain output pin"]
            pub fn into_open_drain_output(
                self,
                moder: &mut MODER,
                otyper: &mut OTYPER,
            ) -> PA1<Output<OpenDrain>> {
                moder.moder().modify(|_, w| w.moder1().output());
                otyper.otyper().modify(|_, w| w.ot1().open_drain());
                PA1 { _mode: PhantomData }
            }
            #[doc = " Configures the pin to operate as an push pull output pin"]
            pub fn into_push_pull_output(
                self,
                moder: &mut MODER,
                otyper: &mut OTYPER,
            ) -> PA1<Output<PushPull>> {
                moder.moder().modify(|_, w| w.moder1().output());
                otyper.otyper().modify(|_, w| w.ot1().push_pull());
                PA1 { _mode: PhantomData }
            }
            #[doc = " Configures the pin to operate as analog, with disabled schmitt trigger."]
            #[doc = " This mode is suitable when the pin is connected to the DAC or ADC."]
            pub fn into_analog(self, moder: &mut MODER, pupdr: &mut PUPDR) -> PA1<Analog> {
                moder.moder().modify(|_, w| w.moder1().analog());
                pupdr.pupdr().modify(|_, w| w.pupdr1().floating());
                PA1 { _mode: PhantomData }
            }
        }
        impl PA1<Output<OpenDrain>> {
            #[doc = " Enables / disables the internal pull up"]
            pub fn internal_pull_up(&mut self, pupdr: &mut PUPDR, on: bool) {
                pupdr.pupdr().modify(|_, w| {
                    if on {
                        w.pupdr1().pull_up()
                    } else {
                        w.pupdr1().floating()
                    }
                });
            }
        }
        impl<MODE> PA1<Output<MODE>> {
            #[doc = " Erases the pin number from the type"]
            #[doc = ""]
            #[doc = " This is useful when you want to collect the pins into an array where you"]
            #[doc = " need all the elements to have the same type"]
            pub fn downgrade(self) -> PAx<Output<MODE>> {
                PAx {
                    i: 1,
                    _mode: self._mode,
                }
            }
        }
        impl<MODE> PA1<Input<MODE>> {
            #[doc = " Erases the pin number from the type"]
            #[doc = ""]
            #[doc = " This is useful when you want to collect the pins into an array where you"]
            #[doc = " need all the elements to have the same type"]
            pub fn downgrade(self) -> PAx<Input<MODE>> {
                PAx {
                    i: 1,
                    _mode: self._mode,
                }
            }
        }
        impl<MODE> OutputPin for PA1<Output<MODE>> {
            type Error = Infallible;
            fn set_high(&mut self) -> Result<(), Self::Error> {
                unsafe { (*GPIOA::ptr()).bsrr.write(|w| w.bs1().set()) }
                Ok(())
            }
            fn set_low(&mut self) -> Result<(), Self::Error> {
                unsafe { (*GPIOA::ptr()).bsrr.write(|w| w.br1().reset()) }
                Ok(())
            }
        }
        #[cfg(feature = "unproven")]
        impl<MODE> InputPin for PA1<Input<MODE>> {
            type Error = Infallible;
            fn is_high(&self) -> Result<bool, Self::Error> {
                Ok(!self.is_low()?)
            }
            fn is_low(&self) -> Result<bool, Self::Error> {
                Ok(unsafe { (*GPIOA::ptr()).idr.read().idr1().is_low() })
            }
        }
        #[cfg(feature = "unproven")]
        impl InputPin for PA1<Output<OpenDrain>> {
            type Error = Infallible;
            fn is_high(&self) -> Result<bool, Self::Error> {
                Ok(!self.is_low()?)
            }
            fn is_low(&self) -> Result<bool, Self::Error> {
                Ok(unsafe { (*GPIOA::ptr()).idr.read().idr1().is_low() })
            }
        }
        #[cfg(feature = "unproven")]
        impl<MODE> StatefulOutputPin for PA1<Output<MODE>> {
            fn is_set_high(&self) -> Result<bool, Self::Error> {
                self.is_set_low().map(|b| !b)
            }
            fn is_set_low(&self) -> Result<bool, Self::Error> {
                Ok(unsafe { (*GPIOA::ptr()).odr.read().odr1().is_low() })
            }
        }
        #[cfg(feature = "unproven")]
        impl<MODE> toggleable::Default for PA1<Output<MODE>> {}
        #[doc = "Pin `PA2`"]
        pub struct PA2<MODE> {
            _mode: PhantomData<MODE>,
        }
        impl<MODE> PA2<MODE> {
            #[doc = "Configures `PA2` to serve as alternate function: `AF1`"]
            pub fn into_af1(self, moder: &mut MODER, afr: &mut AFRL) -> PA2<AF1> {
                moder.moder().modify(|_, w| w.moder2().alternate());
                afr.afr().modify(|_, w| w.afrl2().af1());
                PA2 { _mode: PhantomData }
            }
            #[doc = "Configures `PA2` to serve as alternate function: `AF3`"]
            pub fn into_af3(self, moder: &mut MODER, afr: &mut AFRL) -> PA2<AF3> {
                moder.moder().modify(|_, w| w.moder2().alternate());
                afr.afr().modify(|_, w| w.afrl2().af3());
                PA2 { _mode: PhantomData }
            }
            #[doc = "Configures `PA2` to serve as alternate function: `AF7`"]
            pub fn into_af7(self, moder: &mut MODER, afr: &mut AFRL) -> PA2<AF7> {
                moder.moder().modify(|_, w| w.moder2().alternate());
                afr.afr().modify(|_, w| w.afrl2().af7());
                PA2 { _mode: PhantomData }
            }
            #[doc = "Configures `PA2` to serve as alternate function: `AF8`"]
            pub fn into_af8(self, moder: &mut MODER, afr: &mut AFRL) -> PA2<AF8> {
                moder.moder().modify(|_, w| w.moder2().alternate());
                afr.afr().modify(|_, w| w.afrl2().af8());
                PA2 { _mode: PhantomData }
            }
            #[doc = "Configures `PA2` to serve as alternate function: `AF9`"]
            pub fn into_af9(self, moder: &mut MODER, afr: &mut AFRL) -> PA2<AF9> {
                moder.moder().modify(|_, w| w.moder2().alternate());
                afr.afr().modify(|_, w| w.afrl2().af9());
                PA2 { _mode: PhantomData }
            }
            #[doc = "Configures `PA2` to serve as alternate function: `AF15`"]
            pub fn into_af15(self, moder: &mut MODER, afr: &mut AFRL) -> PA2<AF15> {
                moder.moder().modify(|_, w| w.moder2().alternate());
                afr.afr().modify(|_, w| w.afrl2().af15());
                PA2 { _mode: PhantomData }
            }
            #[doc = " Configures the pin to operate as a floating input pin"]
            pub fn into_floating_input(
                self,
                moder: &mut MODER,
                pupdr: &mut PUPDR,
            ) -> PA2<Input<Floating>> {
                moder.moder().modify(|_, w| w.moder2().input());
                pupdr.pupdr().modify(|_, w| w.pupdr2().floating());
                PA2 { _mode: PhantomData }
            }
            #[doc = " Configures the pin to operate as a pulled down input pin"]
            pub fn into_pull_down_input(
                self,
                moder: &mut MODER,
                pupdr: &mut PUPDR,
            ) -> PA2<Input<PullDown>> {
                moder.moder().modify(|_, w| w.moder2().input());
                pupdr.pupdr().modify(|_, w| w.pupdr2().pull_down());
                PA2 { _mode: PhantomData }
            }
            #[doc = " Configures the pin to operate as a pulled up input pin"]
            pub fn into_pull_up_input(
                self,
                moder: &mut MODER,
                pupdr: &mut PUPDR,
            ) -> PA2<Input<PullUp>> {
                moder.moder().modify(|_, w| w.moder2().input());
                pupdr.pupdr().modify(|_, w| w.pupdr2().pull_up());
                PA2 { _mode: PhantomData }
            }
            #[doc = " Configures the pin to operate as an open drain output pin"]
            pub fn into_open_drain_output(
                self,
                moder: &mut MODER,
                otyper: &mut OTYPER,
            ) -> PA2<Output<OpenDrain>> {
                moder.moder().modify(|_, w| w.moder2().output());
                otyper.otyper().modify(|_, w| w.ot2().open_drain());
                PA2 { _mode: PhantomData }
            }
            #[doc = " Configures the pin to operate as an push pull output pin"]
            pub fn into_push_pull_output(
                self,
                moder: &mut MODER,
                otyper: &mut OTYPER,
            ) -> PA2<Output<PushPull>> {
                moder.moder().modify(|_, w| w.moder2().output());
                otyper.otyper().modify(|_, w| w.ot2().push_pull());
                PA2 { _mode: PhantomData }
            }
            #[doc = " Configures the pin to operate as analog, with disabled schmitt trigger."]
            #[doc = " This mode is suitable when the pin is connected to the DAC or ADC."]
            pub fn into_analog(self, moder: &mut MODER, pupdr: &mut PUPDR) -> PA2<Analog> {
                moder.moder().modify(|_, w| w.moder2().analog());
                pupdr.pupdr().modify(|_, w| w.pupdr2().floating());
                PA2 { _mode: PhantomData }
            }
        }
        impl PA2<Output<OpenDrain>> {
            #[doc = " Enables / disables the internal pull up"]
            pub fn internal_pull_up(&mut self, pupdr: &mut PUPDR, on: bool) {
                pupdr.pupdr().modify(|_, w| {
                    if on {
                        w.pupdr2().pull_up()
                    } else {
                        w.pupdr2().floating()
                    }
                });
            }
        }
        impl<MODE> PA2<Output<MODE>> {
            #[doc = " Erases the pin number from the type"]
            #[doc = ""]
            #[doc = " This is useful when you want to collect the pins into an array where you"]
            #[doc = " need all the elements to have the same type"]
            pub fn downgrade(self) -> PAx<Output<MODE>> {
                PAx {
                    i: 2,
                    _mode: self._mode,
                }
            }
        }
        impl<MODE> PA2<Input<MODE>> {
            #[doc = " Erases the pin number from the type"]
            #[doc = ""]
            #[doc = " This is useful when you want to collect the pins into an array where you"]
            #[doc = " need all the elements to have the same type"]
            pub fn downgrade(self) -> PAx<Input<MODE>> {
                PAx {
                    i: 2,
                    _mode: self._mode,
                }
            }
        }
        impl<MODE> OutputPin for PA2<Output<MODE>> {
            type Error = Infallible;
            fn set_high(&mut self) -> Result<(), Self::Error> {
                unsafe { (*GPIOA::ptr()).bsrr.write(|w| w.bs2().set()) }
                Ok(())
            }
            fn set_low(&mut self) -> Result<(), Self::Error> {
                unsafe { (*GPIOA::ptr()).bsrr.write(|w| w.br2().reset()) }
                Ok(())
            }
        }
        #[cfg(feature = "unproven")]
        impl<MODE> InputPin for PA2<Input<MODE>> {
            type Error = Infallible;
            fn is_high(&self) -> Result<bool, Self::Error> {
                Ok(!self.is_low()?)
            }
            fn is_low(&self) -> Result<bool, Self::Error> {
                Ok(unsafe { (*GPIOA::ptr()).idr.read().idr2().is_low() })
            }
        }
        #[cfg(feature = "unproven")]
        impl InputPin for PA2<Output<OpenDrain>> {
            type Error = Infallible;
            fn is_high(&self) -> Result<bool, Self::Error> {
                Ok(!self.is_low()?)
            }
            fn is_low(&self) -> Result<bool, Self::Error> {
                Ok(unsafe { (*GPIOA::ptr()).idr.read().idr2().is_low() })
            }
        }
        #[cfg(feature = "unproven")]
        impl<MODE> StatefulOutputPin for PA2<Output<MODE>> {
            fn is_set_high(&self) -> Result<bool, Self::Error> {
                self.is_set_low().map(|b| !b)
            }
            fn is_set_low(&self) -> Result<bool, Self::Error> {
                Ok(unsafe { (*GPIOA::ptr()).odr.read().odr2().is_low() })
            }
        }
        #[cfg(feature = "unproven")]
        impl<MODE> toggleable::Default for PA2<Output<MODE>> {}
        #[doc = "Pin `PA3`"]
        pub struct PA3<MODE> {
            _mode: PhantomData<MODE>,
        }
        impl<MODE> PA3<MODE> {
            #[doc = "Configures `PA3` to serve as alternate function: `AF1`"]
            pub fn into_af1(self, moder: &mut MODER, afr: &mut AFRL) -> PA3<AF1> {
                moder.moder().modify(|_, w| w.moder3().alternate());
                afr.afr().modify(|_, w| w.afrl3().af1());
                PA3 { _mode: PhantomData }
            }
            #[doc = "Configures `PA3` to serve as alternate function: `AF3`"]
            pub fn into_af3(self, moder: &mut MODER, afr: &mut AFRL) -> PA3<AF3> {
                moder.moder().modify(|_, w| w.moder3().alternate());
                afr.afr().modify(|_, w| w.afrl3().af3());
                PA3 { _mode: PhantomData }
            }
            #[doc = "Configures `PA3` to serve as alternate function: `AF7`"]
            pub fn into_af7(self, moder: &mut MODER, afr: &mut AFRL) -> PA3<AF7> {
                moder.moder().modify(|_, w| w.moder3().alternate());
                afr.afr().modify(|_, w| w.afrl3().af7());
                PA3 { _mode: PhantomData }
            }
            #[doc = "Configures `PA3` to serve as alternate function: `AF9`"]
            pub fn into_af9(self, moder: &mut MODER, afr: &mut AFRL) -> PA3<AF9> {
                moder.moder().modify(|_, w| w.moder3().alternate());
                afr.afr().modify(|_, w| w.afrl3().af9());
                PA3 { _mode: PhantomData }
            }
            #[doc = "Configures `PA3` to serve as alternate function: `AF15`"]
            pub fn into_af15(self, moder: &mut MODER, afr: &mut AFRL) -> PA3<AF15> {
                moder.moder().modify(|_, w| w.moder3().alternate());
                afr.afr().modify(|_, w| w.afrl3().af15());
                PA3 { _mode: PhantomData }
            }
            #[doc = " Configures the pin to operate as a floating input pin"]
            pub fn into_floating_input(
                self,
                moder: &mut MODER,
                pupdr: &mut PUPDR,
            ) -> PA3<Input<Floating>> {
                moder.moder().modify(|_, w| w.moder3().input());
                pupdr.pupdr().modify(|_, w| w.pupdr3().floating());
                PA3 { _mode: PhantomData }
            }
            #[doc = " Configures the pin to operate as a pulled down input pin"]
            pub fn into_pull_down_input(
                self,
                moder: &mut MODER,
                pupdr: &mut PUPDR,
            ) -> PA3<Input<PullDown>> {
                moder.moder().modify(|_, w| w.moder3().input());
                pupdr.pupdr().modify(|_, w| w.pupdr3().pull_down());
                PA3 { _mode: PhantomData }
            }
            #[doc = " Configures the pin to operate as a pulled up input pin"]
            pub fn into_pull_up_input(
                self,
                moder: &mut MODER,
                pupdr: &mut PUPDR,
            ) -> PA3<Input<PullUp>> {
                moder.moder().modify(|_, w| w.moder3().input());
                pupdr.pupdr().modify(|_, w| w.pupdr3().pull_up());
                PA3 { _mode: PhantomData }
            }
            #[doc = " Configures the pin to operate as an open drain output pin"]
            pub fn into_open_drain_output(
                self,
                moder: &mut MODER,
                otyper: &mut OTYPER,
            ) -> PA3<Output<OpenDrain>> {
                moder.moder().modify(|_, w| w.moder3().output());
                otyper.otyper().modify(|_, w| w.ot3().open_drain());
                PA3 { _mode: PhantomData }
            }
            #[doc = " Configures the pin to operate as an push pull output pin"]
            pub fn into_push_pull_output(
                self,
                moder: &mut MODER,
                otyper: &mut OTYPER,
            ) -> PA3<Output<PushPull>> {
                moder.moder().modify(|_, w| w.moder3().output());
                otyper.otyper().modify(|_, w| w.ot3().push_pull());
                PA3 { _mode: PhantomData }
            }
            #[doc = " Configures the pin to operate as analog, with disabled schmitt trigger."]
            #[doc = " This mode is suitable when the pin is connected to the DAC or ADC."]
            pub fn into_analog(self, moder: &mut MODER, pupdr: &mut PUPDR) -> PA3<Analog> {
                moder.moder().modify(|_, w| w.moder3().analog());
                pupdr.pupdr().modify(|_, w| w.pupdr3().floating());
                PA3 { _mode: PhantomData }
            }
        }
        impl PA3<Output<OpenDrain>> {
            #[doc = " Enables / disables the internal pull up"]
            pub fn internal_pull_up(&mut self, pupdr: &mut PUPDR, on: bool) {
                pupdr.pupdr().modify(|_, w| {
                    if on {
                        w.pupdr3().pull_up()
                    } else {
                        w.pupdr3().floating()
                    }
                });
            }
        }
        impl<MODE> PA3<Output<MODE>> {
            #[doc = " Erases the pin number from the type"]
            #[doc = ""]
            #[doc = " This is useful when you want to collect the pins into an array where you"]
            #[doc = " need all the elements to have the same type"]
            pub fn downgrade(self) -> PAx<Output<MODE>> {
                PAx {
                    i: 3,
                    _mode: self._mode,
                }
            }
        }
        impl<MODE> PA3<Input<MODE>> {
            #[doc = " Erases the pin number from the type"]
            #[doc = ""]
            #[doc = " This is useful when you want to collect the pins into an array where you"]
            #[doc = " need all the elements to have the same type"]
            pub fn downgrade(self) -> PAx<Input<MODE>> {
                PAx {
                    i: 3,
                    _mode: self._mode,
                }
            }
        }
        impl<MODE> OutputPin for PA3<Output<MODE>> {
            type Error = Infallible;
            fn set_high(&mut self) -> Result<(), Self::Error> {
                unsafe { (*GPIOA::ptr()).bsrr.write(|w| w.bs3().set()) }
                Ok(())
            }
            fn set_low(&mut self) -> Result<(), Self::Error> {
                unsafe { (*GPIOA::ptr()).bsrr.write(|w| w.br3().reset()) }
                Ok(())
            }
        }
        #[cfg(feature = "unproven")]
        impl<MODE> InputPin for PA3<Input<MODE>> {
            type Error = Infallible;
            fn is_high(&self) -> Result<bool, Self::Error> {
                Ok(!self.is_low()?)
            }
            fn is_low(&self) -> Result<bool, Self::Error> {
                Ok(unsafe { (*GPIOA::ptr()).idr.read().idr3().is_low() })
            }
        }
        #[cfg(feature = "unproven")]
        impl InputPin for PA3<Output<OpenDrain>> {
            type Error = Infallible;
            fn is_high(&self) -> Result<bool, Self::Error> {
                Ok(!self.is_low()?)
            }
            fn is_low(&self) -> Result<bool, Self::Error> {
                Ok(unsafe { (*GPIOA::ptr()).idr.read().idr3().is_low() })
            }
        }
        #[cfg(feature = "unproven")]
        impl<MODE> StatefulOutputPin for PA3<Output<MODE>> {
            fn is_set_high(&self) -> Result<bool, Self::Error> {
                self.is_set_low().map(|b| !b)
            }
            fn is_set_low(&self) -> Result<bool, Self::Error> {
                Ok(unsafe { (*GPIOA::ptr()).odr.read().odr3().is_low() })
            }
        }
        #[cfg(feature = "unproven")]
        impl<MODE> toggleable::Default for PA3<Output<MODE>> {}
        #[doc = "Pin `PA4`"]
        pub struct PA4<MODE> {
            _mode: PhantomData<MODE>,
        }
        impl<MODE> PA4<MODE> {
            #[doc = "Configures `PA4` to serve as alternate function: `AF2`"]
            pub fn into_af2(self, moder: &mut MODER, afr: &mut AFRL) -> PA4<AF2> {
                moder.moder().modify(|_, w| w.moder4().alternate());
                afr.afr().modify(|_, w| w.afrl4().af2());
                PA4 { _mode: PhantomData }
            }
            #[doc = "Configures `PA4` to serve as alternate function: `AF3`"]
            pub fn into_af3(self, moder: &mut MODER, afr: &mut AFRL) -> PA4<AF3> {
                moder.moder().modify(|_, w| w.moder4().alternate());
                afr.afr().modify(|_, w| w.afrl4().af3());
                PA4 { _mode: PhantomData }
            }
            #[doc = "Configures `PA4` to serve as alternate function: `AF5`"]
            pub fn into_af5(self, moder: &mut MODER, afr: &mut AFRL) -> PA4<AF5> {
                moder.moder().modify(|_, w| w.moder4().alternate());
                afr.afr().modify(|_, w| w.afrl4().af5());
                PA4 { _mode: PhantomData }
            }
            #[doc = "Configures `PA4` to serve as alternate function: `AF6`"]
            pub fn into_af6(self, moder: &mut MODER, afr: &mut AFRL) -> PA4<AF6> {
                moder.moder().modify(|_, w| w.moder4().alternate());
                afr.afr().modify(|_, w| w.afrl4().af6());
                PA4 { _mode: PhantomData }
            }
            #[doc = "Configures `PA4` to serve as alternate function: `AF7`"]
            pub fn into_af7(self, moder: &mut MODER, afr: &mut AFRL) -> PA4<AF7> {
                moder.moder().modify(|_, w| w.moder4().alternate());
                afr.afr().modify(|_, w| w.afrl4().af7());
                PA4 { _mode: PhantomData }
            }
            #[doc = "Configures `PA4` to serve as alternate function: `AF15`"]
            pub fn into_af15(self, moder: &mut MODER, afr: &mut AFRL) -> PA4<AF15> {
                moder.moder().modify(|_, w| w.moder4().alternate());
                afr.afr().modify(|_, w| w.afrl4().af15());
                PA4 { _mode: PhantomData }
            }
            #[doc = " Configures the pin to operate as a floating input pin"]
            pub fn into_floating_input(
                self,
                moder: &mut MODER,
                pupdr: &mut PUPDR,
            ) -> PA4<Input<Floating>> {
                moder.moder().modify(|_, w| w.moder4().input());
                pupdr.pupdr().modify(|_, w| w.pupdr4().floating());
                PA4 { _mode: PhantomData }
            }
            #[doc = " Configures the pin to operate as a pulled down input pin"]
            pub fn into_pull_down_input(
                self,
                moder: &mut MODER,
                pupdr: &mut PUPDR,
            ) -> PA4<Input<PullDown>> {
                moder.moder().modify(|_, w| w.moder4().input());
                pupdr.pupdr().modify(|_, w| w.pupdr4().pull_down());
                PA4 { _mode: PhantomData }
            }
            #[doc = " Configures the pin to operate as a pulled up input pin"]
            pub fn into_pull_up_input(
                self,
                moder: &mut MODER,
                pupdr: &mut PUPDR,
            ) -> PA4<Input<PullUp>> {
                moder.moder().modify(|_, w| w.moder4().input());
                pupdr.pupdr().modify(|_, w| w.pupdr4().pull_up());
                PA4 { _mode: PhantomData }
            }
            #[doc = " Configures the pin to operate as an open drain output pin"]
            pub fn into_open_drain_output(
                self,
                moder: &mut MODER,
                otyper: &mut OTYPER,
            ) -> PA4<Output<OpenDrain>> {
                moder.moder().modify(|_, w| w.moder4().output());
                otyper.otyper().modify(|_, w| w.ot4().open_drain());
                PA4 { _mode: PhantomData }
            }
            #[doc = " Configures the pin to operate as an push pull output pin"]
            pub fn into_push_pull_output(
                self,
                moder: &mut MODER,
                otyper: &mut OTYPER,
            ) -> PA4<Output<PushPull>> {
                moder.moder().modify(|_, w| w.moder4().output());
                otyper.otyper().modify(|_, w| w.ot4().push_pull());
                PA4 { _mode: PhantomData }
            }
            #[doc = " Configures the pin to operate as analog, with disabled schmitt trigger."]
            #[doc = " This mode is suitable when the pin is connected to the DAC or ADC."]
            pub fn into_analog(self, moder: &mut MODER, pupdr: &mut PUPDR) -> PA4<Analog> {
                moder.moder().modify(|_, w| w.moder4().analog());
                pupdr.pupdr().modify(|_, w| w.pupdr4().floating());
                PA4 { _mode: PhantomData }
            }
        }
        impl PA4<Output<OpenDrain>> {
            #[doc = " Enables / disables the internal pull up"]
            pub fn internal_pull_up(&mut self, pupdr: &mut PUPDR, on: bool) {
                pupdr.pupdr().modify(|_, w| {
                    if on {
                        w.pupdr4().pull_up()
                    } else {
                        w.pupdr4().floating()
                    }
                });
            }
        }
        impl<MODE> PA4<Output<MODE>> {
            #[doc = " Erases the pin number from the type"]
            #[doc = ""]
            #[doc = " This is useful when you want to collect the pins into an array where you"]
            #[doc = " need all the elements to have the same type"]
            pub fn downgrade(self) -> PAx<Output<MODE>> {
                PAx {
                    i: 4,
                    _mode: self._mode,
                }
            }
        }
        impl<MODE> PA4<Input<MODE>> {
            #[doc = " Erases the pin number from the type"]
            #[doc = ""]
            #[doc = " This is useful when you want to collect the pins into an array where you"]
            #[doc = " need all the elements to have the same type"]
            pub fn downgrade(self) -> PAx<Input<MODE>> {
                PAx {
                    i: 4,
                    _mode: self._mode,
                }
            }
        }
        impl<MODE> OutputPin for PA4<Output<MODE>> {
            type Error = Infallible;
            fn set_high(&mut self) -> Result<(), Self::Error> {
                unsafe { (*GPIOA::ptr()).bsrr.write(|w| w.bs4().set()) }
                Ok(())
            }
            fn set_low(&mut self) -> Result<(), Self::Error> {
                unsafe { (*GPIOA::ptr()).bsrr.write(|w| w.br4().reset()) }
                Ok(())
            }
        }
        #[cfg(feature = "unproven")]
        impl<MODE> InputPin for PA4<Input<MODE>> {
            type Error = Infallible;
            fn is_high(&self) -> Result<bool, Self::Error> {
                Ok(!self.is_low()?)
            }
            fn is_low(&self) -> Result<bool, Self::Error> {
                Ok(unsafe { (*GPIOA::ptr()).idr.read().idr4().is_low() })
            }
        }
        #[cfg(feature = "unproven")]
        impl InputPin for PA4<Output<OpenDrain>> {
            type Error = Infallible;
            fn is_high(&self) -> Result<bool, Self::Error> {
                Ok(!self.is_low()?)
            }
            fn is_low(&self) -> Result<bool, Self::Error> {
                Ok(unsafe { (*GPIOA::ptr()).idr.read().idr4().is_low() })
            }
        }
        #[cfg(feature = "unproven")]
        impl<MODE> StatefulOutputPin for PA4<Output<MODE>> {
            fn is_set_high(&self) -> Result<bool, Self::Error> {
                self.is_set_low().map(|b| !b)
            }
            fn is_set_low(&self) -> Result<bool, Self::Error> {
                Ok(unsafe { (*GPIOA::ptr()).odr.read().odr4().is_low() })
            }
        }
        #[cfg(feature = "unproven")]
        impl<MODE> toggleable::Default for PA4<Output<MODE>> {}
        #[doc = "Pin `PA5`"]
        pub struct PA5<MODE> {
            _mode: PhantomData<MODE>,
        }
        impl<MODE> PA5<MODE> {
            #[doc = "Configures `PA5` to serve as alternate function: `AF1`"]
            pub fn into_af1(self, moder: &mut MODER, afr: &mut AFRL) -> PA5<AF1> {
                moder.moder().modify(|_, w| w.moder5().alternate());
                afr.afr().modify(|_, w| w.afrl5().af1());
                PA5 { _mode: PhantomData }
            }
            #[doc = "Configures `PA5` to serve as alternate function: `AF3`"]
            pub fn into_af3(self, moder: &mut MODER, afr: &mut AFRL) -> PA5<AF3> {
                moder.moder().modify(|_, w| w.moder5().alternate());
                afr.afr().modify(|_, w| w.afrl5().af3());
                PA5 { _mode: PhantomData }
            }
            #[doc = "Configures `PA5` to serve as alternate function: `AF5`"]
            pub fn into_af5(self, moder: &mut MODER, afr: &mut AFRL) -> PA5<AF5> {
                moder.moder().modify(|_, w| w.moder5().alternate());
                afr.afr().modify(|_, w| w.afrl5().af5());
                PA5 { _mode: PhantomData }
            }
            #[doc = "Configures `PA5` to serve as alternate function: `AF15`"]
            pub fn into_af15(self, moder: &mut MODER, afr: &mut AFRL) -> PA5<AF15> {
                moder.moder().modify(|_, w| w.moder5().alternate());
                afr.afr().modify(|_, w| w.afrl5().af15());
                PA5 { _mode: PhantomData }
            }
            #[doc = " Configures the pin to operate as a floating input pin"]
            pub fn into_floating_input(
                self,
                moder: &mut MODER,
                pupdr: &mut PUPDR,
            ) -> PA5<Input<Floating>> {
                moder.moder().modify(|_, w| w.moder5().input());
                pupdr.pupdr().modify(|_, w| w.pupdr5().floating());
                PA5 { _mode: PhantomData }
            }
            #[doc = " Configures the pin to operate as a pulled down input pin"]
            pub fn into_pull_down_input(
                self,
                moder: &mut MODER,
                pupdr: &mut PUPDR,
            ) -> PA5<Input<PullDown>> {
                moder.moder().modify(|_, w| w.moder5().input());
                pupdr.pupdr().modify(|_, w| w.pupdr5().pull_down());
                PA5 { _mode: PhantomData }
            }
            #[doc = " Configures the pin to operate as a pulled up input pin"]
            pub fn into_pull_up_input(
                self,
                moder: &mut MODER,
                pupdr: &mut PUPDR,
            ) -> PA5<Input<PullUp>> {
                moder.moder().modify(|_, w| w.moder5().input());
                pupdr.pupdr().modify(|_, w| w.pupdr5().pull_up());
                PA5 { _mode: PhantomData }
            }
            #[doc = " Configures the pin to operate as an open drain output pin"]
            pub fn into_open_drain_output(
                self,
                moder: &mut MODER,
                otyper: &mut OTYPER,
            ) -> PA5<Output<OpenDrain>> {
                moder.moder().modify(|_, w| w.moder5().output());
                otyper.otyper().modify(|_, w| w.ot5().open_drain());
                PA5 { _mode: PhantomData }
            }
            #[doc = " Configures the pin to operate as an push pull output pin"]
            pub fn into_push_pull_output(
                self,
                moder: &mut MODER,
                otyper: &mut OTYPER,
            ) -> PA5<Output<PushPull>> {
                moder.moder().modify(|_, w| w.moder5().output());
                otyper.otyper().modify(|_, w| w.ot5().push_pull());
                PA5 { _mode: PhantomData }
            }
            #[doc = " Configures the pin to operate as analog, with disabled schmitt trigger."]
            #[doc = " This mode is suitable when the pin is connected to the DAC or ADC."]
            pub fn into_analog(self, moder: &mut MODER, pupdr: &mut PUPDR) -> PA5<Analog> {
                moder.moder().modify(|_, w| w.moder5().analog());
                pupdr.pupdr().modify(|_, w| w.pupdr5().floating());
                PA5 { _mode: PhantomData }
            }
        }
        impl PA5<Output<OpenDrain>> {
            #[doc = " Enables / disables the internal pull up"]
            pub fn internal_pull_up(&mut self, pupdr: &mut PUPDR, on: bool) {
                pupdr.pupdr().modify(|_, w| {
                    if on {
                        w.pupdr5().pull_up()
                    } else {
                        w.pupdr5().floating()
                    }
                });
            }
        }
        impl<MODE> PA5<Output<MODE>> {
            #[doc = " Erases the pin number from the type"]
            #[doc = ""]
            #[doc = " This is useful when you want to collect the pins into an array where you"]
            #[doc = " need all the elements to have the same type"]
            pub fn downgrade(self) -> PAx<Output<MODE>> {
                PAx {
                    i: 5,
                    _mode: self._mode,
                }
            }
        }
        impl<MODE> PA5<Input<MODE>> {
            #[doc = " Erases the pin number from the type"]
            #[doc = ""]
            #[doc = " This is useful when you want to collect the pins into an array where you"]
            #[doc = " need all the elements to have the same type"]
            pub fn downgrade(self) -> PAx<Input<MODE>> {
                PAx {
                    i: 5,
                    _mode: self._mode,
                }
            }
        }
        impl<MODE> OutputPin for PA5<Output<MODE>> {
            type Error = Infallible;
            fn set_high(&mut self) -> Result<(), Self::Error> {
                unsafe { (*GPIOA::ptr()).bsrr.write(|w| w.bs5().set()) }
                Ok(())
            }
            fn set_low(&mut self) -> Result<(), Self::Error> {
                unsafe { (*GPIOA::ptr()).bsrr.write(|w| w.br5().reset()) }
                Ok(())
            }
        }
        #[cfg(feature = "unproven")]
        impl<MODE> InputPin for PA5<Input<MODE>> {
            type Error = Infallible;
            fn is_high(&self) -> Result<bool, Self::Error> {
                Ok(!self.is_low()?)
            }
            fn is_low(&self) -> Result<bool, Self::Error> {
                Ok(unsafe { (*GPIOA::ptr()).idr.read().idr5().is_low() })
            }
        }
        #[cfg(feature = "unproven")]
        impl InputPin for PA5<Output<OpenDrain>> {
            type Error = Infallible;
            fn is_high(&self) -> Result<bool, Self::Error> {
                Ok(!self.is_low()?)
            }
            fn is_low(&self) -> Result<bool, Self::Error> {
                Ok(unsafe { (*GPIOA::ptr()).idr.read().idr5().is_low() })
            }
        }
        #[cfg(feature = "unproven")]
        impl<MODE> StatefulOutputPin for PA5<Output<MODE>> {
            fn is_set_high(&self) -> Result<bool, Self::Error> {
                self.is_set_low().map(|b| !b)
            }
            fn is_set_low(&self) -> Result<bool, Self::Error> {
                Ok(unsafe { (*GPIOA::ptr()).odr.read().odr5().is_low() })
            }
        }
        #[cfg(feature = "unproven")]
        impl<MODE> toggleable::Default for PA5<Output<MODE>> {}
        #[doc = "Pin `PA6`"]
        pub struct PA6<MODE> {
            _mode: PhantomData<MODE>,
        }
        impl<MODE> PA6<MODE> {
            #[doc = "Configures `PA6` to serve as alternate function: `AF1`"]
            pub fn into_af1(self, moder: &mut MODER, afr: &mut AFRL) -> PA6<AF1> {
                moder.moder().modify(|_, w| w.moder6().alternate());
                afr.afr().modify(|_, w| w.afrl6().af1());
                PA6 { _mode: PhantomData }
            }
            #[doc = "Configures `PA6` to serve as alternate function: `AF2`"]
            pub fn into_af2(self, moder: &mut MODER, afr: &mut AFRL) -> PA6<AF2> {
                moder.moder().modify(|_, w| w.moder6().alternate());
                afr.afr().modify(|_, w| w.afrl6().af2());
                PA6 { _mode: PhantomData }
            }
            #[doc = "Configures `PA6` to serve as alternate function: `AF3`"]
            pub fn into_af3(self, moder: &mut MODER, afr: &mut AFRL) -> PA6<AF3> {
                moder.moder().modify(|_, w| w.moder6().alternate());
                afr.afr().modify(|_, w| w.afrl6().af3());
                PA6 { _mode: PhantomData }
            }
            #[doc = "Configures `PA6` to serve as alternate function: `AF4`"]
            pub fn into_af4(self, moder: &mut MODER, afr: &mut AFRL) -> PA6<AF4> {
                moder.moder().modify(|_, w| w.moder6().alternate());
                afr.afr().modify(|_, w| w.afrl6().af4());
                PA6 { _mode: PhantomData }
            }
            #[doc = "Configures `PA6` to serve as alternate function: `AF5`"]
            pub fn into_af5(self, moder: &mut MODER, afr: &mut AFRL) -> PA6<AF5> {
                moder.moder().modify(|_, w| w.moder6().alternate());
                afr.afr().modify(|_, w| w.afrl6().af5());
                PA6 { _mode: PhantomData }
            }
            #[doc = "Configures `PA6` to serve as alternate function: `AF6`"]
            pub fn into_af6(self, moder: &mut MODER, afr: &mut AFRL) -> PA6<AF6> {
                moder.moder().modify(|_, w| w.moder6().alternate());
                afr.afr().modify(|_, w| w.afrl6().af6());
                PA6 { _mode: PhantomData }
            }
            #[doc = "Configures `PA6` to serve as alternate function: `AF8`"]
            pub fn into_af8(self, moder: &mut MODER, afr: &mut AFRL) -> PA6<AF8> {
                moder.moder().modify(|_, w| w.moder6().alternate());
                afr.afr().modify(|_, w| w.afrl6().af8());
                PA6 { _mode: PhantomData }
            }
            #[doc = "Configures `PA6` to serve as alternate function: `AF15`"]
            pub fn into_af15(self, moder: &mut MODER, afr: &mut AFRL) -> PA6<AF15> {
                moder.moder().modify(|_, w| w.moder6().alternate());
                afr.afr().modify(|_, w| w.afrl6().af15());
                PA6 { _mode: PhantomData }
            }
            #[doc = " Configures the pin to operate as a floating input pin"]
            pub fn into_floating_input(
                self,
                moder: &mut MODER,
                pupdr: &mut PUPDR,
            ) -> PA6<Input<Floating>> {
                moder.moder().modify(|_, w| w.moder6().input());
                pupdr.pupdr().modify(|_, w| w.pupdr6().floating());
                PA6 { _mode: PhantomData }
            }
            #[doc = " Configures the pin to operate as a pulled down input pin"]
            pub fn into_pull_down_input(
                self,
                moder: &mut MODER,
                pupdr: &mut PUPDR,
            ) -> PA6<Input<PullDown>> {
                moder.moder().modify(|_, w| w.moder6().input());
                pupdr.pupdr().modify(|_, w| w.pupdr6().pull_down());
                PA6 { _mode: PhantomData }
            }
            #[doc = " Configures the pin to operate as a pulled up input pin"]
            pub fn into_pull_up_input(
                self,
                moder: &mut MODER,
                pupdr: &mut PUPDR,
            ) -> PA6<Input<PullUp>> {
                moder.moder().modify(|_, w| w.moder6().input());
                pupdr.pupdr().modify(|_, w| w.pupdr6().pull_up());
                PA6 { _mode: PhantomData }
            }
            #[doc = " Configures the pin to operate as an open drain output pin"]
            pub fn into_open_drain_output(
                self,
                moder: &mut MODER,
                otyper: &mut OTYPER,
            ) -> PA6<Output<OpenDrain>> {
                moder.moder().modify(|_, w| w.moder6().output());
                otyper.otyper().modify(|_, w| w.ot6().open_drain());
                PA6 { _mode: PhantomData }
            }
            #[doc = " Configures the pin to operate as an push pull output pin"]
            pub fn into_push_pull_output(
                self,
                moder: &mut MODER,
                otyper: &mut OTYPER,
            ) -> PA6<Output<PushPull>> {
                moder.moder().modify(|_, w| w.moder6().output());
                otyper.otyper().modify(|_, w| w.ot6().push_pull());
                PA6 { _mode: PhantomData }
            }
            #[doc = " Configures the pin to operate as analog, with disabled schmitt trigger."]
            #[doc = " This mode is suitable when the pin is connected to the DAC or ADC."]
            pub fn into_analog(self, moder: &mut MODER, pupdr: &mut PUPDR) -> PA6<Analog> {
                moder.moder().modify(|_, w| w.moder6().analog());
                pupdr.pupdr().modify(|_, w| w.pupdr6().floating());
                PA6 { _mode: PhantomData }
            }
        }
        impl PA6<Output<OpenDrain>> {
            #[doc = " Enables / disables the internal pull up"]
            pub fn internal_pull_up(&mut self, pupdr: &mut PUPDR, on: bool) {
                pupdr.pupdr().modify(|_, w| {
                    if on {
                        w.pupdr6().pull_up()
                    } else {
                        w.pupdr6().floating()
                    }
                });
            }
        }
        impl<MODE> PA6<Output<MODE>> {
            #[doc = " Erases the pin number from the type"]
            #[doc = ""]
            #[doc = " This is useful when you want to collect the pins into an array where you"]
            #[doc = " need all the elements to have the same type"]
            pub fn downgrade(self) -> PAx<Output<MODE>> {
                PAx {
                    i: 6,
                    _mode: self._mode,
                }
            }
        }
        impl<MODE> PA6<Input<MODE>> {
            #[doc = " Erases the pin number from the type"]
            #[doc = ""]
            #[doc = " This is useful when you want to collect the pins into an array where you"]
            #[doc = " need all the elements to have the same type"]
            pub fn downgrade(self) -> PAx<Input<MODE>> {
                PAx {
                    i: 6,
                    _mode: self._mode,
                }
            }
        }
        impl<MODE> OutputPin for PA6<Output<MODE>> {
            type Error = Infallible;
            fn set_high(&mut self) -> Result<(), Self::Error> {
                unsafe { (*GPIOA::ptr()).bsrr.write(|w| w.bs6().set()) }
                Ok(())
            }
            fn set_low(&mut self) -> Result<(), Self::Error> {
                unsafe { (*GPIOA::ptr()).bsrr.write(|w| w.br6().reset()) }
                Ok(())
            }
        }
        #[cfg(feature = "unproven")]
        impl<MODE> InputPin for PA6<Input<MODE>> {
            type Error = Infallible;
            fn is_high(&self) -> Result<bool, Self::Error> {
                Ok(!self.is_low()?)
            }
            fn is_low(&self) -> Result<bool, Self::Error> {
                Ok(unsafe { (*GPIOA::ptr()).idr.read().idr6().is_low() })
            }
        }
        #[cfg(feature = "unproven")]
        impl InputPin for PA6<Output<OpenDrain>> {
            type Error = Infallible;
            fn is_high(&self) -> Result<bool, Self::Error> {
                Ok(!self.is_low()?)
            }
            fn is_low(&self) -> Result<bool, Self::Error> {
                Ok(unsafe { (*GPIOA::ptr()).idr.read().idr6().is_low() })
            }
        }
        #[cfg(feature = "unproven")]
        impl<MODE> StatefulOutputPin for PA6<Output<MODE>> {
            fn is_set_high(&self) -> Result<bool, Self::Error> {
                self.is_set_low().map(|b| !b)
            }
            fn is_set_low(&self) -> Result<bool, Self::Error> {
                Ok(unsafe { (*GPIOA::ptr()).odr.read().odr6().is_low() })
            }
        }
        #[cfg(feature = "unproven")]
        impl<MODE> toggleable::Default for PA6<Output<MODE>> {}
        #[doc = "Pin `PA7`"]
        pub struct PA7<MODE> {
            _mode: PhantomData<MODE>,
        }
        impl<MODE> PA7<MODE> {
            #[doc = "Configures `PA7` to serve as alternate function: `AF1`"]
            pub fn into_af1(self, moder: &mut MODER, afr: &mut AFRL) -> PA7<AF1> {
                moder.moder().modify(|_, w| w.moder7().alternate());
                afr.afr().modify(|_, w| w.afrl7().af1());
                PA7 { _mode: PhantomData }
            }
            #[doc = "Configures `PA7` to serve as alternate function: `AF2`"]
            pub fn into_af2(self, moder: &mut MODER, afr: &mut AFRL) -> PA7<AF2> {
                moder.moder().modify(|_, w| w.moder7().alternate());
                afr.afr().modify(|_, w| w.afrl7().af2());
                PA7 { _mode: PhantomData }
            }
            #[doc = "Configures `PA7` to serve as alternate function: `AF3`"]
            pub fn into_af3(self, moder: &mut MODER, afr: &mut AFRL) -> PA7<AF3> {
                moder.moder().modify(|_, w| w.moder7().alternate());
                afr.afr().modify(|_, w| w.afrl7().af3());
                PA7 { _mode: PhantomData }
            }
            #[doc = "Configures `PA7` to serve as alternate function: `AF4`"]
            pub fn into_af4(self, moder: &mut MODER, afr: &mut AFRL) -> PA7<AF4> {
                moder.moder().modify(|_, w| w.moder7().alternate());
                afr.afr().modify(|_, w| w.afrl7().af4());
                PA7 { _mode: PhantomData }
            }
            #[doc = "Configures `PA7` to serve as alternate function: `AF5`"]
            pub fn into_af5(self, moder: &mut MODER, afr: &mut AFRL) -> PA7<AF5> {
                moder.moder().modify(|_, w| w.moder7().alternate());
                afr.afr().modify(|_, w| w.afrl7().af5());
                PA7 { _mode: PhantomData }
            }
            #[doc = "Configures `PA7` to serve as alternate function: `AF6`"]
            pub fn into_af6(self, moder: &mut MODER, afr: &mut AFRL) -> PA7<AF6> {
                moder.moder().modify(|_, w| w.moder7().alternate());
                afr.afr().modify(|_, w| w.afrl7().af6());
                PA7 { _mode: PhantomData }
            }
            #[doc = "Configures `PA7` to serve as alternate function: `AF8`"]
            pub fn into_af8(self, moder: &mut MODER, afr: &mut AFRL) -> PA7<AF8> {
                moder.moder().modify(|_, w| w.moder7().alternate());
                afr.afr().modify(|_, w| w.afrl7().af8());
                PA7 { _mode: PhantomData }
            }
            #[doc = "Configures `PA7` to serve as alternate function: `AF15`"]
            pub fn into_af15(self, moder: &mut MODER, afr: &mut AFRL) -> PA7<AF15> {
                moder.moder().modify(|_, w| w.moder7().alternate());
                afr.afr().modify(|_, w| w.afrl7().af15());
                PA7 { _mode: PhantomData }
            }
            #[doc = " Configures the pin to operate as a floating input pin"]
            pub fn into_floating_input(
                self,
                moder: &mut MODER,
                pupdr: &mut PUPDR,
            ) -> PA7<Input<Floating>> {
                moder.moder().modify(|_, w| w.moder7().input());
                pupdr.pupdr().modify(|_, w| w.pupdr7().floating());
                PA7 { _mode: PhantomData }
            }
            #[doc = " Configures the pin to operate as a pulled down input pin"]
            pub fn into_pull_down_input(
                self,
                moder: &mut MODER,
                pupdr: &mut PUPDR,
            ) -> PA7<Input<PullDown>> {
                moder.moder().modify(|_, w| w.moder7().input());
                pupdr.pupdr().modify(|_, w| w.pupdr7().pull_down());
                PA7 { _mode: PhantomData }
            }
            #[doc = " Configures the pin to operate as a pulled up input pin"]
            pub fn into_pull_up_input(
                self,
                moder: &mut MODER,
                pupdr: &mut PUPDR,
            ) -> PA7<Input<PullUp>> {
                moder.moder().modify(|_, w| w.moder7().input());
                pupdr.pupdr().modify(|_, w| w.pupdr7().pull_up());
                PA7 { _mode: PhantomData }
            }
            #[doc = " Configures the pin to operate as an open drain output pin"]
            pub fn into_open_drain_output(
                self,
                moder: &mut MODER,
                otyper: &mut OTYPER,
            ) -> PA7<Output<OpenDrain>> {
                moder.moder().modify(|_, w| w.moder7().output());
                otyper.otyper().modify(|_, w| w.ot7().open_drain());
                PA7 { _mode: PhantomData }
            }
            #[doc = " Configures the pin to operate as an push pull output pin"]
            pub fn into_push_pull_output(
                self,
                moder: &mut MODER,
                otyper: &mut OTYPER,
            ) -> PA7<Output<PushPull>> {
                moder.moder().modify(|_, w| w.moder7().output());
                otyper.otyper().modify(|_, w| w.ot7().push_pull());
                PA7 { _mode: PhantomData }
            }
            #[doc = " Configures the pin to operate as analog, with disabled schmitt trigger."]
            #[doc = " This mode is suitable when the pin is connected to the DAC or ADC."]
            pub fn into_analog(self, moder: &mut MODER, pupdr: &mut PUPDR) -> PA7<Analog> {
                moder.moder().modify(|_, w| w.moder7().analog());
                pupdr.pupdr().modify(|_, w| w.pupdr7().floating());
                PA7 { _mode: PhantomData }
            }
        }
        impl PA7<Output<OpenDrain>> {
            #[doc = " Enables / disables the internal pull up"]
            pub fn internal_pull_up(&mut self, pupdr: &mut PUPDR, on: bool) {
                pupdr.pupdr().modify(|_, w| {
                    if on {
                        w.pupdr7().pull_up()
                    } else {
                        w.pupdr7().floating()
                    }
                });
            }
        }
        impl<MODE> PA7<Output<MODE>> {
            #[doc = " Erases the pin number from the type"]
            #[doc = ""]
            #[doc = " This is useful when you want to collect the pins into an array where you"]
            #[doc = " need all the elements to have the same type"]
            pub fn downgrade(self) -> PAx<Output<MODE>> {
                PAx {
                    i: 7,
                    _mode: self._mode,
                }
            }
        }
        impl<MODE> PA7<Input<MODE>> {
            #[doc = " Erases the pin number from the type"]
            #[doc = ""]
            #[doc = " This is useful when you want to collect the pins into an array where you"]
            #[doc = " need all the elements to have the same type"]
            pub fn downgrade(self) -> PAx<Input<MODE>> {
                PAx {
                    i: 7,
                    _mode: self._mode,
                }
            }
        }
        impl<MODE> OutputPin for PA7<Output<MODE>> {
            type Error = Infallible;
            fn set_high(&mut self) -> Result<(), Self::Error> {
                unsafe { (*GPIOA::ptr()).bsrr.write(|w| w.bs7().set()) }
                Ok(())
            }
            fn set_low(&mut self) -> Result<(), Self::Error> {
                unsafe { (*GPIOA::ptr()).bsrr.write(|w| w.br7().reset()) }
                Ok(())
            }
        }
        #[cfg(feature = "unproven")]
        impl<MODE> InputPin for PA7<Input<MODE>> {
            type Error = Infallible;
            fn is_high(&self) -> Result<bool, Self::Error> {
                Ok(!self.is_low()?)
            }
            fn is_low(&self) -> Result<bool, Self::Error> {
                Ok(unsafe { (*GPIOA::ptr()).idr.read().idr7().is_low() })
            }
        }
        #[cfg(feature = "unproven")]
        impl InputPin for PA7<Output<OpenDrain>> {
            type Error = Infallible;
            fn is_high(&self) -> Result<bool, Self::Error> {
                Ok(!self.is_low()?)
            }
            fn is_low(&self) -> Result<bool, Self::Error> {
                Ok(unsafe { (*GPIOA::ptr()).idr.read().idr7().is_low() })
            }
        }
        #[cfg(feature = "unproven")]
        impl<MODE> StatefulOutputPin for PA7<Output<MODE>> {
            fn is_set_high(&self) -> Result<bool, Self::Error> {
                self.is_set_low().map(|b| !b)
            }
            fn is_set_low(&self) -> Result<bool, Self::Error> {
                Ok(unsafe { (*GPIOA::ptr()).odr.read().odr7().is_low() })
            }
        }
        #[cfg(feature = "unproven")]
        impl<MODE> toggleable::Default for PA7<Output<MODE>> {}
        #[doc = "Pin `PA8`"]
        pub struct PA8<MODE> {
            _mode: PhantomData<MODE>,
        }
        impl<MODE> PA8<MODE> {
            #[doc = "Configures `PA8` to serve as alternate function: `AF0`"]
            pub fn into_af0(self, moder: &mut MODER, afr: &mut AFRH) -> PA8<AF0> {
                moder.moder().modify(|_, w| w.moder8().alternate());
                afr.afr().modify(|_, w| w.afrh8().af0());
                PA8 { _mode: PhantomData }
            }
            #[doc = "Configures `PA8` to serve as alternate function: `AF4`"]
            pub fn into_af4(self, moder: &mut MODER, afr: &mut AFRH) -> PA8<AF4> {
                moder.moder().modify(|_, w| w.moder8().alternate());
                afr.afr().modify(|_, w| w.afrh8().af4());
                PA8 { _mode: PhantomData }
            }
            #[doc = "Configures `PA8` to serve as alternate function: `AF5`"]
            pub fn into_af5(self, moder: &mut MODER, afr: &mut AFRH) -> PA8<AF5> {
                moder.moder().modify(|_, w| w.moder8().alternate());
                afr.afr().modify(|_, w| w.afrh8().af5());
                PA8 { _mode: PhantomData }
            }
            #[doc = "Configures `PA8` to serve as alternate function: `AF6`"]
            pub fn into_af6(self, moder: &mut MODER, afr: &mut AFRH) -> PA8<AF6> {
                moder.moder().modify(|_, w| w.moder8().alternate());
                afr.afr().modify(|_, w| w.afrh8().af6());
                PA8 { _mode: PhantomData }
            }
            #[doc = "Configures `PA8` to serve as alternate function: `AF7`"]
            pub fn into_af7(self, moder: &mut MODER, afr: &mut AFRH) -> PA8<AF7> {
                moder.moder().modify(|_, w| w.moder8().alternate());
                afr.afr().modify(|_, w| w.afrh8().af7());
                PA8 { _mode: PhantomData }
            }
            #[doc = "Configures `PA8` to serve as alternate function: `AF8`"]
            pub fn into_af8(self, moder: &mut MODER, afr: &mut AFRH) -> PA8<AF8> {
                moder.moder().modify(|_, w| w.moder8().alternate());
                afr.afr().modify(|_, w| w.afrh8().af8());
                PA8 { _mode: PhantomData }
            }
            #[doc = "Configures `PA8` to serve as alternate function: `AF10`"]
            pub fn into_af10(self, moder: &mut MODER, afr: &mut AFRH) -> PA8<AF10> {
                moder.moder().modify(|_, w| w.moder8().alternate());
                afr.afr().modify(|_, w| w.afrh8().af10());
                PA8 { _mode: PhantomData }
            }
            #[doc = "Configures `PA8` to serve as alternate function: `AF15`"]
            pub fn into_af15(self, moder: &mut MODER, afr: &mut AFRH) -> PA8<AF15> {
                moder.moder().modify(|_, w| w.moder8().alternate());
                afr.afr().modify(|_, w| w.afrh8().af15());
                PA8 { _mode: PhantomData }
            }
            #[doc = " Configures the pin to operate as a floating input pin"]
            pub fn into_floating_input(
                self,
                moder: &mut MODER,
                pupdr: &mut PUPDR,
            ) -> PA8<Input<Floating>> {
                moder.moder().modify(|_, w| w.moder8().input());
                pupdr.pupdr().modify(|_, w| w.pupdr8().floating());
                PA8 { _mode: PhantomData }
            }
            #[doc = " Configures the pin to operate as a pulled down input pin"]
            pub fn into_pull_down_input(
                self,
                moder: &mut MODER,
                pupdr: &mut PUPDR,
            ) -> PA8<Input<PullDown>> {
                moder.moder().modify(|_, w| w.moder8().input());
                pupdr.pupdr().modify(|_, w| w.pupdr8().pull_down());
                PA8 { _mode: PhantomData }
            }
            #[doc = " Configures the pin to operate as a pulled up input pin"]
            pub fn into_pull_up_input(
                self,
                moder: &mut MODER,
                pupdr: &mut PUPDR,
            ) -> PA8<Input<PullUp>> {
                moder.moder().modify(|_, w| w.moder8().input());
                pupdr.pupdr().modify(|_, w| w.pupdr8().pull_up());
                PA8 { _mode: PhantomData }
            }
            #[doc = " Configures the pin to operate as an open drain output pin"]
            pub fn into_open_drain_output(
                self,
                moder: &mut MODER,
                otyper: &mut OTYPER,
            ) -> PA8<Output<OpenDrain>> {
                moder.moder().modify(|_, w| w.moder8().output());
                otyper.otyper().modify(|_, w| w.ot8().open_drain());
                PA8 { _mode: PhantomData }
            }
            #[doc = " Configures the pin to operate as an push pull output pin"]
            pub fn into_push_pull_output(
                self,
                moder: &mut MODER,
                otyper: &mut OTYPER,
            ) -> PA8<Output<PushPull>> {
                moder.moder().modify(|_, w| w.moder8().output());
                otyper.otyper().modify(|_, w| w.ot8().push_pull());
                PA8 { _mode: PhantomData }
            }
            #[doc = " Configures the pin to operate as analog, with disabled schmitt trigger."]
            #[doc = " This mode is suitable when the pin is connected to the DAC or ADC."]
            pub fn into_analog(self, moder: &mut MODER, pupdr: &mut PUPDR) -> PA8<Analog> {
                moder.moder().modify(|_, w| w.moder8().analog());
                pupdr.pupdr().modify(|_, w| w.pupdr8().floating());
                PA8 { _mode: PhantomData }
            }
        }
        impl PA8<Output<OpenDrain>> {
            #[doc = " Enables / disables the internal pull up"]
            pub fn internal_pull_up(&mut self, pupdr: &mut PUPDR, on: bool) {
                pupdr.pupdr().modify(|_, w| {
                    if on {
                        w.pupdr8().pull_up()
                    } else {
                        w.pupdr8().floating()
                    }
                });
            }
        }
        impl<MODE> PA8<Output<MODE>> {
            #[doc = " Erases the pin number from the type"]
            #[doc = ""]
            #[doc = " This is useful when you want to collect the pins into an array where you"]
            #[doc = " need all the elements to have the same type"]
            pub fn downgrade(self) -> PAx<Output<MODE>> {
                PAx {
                    i: 8,
                    _mode: self._mode,
                }
            }
        }
        impl<MODE> PA8<Input<MODE>> {
            #[doc = " Erases the pin number from the type"]
            #[doc = ""]
            #[doc = " This is useful when you want to collect the pins into an array where you"]
            #[doc = " need all the elements to have the same type"]
            pub fn downgrade(self) -> PAx<Input<MODE>> {
                PAx {
                    i: 8,
                    _mode: self._mode,
                }
            }
        }
        impl<MODE> OutputPin for PA8<Output<MODE>> {
            type Error = Infallible;
            fn set_high(&mut self) -> Result<(), Self::Error> {
                unsafe { (*GPIOA::ptr()).bsrr.write(|w| w.bs8().set()) }
                Ok(())
            }
            fn set_low(&mut self) -> Result<(), Self::Error> {
                unsafe { (*GPIOA::ptr()).bsrr.write(|w| w.br8().reset()) }
                Ok(())
            }
        }
        #[cfg(feature = "unproven")]
        impl<MODE> InputPin for PA8<Input<MODE>> {
            type Error = Infallible;
            fn is_high(&self) -> Result<bool, Self::Error> {
                Ok(!self.is_low()?)
            }
            fn is_low(&self) -> Result<bool, Self::Error> {
                Ok(unsafe { (*GPIOA::ptr()).idr.read().idr8().is_low() })
            }
        }
        #[cfg(feature = "unproven")]
        impl InputPin for PA8<Output<OpenDrain>> {
            type Error = Infallible;
            fn is_high(&self) -> Result<bool, Self::Error> {
                Ok(!self.is_low()?)
            }
            fn is_low(&self) -> Result<bool, Self::Error> {
                Ok(unsafe { (*GPIOA::ptr()).idr.read().idr8().is_low() })
            }
        }
        #[cfg(feature = "unproven")]
        impl<MODE> StatefulOutputPin for PA8<Output<MODE>> {
            fn is_set_high(&self) -> Result<bool, Self::Error> {
                self.is_set_low().map(|b| !b)
            }
            fn is_set_low(&self) -> Result<bool, Self::Error> {
                Ok(unsafe { (*GPIOA::ptr()).odr.read().odr8().is_low() })
            }
        }
        #[cfg(feature = "unproven")]
        impl<MODE> toggleable::Default for PA8<Output<MODE>> {}
        #[doc = "Pin `PA9`"]
        pub struct PA9<MODE> {
            _mode: PhantomData<MODE>,
        }
        impl<MODE> PA9<MODE> {
            #[doc = "Configures `PA9` to serve as alternate function: `AF3`"]
            pub fn into_af3(self, moder: &mut MODER, afr: &mut AFRH) -> PA9<AF3> {
                moder.moder().modify(|_, w| w.moder9().alternate());
                afr.afr().modify(|_, w| w.afrh9().af3());
                PA9 { _mode: PhantomData }
            }
            #[doc = "Configures `PA9` to serve as alternate function: `AF4`"]
            pub fn into_af4(self, moder: &mut MODER, afr: &mut AFRH) -> PA9<AF4> {
                moder.moder().modify(|_, w| w.moder9().alternate());
                afr.afr().modify(|_, w| w.afrh9().af4());
                PA9 { _mode: PhantomData }
            }
            #[doc = "Configures `PA9` to serve as alternate function: `AF5`"]
            pub fn into_af5(self, moder: &mut MODER, afr: &mut AFRH) -> PA9<AF5> {
                moder.moder().modify(|_, w| w.moder9().alternate());
                afr.afr().modify(|_, w| w.afrh9().af5());
                PA9 { _mode: PhantomData }
            }
            #[doc = "Configures `PA9` to serve as alternate function: `AF6`"]
            pub fn into_af6(self, moder: &mut MODER, afr: &mut AFRH) -> PA9<AF6> {
                moder.moder().modify(|_, w| w.moder9().alternate());
                afr.afr().modify(|_, w| w.afrh9().af6());
                PA9 { _mode: PhantomData }
            }
            #[doc = "Configures `PA9` to serve as alternate function: `AF7`"]
            pub fn into_af7(self, moder: &mut MODER, afr: &mut AFRH) -> PA9<AF7> {
                moder.moder().modify(|_, w| w.moder9().alternate());
                afr.afr().modify(|_, w| w.afrh9().af7());
                PA9 { _mode: PhantomData }
            }
            #[doc = "Configures `PA9` to serve as alternate function: `AF8`"]
            pub fn into_af8(self, moder: &mut MODER, afr: &mut AFRH) -> PA9<AF8> {
                moder.moder().modify(|_, w| w.moder9().alternate());
                afr.afr().modify(|_, w| w.afrh9().af8());
                PA9 { _mode: PhantomData }
            }
            #[doc = "Configures `PA9` to serve as alternate function: `AF9`"]
            pub fn into_af9(self, moder: &mut MODER, afr: &mut AFRH) -> PA9<AF9> {
                moder.moder().modify(|_, w| w.moder9().alternate());
                afr.afr().modify(|_, w| w.afrh9().af9());
                PA9 { _mode: PhantomData }
            }
            #[doc = "Configures `PA9` to serve as alternate function: `AF10`"]
            pub fn into_af10(self, moder: &mut MODER, afr: &mut AFRH) -> PA9<AF10> {
                moder.moder().modify(|_, w| w.moder9().alternate());
                afr.afr().modify(|_, w| w.afrh9().af10());
                PA9 { _mode: PhantomData }
            }
            #[doc = "Configures `PA9` to serve as alternate function: `AF15`"]
            pub fn into_af15(self, moder: &mut MODER, afr: &mut AFRH) -> PA9<AF15> {
                moder.moder().modify(|_, w| w.moder9().alternate());
                afr.afr().modify(|_, w| w.afrh9().af15());
                PA9 { _mode: PhantomData }
            }
            #[doc = " Configures the pin to operate as a floating input pin"]
            pub fn into_floating_input(
                self,
                moder: &mut MODER,
                pupdr: &mut PUPDR,
            ) -> PA9<Input<Floating>> {
                moder.moder().modify(|_, w| w.moder9().input());
                pupdr.pupdr().modify(|_, w| w.pupdr9().floating());
                PA9 { _mode: PhantomData }
            }
            #[doc = " Configures the pin to operate as a pulled down input pin"]
            pub fn into_pull_down_input(
                self,
                moder: &mut MODER,
                pupdr: &mut PUPDR,
            ) -> PA9<Input<PullDown>> {
                moder.moder().modify(|_, w| w.moder9().input());
                pupdr.pupdr().modify(|_, w| w.pupdr9().pull_down());
                PA9 { _mode: PhantomData }
            }
            #[doc = " Configures the pin to operate as a pulled up input pin"]
            pub fn into_pull_up_input(
                self,
                moder: &mut MODER,
                pupdr: &mut PUPDR,
            ) -> PA9<Input<PullUp>> {
                moder.moder().modify(|_, w| w.moder9().input());
                pupdr.pupdr().modify(|_, w| w.pupdr9().pull_up());
                PA9 { _mode: PhantomData }
            }
            #[doc = " Configures the pin to operate as an open drain output pin"]
            pub fn into_open_drain_output(
                self,
                moder: &mut MODER,
                otyper: &mut OTYPER,
            ) -> PA9<Output<OpenDrain>> {
                moder.moder().modify(|_, w| w.moder9().output());
                otyper.otyper().modify(|_, w| w.ot9().open_drain());
                PA9 { _mode: PhantomData }
            }
            #[doc = " Configures the pin to operate as an push pull output pin"]
            pub fn into_push_pull_output(
                self,
                moder: &mut MODER,
                otyper: &mut OTYPER,
            ) -> PA9<Output<PushPull>> {
                moder.moder().modify(|_, w| w.moder9().output());
                otyper.otyper().modify(|_, w| w.ot9().push_pull());
                PA9 { _mode: PhantomData }
            }
            #[doc = " Configures the pin to operate as analog, with disabled schmitt trigger."]
            #[doc = " This mode is suitable when the pin is connected to the DAC or ADC."]
            pub fn into_analog(self, moder: &mut MODER, pupdr: &mut PUPDR) -> PA9<Analog> {
                moder.moder().modify(|_, w| w.moder9().analog());
                pupdr.pupdr().modify(|_, w| w.pupdr9().floating());
                PA9 { _mode: PhantomData }
            }
        }
        impl PA9<Output<OpenDrain>> {
            #[doc = " Enables / disables the internal pull up"]
            pub fn internal_pull_up(&mut self, pupdr: &mut PUPDR, on: bool) {
                pupdr.pupdr().modify(|_, w| {
                    if on {
                        w.pupdr9().pull_up()
                    } else {
                        w.pupdr9().floating()
                    }
                });
            }
        }
        impl<MODE> PA9<Output<MODE>> {
            #[doc = " Erases the pin number from the type"]
            #[doc = ""]
            #[doc = " This is useful when you want to collect the pins into an array where you"]
            #[doc = " need all the elements to have the same type"]
            pub fn downgrade(self) -> PAx<Output<MODE>> {
                PAx {
                    i: 9,
                    _mode: self._mode,
                }
            }
        }
        impl<MODE> PA9<Input<MODE>> {
            #[doc = " Erases the pin number from the type"]
            #[doc = ""]
            #[doc = " This is useful when you want to collect the pins into an array where you"]
            #[doc = " need all the elements to have the same type"]
            pub fn downgrade(self) -> PAx<Input<MODE>> {
                PAx {
                    i: 9,
                    _mode: self._mode,
                }
            }
        }
        impl<MODE> OutputPin for PA9<Output<MODE>> {
            type Error = Infallible;
            fn set_high(&mut self) -> Result<(), Self::Error> {
                unsafe { (*GPIOA::ptr()).bsrr.write(|w| w.bs9().set()) }
                Ok(())
            }
            fn set_low(&mut self) -> Result<(), Self::Error> {
                unsafe { (*GPIOA::ptr()).bsrr.write(|w| w.br9().reset()) }
                Ok(())
            }
        }
        #[cfg(feature = "unproven")]
        impl<MODE> InputPin for PA9<Input<MODE>> {
            type Error = Infallible;
            fn is_high(&self) -> Result<bool, Self::Error> {
                Ok(!self.is_low()?)
            }
            fn is_low(&self) -> Result<bool, Self::Error> {
                Ok(unsafe { (*GPIOA::ptr()).idr.read().idr9().is_low() })
            }
        }
        #[cfg(feature = "unproven")]
        impl InputPin for PA9<Output<OpenDrain>> {
            type Error = Infallible;
            fn is_high(&self) -> Result<bool, Self::Error> {
                Ok(!self.is_low()?)
            }
            fn is_low(&self) -> Result<bool, Self::Error> {
                Ok(unsafe { (*GPIOA::ptr()).idr.read().idr9().is_low() })
            }
        }
        #[cfg(feature = "unproven")]
        impl<MODE> StatefulOutputPin for PA9<Output<MODE>> {
            fn is_set_high(&self) -> Result<bool, Self::Error> {
                self.is_set_low().map(|b| !b)
            }
            fn is_set_low(&self) -> Result<bool, Self::Error> {
                Ok(unsafe { (*GPIOA::ptr()).odr.read().odr9().is_low() })
            }
        }
        #[cfg(feature = "unproven")]
        impl<MODE> toggleable::Default for PA9<Output<MODE>> {}
        #[doc = "Pin `PA10`"]
        pub struct PA10<MODE> {
            _mode: PhantomData<MODE>,
        }
        impl<MODE> PA10<MODE> {
            #[doc = "Configures `PA10` to serve as alternate function: `AF1`"]
            pub fn into_af1(self, moder: &mut MODER, afr: &mut AFRH) -> PA10<AF1> {
                moder.moder().modify(|_, w| w.moder10().alternate());
                afr.afr().modify(|_, w| w.afrh10().af1());
                PA10 { _mode: PhantomData }
            }
            #[doc = "Configures `PA10` to serve as alternate function: `AF3`"]
            pub fn into_af3(self, moder: &mut MODER, afr: &mut AFRH) -> PA10<AF3> {
                moder.moder().modify(|_, w| w.moder10().alternate());
                afr.afr().modify(|_, w| w.afrh10().af3());
                PA10 { _mode: PhantomData }
            }
            #[doc = "Configures `PA10` to serve as alternate function: `AF4`"]
            pub fn into_af4(self, moder: &mut MODER, afr: &mut AFRH) -> PA10<AF4> {
                moder.moder().modify(|_, w| w.moder10().alternate());
                afr.afr().modify(|_, w| w.afrh10().af4());
                PA10 { _mode: PhantomData }
            }
            #[doc = "Configures `PA10` to serve as alternate function: `AF6`"]
            pub fn into_af6(self, moder: &mut MODER, afr: &mut AFRH) -> PA10<AF6> {
                moder.moder().modify(|_, w| w.moder10().alternate());
                afr.afr().modify(|_, w| w.afrh10().af6());
                PA10 { _mode: PhantomData }
            }
            #[doc = "Configures `PA10` to serve as alternate function: `AF7`"]
            pub fn into_af7(self, moder: &mut MODER, afr: &mut AFRH) -> PA10<AF7> {
                moder.moder().modify(|_, w| w.moder10().alternate());
                afr.afr().modify(|_, w| w.afrh10().af7());
                PA10 { _mode: PhantomData }
            }
            #[doc = "Configures `PA10` to serve as alternate function: `AF8`"]
            pub fn into_af8(self, moder: &mut MODER, afr: &mut AFRH) -> PA10<AF8> {
                moder.moder().modify(|_, w| w.moder10().alternate());
                afr.afr().modify(|_, w| w.afrh10().af8());
                PA10 { _mode: PhantomData }
            }
            #[doc = "Configures `PA10` to serve as alternate function: `AF10`"]
            pub fn into_af10(self, moder: &mut MODER, afr: &mut AFRH) -> PA10<AF10> {
                moder.moder().modify(|_, w| w.moder10().alternate());
                afr.afr().modify(|_, w| w.afrh10().af10());
                PA10 { _mode: PhantomData }
            }
            #[doc = "Configures `PA10` to serve as alternate function: `AF11`"]
            pub fn into_af11(self, moder: &mut MODER, afr: &mut AFRH) -> PA10<AF11> {
                moder.moder().modify(|_, w| w.moder10().alternate());
                afr.afr().modify(|_, w| w.afrh10().af11());
                PA10 { _mode: PhantomData }
            }
            #[doc = "Configures `PA10` to serve as alternate function: `AF15`"]
            pub fn into_af15(self, moder: &mut MODER, afr: &mut AFRH) -> PA10<AF15> {
                moder.moder().modify(|_, w| w.moder10().alternate());
                afr.afr().modify(|_, w| w.afrh10().af15());
                PA10 { _mode: PhantomData }
            }
            #[doc = " Configures the pin to operate as a floating input pin"]
            pub fn into_floating_input(
                self,
                moder: &mut MODER,
                pupdr: &mut PUPDR,
            ) -> PA10<Input<Floating>> {
                moder.moder().modify(|_, w| w.moder10().input());
                pupdr.pupdr().modify(|_, w| w.pupdr10().floating());
                PA10 { _mode: PhantomData }
            }
            #[doc = " Configures the pin to operate as a pulled down input pin"]
            pub fn into_pull_down_input(
                self,
                moder: &mut MODER,
                pupdr: &mut PUPDR,
            ) -> PA10<Input<PullDown>> {
                moder.moder().modify(|_, w| w.moder10().input());
                pupdr.pupdr().modify(|_, w| w.pupdr10().pull_down());
                PA10 { _mode: PhantomData }
            }
            #[doc = " Configures the pin to operate as a pulled up input pin"]
            pub fn into_pull_up_input(
                self,
                moder: &mut MODER,
                pupdr: &mut PUPDR,
            ) -> PA10<Input<PullUp>> {
                moder.moder().modify(|_, w| w.moder10().input());
                pupdr.pupdr().modify(|_, w| w.pupdr10().pull_up());
                PA10 { _mode: PhantomData }
            }
            #[doc = " Configures the pin to operate as an open drain output pin"]
            pub fn into_open_drain_output(
                self,
                moder: &mut MODER,
                otyper: &mut OTYPER,
            ) -> PA10<Output<OpenDrain>> {
                moder.moder().modify(|_, w| w.moder10().output());
                otyper.otyper().modify(|_, w| w.ot10().open_drain());
                PA10 { _mode: PhantomData }
            }
            #[doc = " Configures the pin to operate as an push pull output pin"]
            pub fn into_push_pull_output(
                self,
                moder: &mut MODER,
                otyper: &mut OTYPER,
            ) -> PA10<Output<PushPull>> {
                moder.moder().modify(|_, w| w.moder10().output());
                otyper.otyper().modify(|_, w| w.ot10().push_pull());
                PA10 { _mode: PhantomData }
            }
            #[doc = " Configures the pin to operate as analog, with disabled schmitt trigger."]
            #[doc = " This mode is suitable when the pin is connected to the DAC or ADC."]
            pub fn into_analog(self, moder: &mut MODER, pupdr: &mut PUPDR) -> PA10<Analog> {
                moder.moder().modify(|_, w| w.moder10().analog());
                pupdr.pupdr().modify(|_, w| w.pupdr10().floating());
                PA10 { _mode: PhantomData }
            }
        }
        impl PA10<Output<OpenDrain>> {
            #[doc = " Enables / disables the internal pull up"]
            pub fn internal_pull_up(&mut self, pupdr: &mut PUPDR, on: bool) {
                pupdr.pupdr().modify(|_, w| {
                    if on {
                        w.pupdr10().pull_up()
                    } else {
                        w.pupdr10().floating()
                    }
                });
            }
        }
        impl<MODE> PA10<Output<MODE>> {
            #[doc = " Erases the pin number from the type"]
            #[doc = ""]
            #[doc = " This is useful when you want to collect the pins into an array where you"]
            #[doc = " need all the elements to have the same type"]
            pub fn downgrade(self) -> PAx<Output<MODE>> {
                PAx {
                    i: 10,
                    _mode: self._mode,
                }
            }
        }
        impl<MODE> PA10<Input<MODE>> {
            #[doc = " Erases the pin number from the type"]
            #[doc = ""]
            #[doc = " This is useful when you want to collect the pins into an array where you"]
            #[doc = " need all the elements to have the same type"]
            pub fn downgrade(self) -> PAx<Input<MODE>> {
                PAx {
                    i: 10,
                    _mode: self._mode,
                }
            }
        }
        impl<MODE> OutputPin for PA10<Output<MODE>> {
            type Error = Infallible;
            fn set_high(&mut self) -> Result<(), Self::Error> {
                unsafe { (*GPIOA::ptr()).bsrr.write(|w| w.bs10().set()) }
                Ok(())
            }
            fn set_low(&mut self) -> Result<(), Self::Error> {
                unsafe { (*GPIOA::ptr()).bsrr.write(|w| w.br10().reset()) }
                Ok(())
            }
        }
        #[cfg(feature = "unproven")]
        impl<MODE> InputPin for PA10<Input<MODE>> {
            type Error = Infallible;
            fn is_high(&self) -> Result<bool, Self::Error> {
                Ok(!self.is_low()?)
            }
            fn is_low(&self) -> Result<bool, Self::Error> {
                Ok(unsafe { (*GPIOA::ptr()).idr.read().idr10().is_low() })
            }
        }
        #[cfg(feature = "unproven")]
        impl InputPin for PA10<Output<OpenDrain>> {
            type Error = Infallible;
            fn is_high(&self) -> Result<bool, Self::Error> {
                Ok(!self.is_low()?)
            }
            fn is_low(&self) -> Result<bool, Self::Error> {
                Ok(unsafe { (*GPIOA::ptr()).idr.read().idr10().is_low() })
            }
        }
        #[cfg(feature = "unproven")]
        impl<MODE> StatefulOutputPin for PA10<Output<MODE>> {
            fn is_set_high(&self) -> Result<bool, Self::Error> {
                self.is_set_low().map(|b| !b)
            }
            fn is_set_low(&self) -> Result<bool, Self::Error> {
                Ok(unsafe { (*GPIOA::ptr()).odr.read().odr10().is_low() })
            }
        }
        #[cfg(feature = "unproven")]
        impl<MODE> toggleable::Default for PA10<Output<MODE>> {}
        #[doc = "Pin `PA11`"]
        pub struct PA11<MODE> {
            _mode: PhantomData<MODE>,
        }
        impl<MODE> PA11<MODE> {
            #[doc = "Configures `PA11` to serve as alternate function: `AF6`"]
            pub fn into_af6(self, moder: &mut MODER, afr: &mut AFRH) -> PA11<AF6> {
                moder.moder().modify(|_, w| w.moder11().alternate());
                afr.afr().modify(|_, w| w.afrh11().af6());
                PA11 { _mode: PhantomData }
            }
            #[doc = "Configures `PA11` to serve as alternate function: `AF7`"]
            pub fn into_af7(self, moder: &mut MODER, afr: &mut AFRH) -> PA11<AF7> {
                moder.moder().modify(|_, w| w.moder11().alternate());
                afr.afr().modify(|_, w| w.afrh11().af7());
                PA11 { _mode: PhantomData }
            }
            #[doc = "Configures `PA11` to serve as alternate function: `AF8`"]
            pub fn into_af8(self, moder: &mut MODER, afr: &mut AFRH) -> PA11<AF8> {
                moder.moder().modify(|_, w| w.moder11().alternate());
                afr.afr().modify(|_, w| w.afrh11().af8());
                PA11 { _mode: PhantomData }
            }
            #[doc = "Configures `PA11` to serve as alternate function: `AF9`"]
            pub fn into_af9(self, moder: &mut MODER, afr: &mut AFRH) -> PA11<AF9> {
                moder.moder().modify(|_, w| w.moder11().alternate());
                afr.afr().modify(|_, w| w.afrh11().af9());
                PA11 { _mode: PhantomData }
            }
            #[doc = "Configures `PA11` to serve as alternate function: `AF10`"]
            pub fn into_af10(self, moder: &mut MODER, afr: &mut AFRH) -> PA11<AF10> {
                moder.moder().modify(|_, w| w.moder11().alternate());
                afr.afr().modify(|_, w| w.afrh11().af10());
                PA11 { _mode: PhantomData }
            }
            #[doc = "Configures `PA11` to serve as alternate function: `AF11`"]
            pub fn into_af11(self, moder: &mut MODER, afr: &mut AFRH) -> PA11<AF11> {
                moder.moder().modify(|_, w| w.moder11().alternate());
                afr.afr().modify(|_, w| w.afrh11().af11());
                PA11 { _mode: PhantomData }
            }
            #[doc = "Configures `PA11` to serve as alternate function: `AF12`"]
            pub fn into_af12(self, moder: &mut MODER, afr: &mut AFRH) -> PA11<AF12> {
                moder.moder().modify(|_, w| w.moder11().alternate());
                afr.afr().modify(|_, w| w.afrh11().af12());
                PA11 { _mode: PhantomData }
            }
            #[doc = "Configures `PA11` to serve as alternate function: `AF14`"]
            pub fn into_af14(self, moder: &mut MODER, afr: &mut AFRH) -> PA11<AF14> {
                moder.moder().modify(|_, w| w.moder11().alternate());
                afr.afr().modify(|_, w| w.afrh11().af14());
                PA11 { _mode: PhantomData }
            }
            #[doc = "Configures `PA11` to serve as alternate function: `AF15`"]
            pub fn into_af15(self, moder: &mut MODER, afr: &mut AFRH) -> PA11<AF15> {
                moder.moder().modify(|_, w| w.moder11().alternate());
                afr.afr().modify(|_, w| w.afrh11().af15());
                PA11 { _mode: PhantomData }
            }
            #[doc = " Configures the pin to operate as a floating input pin"]
            pub fn into_floating_input(
                self,
                moder: &mut MODER,
                pupdr: &mut PUPDR,
            ) -> PA11<Input<Floating>> {
                moder.moder().modify(|_, w| w.moder11().input());
                pupdr.pupdr().modify(|_, w| w.pupdr11().floating());
                PA11 { _mode: PhantomData }
            }
            #[doc = " Configures the pin to operate as a pulled down input pin"]
            pub fn into_pull_down_input(
                self,
                moder: &mut MODER,
                pupdr: &mut PUPDR,
            ) -> PA11<Input<PullDown>> {
                moder.moder().modify(|_, w| w.moder11().input());
                pupdr.pupdr().modify(|_, w| w.pupdr11().pull_down());
                PA11 { _mode: PhantomData }
            }
            #[doc = " Configures the pin to operate as a pulled up input pin"]
            pub fn into_pull_up_input(
                self,
                moder: &mut MODER,
                pupdr: &mut PUPDR,
            ) -> PA11<Input<PullUp>> {
                moder.moder().modify(|_, w| w.moder11().input());
                pupdr.pupdr().modify(|_, w| w.pupdr11().pull_up());
                PA11 { _mode: PhantomData }
            }
            #[doc = " Configures the pin to operate as an open drain output pin"]
            pub fn into_open_drain_output(
                self,
                moder: &mut MODER,
                otyper: &mut OTYPER,
            ) -> PA11<Output<OpenDrain>> {
                moder.moder().modify(|_, w| w.moder11().output());
                otyper.otyper().modify(|_, w| w.ot11().open_drain());
                PA11 { _mode: PhantomData }
            }
            #[doc = " Configures the pin to operate as an push pull output pin"]
            pub fn into_push_pull_output(
                self,
                moder: &mut MODER,
                otyper: &mut OTYPER,
            ) -> PA11<Output<PushPull>> {
                moder.moder().modify(|_, w| w.moder11().output());
                otyper.otyper().modify(|_, w| w.ot11().push_pull());
                PA11 { _mode: PhantomData }
            }
            #[doc = " Configures the pin to operate as analog, with disabled schmitt trigger."]
            #[doc = " This mode is suitable when the pin is connected to the DAC or ADC."]
            pub fn into_analog(self, moder: &mut MODER, pupdr: &mut PUPDR) -> PA11<Analog> {
                moder.moder().modify(|_, w| w.moder11().analog());
                pupdr.pupdr().modify(|_, w| w.pupdr11().floating());
                PA11 { _mode: PhantomData }
            }
        }
        impl PA11<Output<OpenDrain>> {
            #[doc = " Enables / disables the internal pull up"]
            pub fn internal_pull_up(&mut self, pupdr: &mut PUPDR, on: bool) {
                pupdr.pupdr().modify(|_, w| {
                    if on {
                        w.pupdr11().pull_up()
                    } else {
                        w.pupdr11().floating()
                    }
                });
            }
        }
        impl<MODE> PA11<Output<MODE>> {
            #[doc = " Erases the pin number from the type"]
            #[doc = ""]
            #[doc = " This is useful when you want to collect the pins into an array where you"]
            #[doc = " need all the elements to have the same type"]
            pub fn downgrade(self) -> PAx<Output<MODE>> {
                PAx {
                    i: 11,
                    _mode: self._mode,
                }
            }
        }
        impl<MODE> PA11<Input<MODE>> {
            #[doc = " Erases the pin number from the type"]
            #[doc = ""]
            #[doc = " This is useful when you want to collect the pins into an array where you"]
            #[doc = " need all the elements to have the same type"]
            pub fn downgrade(self) -> PAx<Input<MODE>> {
                PAx {
                    i: 11,
                    _mode: self._mode,
                }
            }
        }
        impl<MODE> OutputPin for PA11<Output<MODE>> {
            type Error = Infallible;
            fn set_high(&mut self) -> Result<(), Self::Error> {
                unsafe { (*GPIOA::ptr()).bsrr.write(|w| w.bs11().set()) }
                Ok(())
            }
            fn set_low(&mut self) -> Result<(), Self::Error> {
                unsafe { (*GPIOA::ptr()).bsrr.write(|w| w.br11().reset()) }
                Ok(())
            }
        }
        #[cfg(feature = "unproven")]
        impl<MODE> InputPin for PA11<Input<MODE>> {
            type Error = Infallible;
            fn is_high(&self) -> Result<bool, Self::Error> {
                Ok(!self.is_low()?)
            }
            fn is_low(&self) -> Result<bool, Self::Error> {
                Ok(unsafe { (*GPIOA::ptr()).idr.read().idr11().is_low() })
            }
        }
        #[cfg(feature = "unproven")]
        impl InputPin for PA11<Output<OpenDrain>> {
            type Error = Infallible;
            fn is_high(&self) -> Result<bool, Self::Error> {
                Ok(!self.is_low()?)
            }
            fn is_low(&self) -> Result<bool, Self::Error> {
                Ok(unsafe { (*GPIOA::ptr()).idr.read().idr11().is_low() })
            }
        }
        #[cfg(feature = "unproven")]
        impl<MODE> StatefulOutputPin for PA11<Output<MODE>> {
            fn is_set_high(&self) -> Result<bool, Self::Error> {
                self.is_set_low().map(|b| !b)
            }
            fn is_set_low(&self) -> Result<bool, Self::Error> {
                Ok(unsafe { (*GPIOA::ptr()).odr.read().odr11().is_low() })
            }
        }
        #[cfg(feature = "unproven")]
        impl<MODE> toggleable::Default for PA11<Output<MODE>> {}
        #[doc = "Pin `PA12`"]
        pub struct PA12<MODE> {
            _mode: PhantomData<MODE>,
        }
        impl<MODE> PA12<MODE> {
            #[doc = "Configures `PA12` to serve as alternate function: `AF1`"]
            pub fn into_af1(self, moder: &mut MODER, afr: &mut AFRH) -> PA12<AF1> {
                moder.moder().modify(|_, w| w.moder12().alternate());
                afr.afr().modify(|_, w| w.afrh12().af1());
                PA12 { _mode: PhantomData }
            }
            #[doc = "Configures `PA12` to serve as alternate function: `AF6`"]
            pub fn into_af6(self, moder: &mut MODER, afr: &mut AFRH) -> PA12<AF6> {
                moder.moder().modify(|_, w| w.moder12().alternate());
                afr.afr().modify(|_, w| w.afrh12().af6());
                PA12 { _mode: PhantomData }
            }
            #[doc = "Configures `PA12` to serve as alternate function: `AF7`"]
            pub fn into_af7(self, moder: &mut MODER, afr: &mut AFRH) -> PA12<AF7> {
                moder.moder().modify(|_, w| w.moder12().alternate());
                afr.afr().modify(|_, w| w.afrh12().af7());
                PA12 { _mode: PhantomData }
            }
            #[doc = "Configures `PA12` to serve as alternate function: `AF8`"]
            pub fn into_af8(self, moder: &mut MODER, afr: &mut AFRH) -> PA12<AF8> {
                moder.moder().modify(|_, w| w.moder12().alternate());
                afr.afr().modify(|_, w| w.afrh12().af8());
                PA12 { _mode: PhantomData }
            }
            #[doc = "Configures `PA12` to serve as alternate function: `AF9`"]
            pub fn into_af9(self, moder: &mut MODER, afr: &mut AFRH) -> PA12<AF9> {
                moder.moder().modify(|_, w| w.moder12().alternate());
                afr.afr().modify(|_, w| w.afrh12().af9());
                PA12 { _mode: PhantomData }
            }
            #[doc = "Configures `PA12` to serve as alternate function: `AF10`"]
            pub fn into_af10(self, moder: &mut MODER, afr: &mut AFRH) -> PA12<AF10> {
                moder.moder().modify(|_, w| w.moder12().alternate());
                afr.afr().modify(|_, w| w.afrh12().af10());
                PA12 { _mode: PhantomData }
            }
            #[doc = "Configures `PA12` to serve as alternate function: `AF11`"]
            pub fn into_af11(self, moder: &mut MODER, afr: &mut AFRH) -> PA12<AF11> {
                moder.moder().modify(|_, w| w.moder12().alternate());
                afr.afr().modify(|_, w| w.afrh12().af11());
                PA12 { _mode: PhantomData }
            }
            #[doc = "Configures `PA12` to serve as alternate function: `AF14`"]
            pub fn into_af14(self, moder: &mut MODER, afr: &mut AFRH) -> PA12<AF14> {
                moder.moder().modify(|_, w| w.moder12().alternate());
                afr.afr().modify(|_, w| w.afrh12().af14());
                PA12 { _mode: PhantomData }
            }
            #[doc = "Configures `PA12` to serve as alternate function: `AF15`"]
            pub fn into_af15(self, moder: &mut MODER, afr: &mut AFRH) -> PA12<AF15> {
                moder.moder().modify(|_, w| w.moder12().alternate());
                afr.afr().modify(|_, w| w.afrh12().af15());
                PA12 { _mode: PhantomData }
            }
            #[doc = " Configures the pin to operate as a floating input pin"]
            pub fn into_floating_input(
                self,
                moder: &mut MODER,
                pupdr: &mut PUPDR,
            ) -> PA12<Input<Floating>> {
                moder.moder().modify(|_, w| w.moder12().input());
                pupdr.pupdr().modify(|_, w| w.pupdr12().floating());
                PA12 { _mode: PhantomData }
            }
            #[doc = " Configures the pin to operate as a pulled down input pin"]
            pub fn into_pull_down_input(
                self,
                moder: &mut MODER,
                pupdr: &mut PUPDR,
            ) -> PA12<Input<PullDown>> {
                moder.moder().modify(|_, w| w.moder12().input());
                pupdr.pupdr().modify(|_, w| w.pupdr12().pull_down());
                PA12 { _mode: PhantomData }
            }
            #[doc = " Configures the pin to operate as a pulled up input pin"]
            pub fn into_pull_up_input(
                self,
                moder: &mut MODER,
                pupdr: &mut PUPDR,
            ) -> PA12<Input<PullUp>> {
                moder.moder().modify(|_, w| w.moder12().input());
                pupdr.pupdr().modify(|_, w| w.pupdr12().pull_up());
                PA12 { _mode: PhantomData }
            }
            #[doc = " Configures the pin to operate as an open drain output pin"]
            pub fn into_open_drain_output(
                self,
                moder: &mut MODER,
                otyper: &mut OTYPER,
            ) -> PA12<Output<OpenDrain>> {
                moder.moder().modify(|_, w| w.moder12().output());
                otyper.otyper().modify(|_, w| w.ot12().open_drain());
                PA12 { _mode: PhantomData }
            }
            #[doc = " Configures the pin to operate as an push pull output pin"]
            pub fn into_push_pull_output(
                self,
                moder: &mut MODER,
                otyper: &mut OTYPER,
            ) -> PA12<Output<PushPull>> {
                moder.moder().modify(|_, w| w.moder12().output());
                otyper.otyper().modify(|_, w| w.ot12().push_pull());
                PA12 { _mode: PhantomData }
            }
            #[doc = " Configures the pin to operate as analog, with disabled schmitt trigger."]
            #[doc = " This mode is suitable when the pin is connected to the DAC or ADC."]
            pub fn into_analog(self, moder: &mut MODER, pupdr: &mut PUPDR) -> PA12<Analog> {
                moder.moder().modify(|_, w| w.moder12().analog());
                pupdr.pupdr().modify(|_, w| w.pupdr12().floating());
                PA12 { _mode: PhantomData }
            }
        }
        impl PA12<Output<OpenDrain>> {
            #[doc = " Enables / disables the internal pull up"]
            pub fn internal_pull_up(&mut self, pupdr: &mut PUPDR, on: bool) {
                pupdr.pupdr().modify(|_, w| {
                    if on {
                        w.pupdr12().pull_up()
                    } else {
                        w.pupdr12().floating()
                    }
                });
            }
        }
        impl<MODE> PA12<Output<MODE>> {
            #[doc = " Erases the pin number from the type"]
            #[doc = ""]
            #[doc = " This is useful when you want to collect the pins into an array where you"]
            #[doc = " need all the elements to have the same type"]
            pub fn downgrade(self) -> PAx<Output<MODE>> {
                PAx {
                    i: 12,
                    _mode: self._mode,
                }
            }
        }
        impl<MODE> PA12<Input<MODE>> {
            #[doc = " Erases the pin number from the type"]
            #[doc = ""]
            #[doc = " This is useful when you want to collect the pins into an array where you"]
            #[doc = " need all the elements to have the same type"]
            pub fn downgrade(self) -> PAx<Input<MODE>> {
                PAx {
                    i: 12,
                    _mode: self._mode,
                }
            }
        }
        impl<MODE> OutputPin for PA12<Output<MODE>> {
            type Error = Infallible;
            fn set_high(&mut self) -> Result<(), Self::Error> {
                unsafe { (*GPIOA::ptr()).bsrr.write(|w| w.bs12().set()) }
                Ok(())
            }
            fn set_low(&mut self) -> Result<(), Self::Error> {
                unsafe { (*GPIOA::ptr()).bsrr.write(|w| w.br12().reset()) }
                Ok(())
            }
        }
        #[cfg(feature = "unproven")]
        impl<MODE> InputPin for PA12<Input<MODE>> {
            type Error = Infallible;
            fn is_high(&self) -> Result<bool, Self::Error> {
                Ok(!self.is_low()?)
            }
            fn is_low(&self) -> Result<bool, Self::Error> {
                Ok(unsafe { (*GPIOA::ptr()).idr.read().idr12().is_low() })
            }
        }
        #[cfg(feature = "unproven")]
        impl InputPin for PA12<Output<OpenDrain>> {
            type Error = Infallible;
            fn is_high(&self) -> Result<bool, Self::Error> {
                Ok(!self.is_low()?)
            }
            fn is_low(&self) -> Result<bool, Self::Error> {
                Ok(unsafe { (*GPIOA::ptr()).idr.read().idr12().is_low() })
            }
        }
        #[cfg(feature = "unproven")]
        impl<MODE> StatefulOutputPin for PA12<Output<MODE>> {
            fn is_set_high(&self) -> Result<bool, Self::Error> {
                self.is_set_low().map(|b| !b)
            }
            fn is_set_low(&self) -> Result<bool, Self::Error> {
                Ok(unsafe { (*GPIOA::ptr()).odr.read().odr12().is_low() })
            }
        }
        #[cfg(feature = "unproven")]
        impl<MODE> toggleable::Default for PA12<Output<MODE>> {}
        #[doc = "Pin `PA13`"]
        pub struct PA13<MODE> {
            _mode: PhantomData<MODE>,
        }
        impl<MODE> PA13<MODE> {
            #[doc = "Configures `PA13` to serve as alternate function: `AF0`"]
            pub fn into_af0(self, moder: &mut MODER, afr: &mut AFRH) -> PA13<AF0> {
                moder.moder().modify(|_, w| w.moder13().alternate());
                afr.afr().modify(|_, w| w.afrh13().af0());
                PA13 { _mode: PhantomData }
            }
            #[doc = "Configures `PA13` to serve as alternate function: `AF1`"]
            pub fn into_af1(self, moder: &mut MODER, afr: &mut AFRH) -> PA13<AF1> {
                moder.moder().modify(|_, w| w.moder13().alternate());
                afr.afr().modify(|_, w| w.afrh13().af1());
                PA13 { _mode: PhantomData }
            }
            #[doc = "Configures `PA13` to serve as alternate function: `AF3`"]
            pub fn into_af3(self, moder: &mut MODER, afr: &mut AFRH) -> PA13<AF3> {
                moder.moder().modify(|_, w| w.moder13().alternate());
                afr.afr().modify(|_, w| w.afrh13().af3());
                PA13 { _mode: PhantomData }
            }
            #[doc = "Configures `PA13` to serve as alternate function: `AF5`"]
            pub fn into_af5(self, moder: &mut MODER, afr: &mut AFRH) -> PA13<AF5> {
                moder.moder().modify(|_, w| w.moder13().alternate());
                afr.afr().modify(|_, w| w.afrh13().af5());
                PA13 { _mode: PhantomData }
            }
            #[doc = "Configures `PA13` to serve as alternate function: `AF7`"]
            pub fn into_af7(self, moder: &mut MODER, afr: &mut AFRH) -> PA13<AF7> {
                moder.moder().modify(|_, w| w.moder13().alternate());
                afr.afr().modify(|_, w| w.afrh13().af7());
                PA13 { _mode: PhantomData }
            }
            #[doc = "Configures `PA13` to serve as alternate function: `AF10`"]
            pub fn into_af10(self, moder: &mut MODER, afr: &mut AFRH) -> PA13<AF10> {
                moder.moder().modify(|_, w| w.moder13().alternate());
                afr.afr().modify(|_, w| w.afrh13().af10());
                PA13 { _mode: PhantomData }
            }
            #[doc = "Configures `PA13` to serve as alternate function: `AF15`"]
            pub fn into_af15(self, moder: &mut MODER, afr: &mut AFRH) -> PA13<AF15> {
                moder.moder().modify(|_, w| w.moder13().alternate());
                afr.afr().modify(|_, w| w.afrh13().af15());
                PA13 { _mode: PhantomData }
            }
            #[doc = " Configures the pin to operate as a floating input pin"]
            pub fn into_floating_input(
                self,
                moder: &mut MODER,
                pupdr: &mut PUPDR,
            ) -> PA13<Input<Floating>> {
                moder.moder().modify(|_, w| w.moder13().input());
                pupdr.pupdr().modify(|_, w| w.pupdr13().floating());
                PA13 { _mode: PhantomData }
            }
            #[doc = " Configures the pin to operate as a pulled down input pin"]
            pub fn into_pull_down_input(
                self,
                moder: &mut MODER,
                pupdr: &mut PUPDR,
            ) -> PA13<Input<PullDown>> {
                moder.moder().modify(|_, w| w.moder13().input());
                pupdr.pupdr().modify(|_, w| w.pupdr13().pull_down());
                PA13 { _mode: PhantomData }
            }
            #[doc = " Configures the pin to operate as a pulled up input pin"]
            pub fn into_pull_up_input(
                self,
                moder: &mut MODER,
                pupdr: &mut PUPDR,
            ) -> PA13<Input<PullUp>> {
                moder.moder().modify(|_, w| w.moder13().input());
                pupdr.pupdr().modify(|_, w| w.pupdr13().pull_up());
                PA13 { _mode: PhantomData }
            }
            #[doc = " Configures the pin to operate as an open drain output pin"]
            pub fn into_open_drain_output(
                self,
                moder: &mut MODER,
                otyper: &mut OTYPER,
            ) -> PA13<Output<OpenDrain>> {
                moder.moder().modify(|_, w| w.moder13().output());
                otyper.otyper().modify(|_, w| w.ot13().open_drain());
                PA13 { _mode: PhantomData }
            }
            #[doc = " Configures the pin to operate as an push pull output pin"]
            pub fn into_push_pull_output(
                self,
                moder: &mut MODER,
                otyper: &mut OTYPER,
            ) -> PA13<Output<PushPull>> {
                moder.moder().modify(|_, w| w.moder13().output());
                otyper.otyper().modify(|_, w| w.ot13().push_pull());
                PA13 { _mode: PhantomData }
            }
            #[doc = " Configures the pin to operate as analog, with disabled schmitt trigger."]
            #[doc = " This mode is suitable when the pin is connected to the DAC or ADC."]
            pub fn into_analog(self, moder: &mut MODER, pupdr: &mut PUPDR) -> PA13<Analog> {
                moder.moder().modify(|_, w| w.moder13().analog());
                pupdr.pupdr().modify(|_, w| w.pupdr13().floating());
                PA13 { _mode: PhantomData }
            }
        }
        impl PA13<Output<OpenDrain>> {
            #[doc = " Enables / disables the internal pull up"]
            pub fn internal_pull_up(&mut self, pupdr: &mut PUPDR, on: bool) {
                pupdr.pupdr().modify(|_, w| {
                    if on {
                        w.pupdr13().pull_up()
                    } else {
                        w.pupdr13().floating()
                    }
                });
            }
        }
        impl<MODE> PA13<Output<MODE>> {
            #[doc = " Erases the pin number from the type"]
            #[doc = ""]
            #[doc = " This is useful when you want to collect the pins into an array where you"]
            #[doc = " need all the elements to have the same type"]
            pub fn downgrade(self) -> PAx<Output<MODE>> {
                PAx {
                    i: 13,
                    _mode: self._mode,
                }
            }
        }
        impl<MODE> PA13<Input<MODE>> {
            #[doc = " Erases the pin number from the type"]
            #[doc = ""]
            #[doc = " This is useful when you want to collect the pins into an array where you"]
            #[doc = " need all the elements to have the same type"]
            pub fn downgrade(self) -> PAx<Input<MODE>> {
                PAx {
                    i: 13,
                    _mode: self._mode,
                }
            }
        }
        impl<MODE> OutputPin for PA13<Output<MODE>> {
            type Error = Infallible;
            fn set_high(&mut self) -> Result<(), Self::Error> {
                unsafe { (*GPIOA::ptr()).bsrr.write(|w| w.bs13().set()) }
                Ok(())
            }
            fn set_low(&mut self) -> Result<(), Self::Error> {
                unsafe { (*GPIOA::ptr()).bsrr.write(|w| w.br13().reset()) }
                Ok(())
            }
        }
        #[cfg(feature = "unproven")]
        impl<MODE> InputPin for PA13<Input<MODE>> {
            type Error = Infallible;
            fn is_high(&self) -> Result<bool, Self::Error> {
                Ok(!self.is_low()?)
            }
            fn is_low(&self) -> Result<bool, Self::Error> {
                Ok(unsafe { (*GPIOA::ptr()).idr.read().idr13().is_low() })
            }
        }
        #[cfg(feature = "unproven")]
        impl InputPin for PA13<Output<OpenDrain>> {
            type Error = Infallible;
            fn is_high(&self) -> Result<bool, Self::Error> {
                Ok(!self.is_low()?)
            }
            fn is_low(&self) -> Result<bool, Self::Error> {
                Ok(unsafe { (*GPIOA::ptr()).idr.read().idr13().is_low() })
            }
        }
        #[cfg(feature = "unproven")]
        impl<MODE> StatefulOutputPin for PA13<Output<MODE>> {
            fn is_set_high(&self) -> Result<bool, Self::Error> {
                self.is_set_low().map(|b| !b)
            }
            fn is_set_low(&self) -> Result<bool, Self::Error> {
                Ok(unsafe { (*GPIOA::ptr()).odr.read().odr13().is_low() })
            }
        }
        #[cfg(feature = "unproven")]
        impl<MODE> toggleable::Default for PA13<Output<MODE>> {}
        #[doc = "Pin `PA14`"]
        pub struct PA14<MODE> {
            _mode: PhantomData<MODE>,
        }
        impl<MODE> PA14<MODE> {
            #[doc = "Configures `PA14` to serve as alternate function: `AF0`"]
            pub fn into_af0(self, moder: &mut MODER, afr: &mut AFRH) -> PA14<AF0> {
                moder.moder().modify(|_, w| w.moder14().alternate());
                afr.afr().modify(|_, w| w.afrh14().af0());
                PA14 { _mode: PhantomData }
            }
            #[doc = "Configures `PA14` to serve as alternate function: `AF3`"]
            pub fn into_af3(self, moder: &mut MODER, afr: &mut AFRH) -> PA14<AF3> {
                moder.moder().modify(|_, w| w.moder14().alternate());
                afr.afr().modify(|_, w| w.afrh14().af3());
                PA14 { _mode: PhantomData }
            }
            #[doc = "Configures `PA14` to serve as alternate function: `AF4`"]
            pub fn into_af4(self, moder: &mut MODER, afr: &mut AFRH) -> PA14<AF4> {
                moder.moder().modify(|_, w| w.moder14().alternate());
                afr.afr().modify(|_, w| w.afrh14().af4());
                PA14 { _mode: PhantomData }
            }
            #[doc = "Configures `PA14` to serve as alternate function: `AF5`"]
            pub fn into_af5(self, moder: &mut MODER, afr: &mut AFRH) -> PA14<AF5> {
                moder.moder().modify(|_, w| w.moder14().alternate());
                afr.afr().modify(|_, w| w.afrh14().af5());
                PA14 { _mode: PhantomData }
            }
            #[doc = "Configures `PA14` to serve as alternate function: `AF6`"]
            pub fn into_af6(self, moder: &mut MODER, afr: &mut AFRH) -> PA14<AF6> {
                moder.moder().modify(|_, w| w.moder14().alternate());
                afr.afr().modify(|_, w| w.afrh14().af6());
                PA14 { _mode: PhantomData }
            }
            #[doc = "Configures `PA14` to serve as alternate function: `AF7`"]
            pub fn into_af7(self, moder: &mut MODER, afr: &mut AFRH) -> PA14<AF7> {
                moder.moder().modify(|_, w| w.moder14().alternate());
                afr.afr().modify(|_, w| w.afrh14().af7());
                PA14 { _mode: PhantomData }
            }
            #[doc = "Configures `PA14` to serve as alternate function: `AF15`"]
            pub fn into_af15(self, moder: &mut MODER, afr: &mut AFRH) -> PA14<AF15> {
                moder.moder().modify(|_, w| w.moder14().alternate());
                afr.afr().modify(|_, w| w.afrh14().af15());
                PA14 { _mode: PhantomData }
            }
            #[doc = " Configures the pin to operate as a floating input pin"]
            pub fn into_floating_input(
                self,
                moder: &mut MODER,
                pupdr: &mut PUPDR,
            ) -> PA14<Input<Floating>> {
                moder.moder().modify(|_, w| w.moder14().input());
                pupdr.pupdr().modify(|_, w| w.pupdr14().floating());
                PA14 { _mode: PhantomData }
            }
            #[doc = " Configures the pin to operate as a pulled down input pin"]
            pub fn into_pull_down_input(
                self,
                moder: &mut MODER,
                pupdr: &mut PUPDR,
            ) -> PA14<Input<PullDown>> {
                moder.moder().modify(|_, w| w.moder14().input());
                pupdr.pupdr().modify(|_, w| w.pupdr14().pull_down());
                PA14 { _mode: PhantomData }
            }
            #[doc = " Configures the pin to operate as a pulled up input pin"]
            pub fn into_pull_up_input(
                self,
                moder: &mut MODER,
                pupdr: &mut PUPDR,
            ) -> PA14<Input<PullUp>> {
                moder.moder().modify(|_, w| w.moder14().input());
                pupdr.pupdr().modify(|_, w| w.pupdr14().pull_up());
                PA14 { _mode: PhantomData }
            }
            #[doc = " Configures the pin to operate as an open drain output pin"]
            pub fn into_open_drain_output(
                self,
                moder: &mut MODER,
                otyper: &mut OTYPER,
            ) -> PA14<Output<OpenDrain>> {
                moder.moder().modify(|_, w| w.moder14().output());
                otyper.otyper().modify(|_, w| w.ot14().open_drain());
                PA14 { _mode: PhantomData }
            }
            #[doc = " Configures the pin to operate as an push pull output pin"]
            pub fn into_push_pull_output(
                self,
                moder: &mut MODER,
                otyper: &mut OTYPER,
            ) -> PA14<Output<PushPull>> {
                moder.moder().modify(|_, w| w.moder14().output());
                otyper.otyper().modify(|_, w| w.ot14().push_pull());
                PA14 { _mode: PhantomData }
            }
            #[doc = " Configures the pin to operate as analog, with disabled schmitt trigger."]
            #[doc = " This mode is suitable when the pin is connected to the DAC or ADC."]
            pub fn into_analog(self, moder: &mut MODER, pupdr: &mut PUPDR) -> PA14<Analog> {
                moder.moder().modify(|_, w| w.moder14().analog());
                pupdr.pupdr().modify(|_, w| w.pupdr14().floating());
                PA14 { _mode: PhantomData }
            }
        }
        impl PA14<Output<OpenDrain>> {
            #[doc = " Enables / disables the internal pull up"]
            pub fn internal_pull_up(&mut self, pupdr: &mut PUPDR, on: bool) {
                pupdr.pupdr().modify(|_, w| {
                    if on {
                        w.pupdr14().pull_up()
                    } else {
                        w.pupdr14().floating()
                    }
                });
            }
        }
        impl<MODE> PA14<Output<MODE>> {
            #[doc = " Erases the pin number from the type"]
            #[doc = ""]
            #[doc = " This is useful when you want to collect the pins into an array where you"]
            #[doc = " need all the elements to have the same type"]
            pub fn downgrade(self) -> PAx<Output<MODE>> {
                PAx {
                    i: 14,
                    _mode: self._mode,
                }
            }
        }
        impl<MODE> PA14<Input<MODE>> {
            #[doc = " Erases the pin number from the type"]
            #[doc = ""]
            #[doc = " This is useful when you want to collect the pins into an array where you"]
            #[doc = " need all the elements to have the same type"]
            pub fn downgrade(self) -> PAx<Input<MODE>> {
                PAx {
                    i: 14,
                    _mode: self._mode,
                }
            }
        }
        impl<MODE> OutputPin for PA14<Output<MODE>> {
            type Error = Infallible;
            fn set_high(&mut self) -> Result<(), Self::Error> {
                unsafe { (*GPIOA::ptr()).bsrr.write(|w| w.bs14().set()) }
                Ok(())
            }
            fn set_low(&mut self) -> Result<(), Self::Error> {
                unsafe { (*GPIOA::ptr()).bsrr.write(|w| w.br14().reset()) }
                Ok(())
            }
        }
        #[cfg(feature = "unproven")]
        impl<MODE> InputPin for PA14<Input<MODE>> {
            type Error = Infallible;
            fn is_high(&self) -> Result<bool, Self::Error> {
                Ok(!self.is_low()?)
            }
            fn is_low(&self) -> Result<bool, Self::Error> {
                Ok(unsafe { (*GPIOA::ptr()).idr.read().idr14().is_low() })
            }
        }
        #[cfg(feature = "unproven")]
        impl InputPin for PA14<Output<OpenDrain>> {
            type Error = Infallible;
            fn is_high(&self) -> Result<bool, Self::Error> {
                Ok(!self.is_low()?)
            }
            fn is_low(&self) -> Result<bool, Self::Error> {
                Ok(unsafe { (*GPIOA::ptr()).idr.read().idr14().is_low() })
            }
        }
        #[cfg(feature = "unproven")]
        impl<MODE> StatefulOutputPin for PA14<Output<MODE>> {
            fn is_set_high(&self) -> Result<bool, Self::Error> {
                self.is_set_low().map(|b| !b)
            }
            fn is_set_low(&self) -> Result<bool, Self::Error> {
                Ok(unsafe { (*GPIOA::ptr()).odr.read().odr14().is_low() })
            }
        }
        #[cfg(feature = "unproven")]
        impl<MODE> toggleable::Default for PA14<Output<MODE>> {}
        #[doc = "Pin `PA15`"]
        pub struct PA15<MODE> {
            _mode: PhantomData<MODE>,
        }
        impl<MODE> PA15<MODE> {
            #[doc = "Configures `PA15` to serve as alternate function: `AF0`"]
            pub fn into_af0(self, moder: &mut MODER, afr: &mut AFRH) -> PA15<AF0> {
                moder.moder().modify(|_, w| w.moder15().alternate());
                afr.afr().modify(|_, w| w.afrh15().af0());
                PA15 { _mode: PhantomData }
            }
            #[doc = "Configures `PA15` to serve as alternate function: `AF1`"]
            pub fn into_af1(self, moder: &mut MODER, afr: &mut AFRH) -> PA15<AF1> {
                moder.moder().modify(|_, w| w.moder15().alternate());
                afr.afr().modify(|_, w| w.afrh15().af1());
                PA15 { _mode: PhantomData }
            }
            #[doc = "Configures `PA15` to serve as alternate function: `AF2`"]
            pub fn into_af2(self, moder: &mut MODER, afr: &mut AFRH) -> PA15<AF2> {
                moder.moder().modify(|_, w| w.moder15().alternate());
                afr.afr().modify(|_, w| w.afrh15().af2());
                PA15 { _mode: PhantomData }
            }
            #[doc = "Configures `PA15` to serve as alternate function: `AF4`"]
            pub fn into_af4(self, moder: &mut MODER, afr: &mut AFRH) -> PA15<AF4> {
                moder.moder().modify(|_, w| w.moder15().alternate());
                afr.afr().modify(|_, w| w.afrh15().af4());
                PA15 { _mode: PhantomData }
            }
            #[doc = "Configures `PA15` to serve as alternate function: `AF5`"]
            pub fn into_af5(self, moder: &mut MODER, afr: &mut AFRH) -> PA15<AF5> {
                moder.moder().modify(|_, w| w.moder15().alternate());
                afr.afr().modify(|_, w| w.afrh15().af5());
                PA15 { _mode: PhantomData }
            }
            #[doc = "Configures `PA15` to serve as alternate function: `AF6`"]
            pub fn into_af6(self, moder: &mut MODER, afr: &mut AFRH) -> PA15<AF6> {
                moder.moder().modify(|_, w| w.moder15().alternate());
                afr.afr().modify(|_, w| w.afrh15().af6());
                PA15 { _mode: PhantomData }
            }
            #[doc = "Configures `PA15` to serve as alternate function: `AF7`"]
            pub fn into_af7(self, moder: &mut MODER, afr: &mut AFRH) -> PA15<AF7> {
                moder.moder().modify(|_, w| w.moder15().alternate());
                afr.afr().modify(|_, w| w.afrh15().af7());
                PA15 { _mode: PhantomData }
            }
            #[doc = "Configures `PA15` to serve as alternate function: `AF9`"]
            pub fn into_af9(self, moder: &mut MODER, afr: &mut AFRH) -> PA15<AF9> {
                moder.moder().modify(|_, w| w.moder15().alternate());
                afr.afr().modify(|_, w| w.afrh15().af9());
                PA15 { _mode: PhantomData }
            }
            #[doc = "Configures `PA15` to serve as alternate function: `AF15`"]
            pub fn into_af15(self, moder: &mut MODER, afr: &mut AFRH) -> PA15<AF15> {
                moder.moder().modify(|_, w| w.moder15().alternate());
                afr.afr().modify(|_, w| w.afrh15().af15());
                PA15 { _mode: PhantomData }
            }
            #[doc = " Configures the pin to operate as a floating input pin"]
            pub fn into_floating_input(
                self,
                moder: &mut MODER,
                pupdr: &mut PUPDR,
            ) -> PA15<Input<Floating>> {
                moder.moder().modify(|_, w| w.moder15().input());
                pupdr.pupdr().modify(|_, w| w.pupdr15().floating());
                PA15 { _mode: PhantomData }
            }
            #[doc = " Configures the pin to operate as a pulled down input pin"]
            pub fn into_pull_down_input(
                self,
                moder: &mut MODER,
                pupdr: &mut PUPDR,
            ) -> PA15<Input<PullDown>> {
                moder.moder().modify(|_, w| w.moder15().input());
                pupdr.pupdr().modify(|_, w| w.pupdr15().pull_down());
                PA15 { _mode: PhantomData }
            }
            #[doc = " Configures the pin to operate as a pulled up input pin"]
            pub fn into_pull_up_input(
                self,
                moder: &mut MODER,
                pupdr: &mut PUPDR,
            ) -> PA15<Input<PullUp>> {
                moder.moder().modify(|_, w| w.moder15().input());
                pupdr.pupdr().modify(|_, w| w.pupdr15().pull_up());
                PA15 { _mode: PhantomData }
            }
            #[doc = " Configures the pin to operate as an open drain output pin"]
            pub fn into_open_drain_output(
                self,
                moder: &mut MODER,
                otyper: &mut OTYPER,
            ) -> PA15<Output<OpenDrain>> {
                moder.moder().modify(|_, w| w.moder15().output());
                otyper.otyper().modify(|_, w| w.ot15().open_drain());
                PA15 { _mode: PhantomData }
            }
            #[doc = " Configures the pin to operate as an push pull output pin"]
            pub fn into_push_pull_output(
                self,
                moder: &mut MODER,
                otyper: &mut OTYPER,
            ) -> PA15<Output<PushPull>> {
                moder.moder().modify(|_, w| w.moder15().output());
                otyper.otyper().modify(|_, w| w.ot15().push_pull());
                PA15 { _mode: PhantomData }
            }
            #[doc = " Configures the pin to operate as analog, with disabled schmitt trigger."]
            #[doc = " This mode is suitable when the pin is connected to the DAC or ADC."]
            pub fn into_analog(self, moder: &mut MODER, pupdr: &mut PUPDR) -> PA15<Analog> {
                moder.moder().modify(|_, w| w.moder15().analog());
                pupdr.pupdr().modify(|_, w| w.pupdr15().floating());
                PA15 { _mode: PhantomData }
            }
        }
        impl PA15<Output<OpenDrain>> {
            #[doc = " Enables / disables the internal pull up"]
            pub fn internal_pull_up(&mut self, pupdr: &mut PUPDR, on: bool) {
                pupdr.pupdr().modify(|_, w| {
                    if on {
                        w.pupdr15().pull_up()
                    } else {
                        w.pupdr15().floating()
                    }
                });
            }
        }
        impl<MODE> PA15<Output<MODE>> {
            #[doc = " Erases the pin number from the type"]
            #[doc = ""]
            #[doc = " This is useful when you want to collect the pins into an array where you"]
            #[doc = " need all the elements to have the same type"]
            pub fn downgrade(self) -> PAx<Output<MODE>> {
                PAx {
                    i: 15,
                    _mode: self._mode,
                }
            }
        }
        impl<MODE> PA15<Input<MODE>> {
            #[doc = " Erases the pin number from the type"]
            #[doc = ""]
            #[doc = " This is useful when you want to collect the pins into an array where you"]
            #[doc = " need all the elements to have the same type"]
            pub fn downgrade(self) -> PAx<Input<MODE>> {
                PAx {
                    i: 15,
                    _mode: self._mode,
                }
            }
        }
        impl<MODE> OutputPin for PA15<Output<MODE>> {
            type Error = Infallible;
            fn set_high(&mut self) -> Result<(), Self::Error> {
                unsafe { (*GPIOA::ptr()).bsrr.write(|w| w.bs15().set()) }
                Ok(())
            }
            fn set_low(&mut self) -> Result<(), Self::Error> {
                unsafe { (*GPIOA::ptr()).bsrr.write(|w| w.br15().reset()) }
                Ok(())
            }
        }
        #[cfg(feature = "unproven")]
        impl<MODE> InputPin for PA15<Input<MODE>> {
            type Error = Infallible;
            fn is_high(&self) -> Result<bool, Self::Error> {
                Ok(!self.is_low()?)
            }
            fn is_low(&self) -> Result<bool, Self::Error> {
                Ok(unsafe { (*GPIOA::ptr()).idr.read().idr15().is_low() })
            }
        }
        #[cfg(feature = "unproven")]
        impl InputPin for PA15<Output<OpenDrain>> {
            type Error = Infallible;
            fn is_high(&self) -> Result<bool, Self::Error> {
                Ok(!self.is_low()?)
            }
            fn is_low(&self) -> Result<bool, Self::Error> {
                Ok(unsafe { (*GPIOA::ptr()).idr.read().idr15().is_low() })
            }
        }
        #[cfg(feature = "unproven")]
        impl<MODE> StatefulOutputPin for PA15<Output<MODE>> {
            fn is_set_high(&self) -> Result<bool, Self::Error> {
                self.is_set_low().map(|b| !b)
            }
            fn is_set_low(&self) -> Result<bool, Self::Error> {
                Ok(unsafe { (*GPIOA::ptr()).odr.read().odr15().is_low() })
            }
        }
        #[cfg(feature = "unproven")]
        impl<MODE> toggleable::Default for PA15<Output<MODE>> {}
    }
    #[doc = "All Pins and associated functions for GPIO Bank: `GPIOB`"]
    pub mod gpiob {
        use core::marker::PhantomData;
        use core::convert::Infallible;
        use crate::hal::digital::v2::OutputPin;
        #[cfg(feature = "unproven")]
        use crate::hal::digital::v2::InputPin;
        #[cfg(feature = "unproven")]
        use crate::hal::digital::v2::StatefulOutputPin;
        #[cfg(feature = "unproven")]
        use crate::hal::digital::v2::toggleable;
        use crate::pac::{gpiob, GPIOB};
        use crate::rcc::AHB;
        #[allow(unused_imports)]
        use super::{
            AF0, AF1, AF2, AF3, AF4, AF5, AF6, AF7, AF8, AF9, AF10, AF11, AF12, AF13, AF14, AF15,
        };
        use super::{
            Floating, GpioExt, Input, OpenDrain, Output, Analog, PullDown, PullUp, PushPull, PXx,
            Gpio,
        };
        #[doc = " GPIO parts"]
        pub struct Parts {
            #[doc = " Opaque AFRH register"]
            pub afrh: AFRH,
            #[doc = " Opaque AFRL register"]
            pub afrl: AFRL,
            #[doc = " Opaque MODER register"]
            pub moder: MODER,
            #[doc = " Opaque OTYPER register"]
            pub otyper: OTYPER,
            #[doc = " Opaque PUPDR register"]
            pub pupdr: PUPDR,
            #[doc = " Pin"]
            pub pb0: PB0<Input<Floating>>,
            #[doc = " Pin"]
            pub pb1: PB1<Input<Floating>>,
            #[doc = " Pin"]
            pub pb2: PB2<Input<Floating>>,
            #[doc = " Pin"]
            pub pb3: PB3<AF0>,
            #[doc = " Pin"]
            pub pb4: PB4<AF0>,
            #[doc = " Pin"]
            pub pb5: PB5<Input<Floating>>,
            #[doc = " Pin"]
            pub pb6: PB6<Input<Floating>>,
            #[doc = " Pin"]
            pub pb7: PB7<Input<Floating>>,
            #[doc = " Pin"]
            pub pb8: PB8<Input<Floating>>,
            #[doc = " Pin"]
            pub pb9: PB9<Input<Floating>>,
            #[doc = " Pin"]
            pub pb10: PB10<Input<Floating>>,
            #[doc = " Pin"]
            pub pb11: PB11<Input<Floating>>,
            #[doc = " Pin"]
            pub pb12: PB12<Input<Floating>>,
            #[doc = " Pin"]
            pub pb13: PB13<Input<Floating>>,
            #[doc = " Pin"]
            pub pb14: PB14<Input<Floating>>,
            #[doc = " Pin"]
            pub pb15: PB15<Input<Floating>>,
        }
        impl GpioExt for GPIOB {
            type Parts = Parts;
            fn split(self, ahb: &mut AHB) -> Parts {
                ahb.enr().modify(|_, w| w.iopben().set_bit());
                ahb.rstr().modify(|_, w| w.iopbrst().set_bit());
                ahb.rstr().modify(|_, w| w.iopbrst().clear_bit());
                Parts {
                    afrh: AFRH { _0: () },
                    afrl: AFRL { _0: () },
                    moder: MODER { _0: () },
                    otyper: OTYPER { _0: () },
                    pupdr: PUPDR { _0: () },
                    pb0: PB0 { _mode: PhantomData },
                    pb1: PB1 { _mode: PhantomData },
                    pb2: PB2 { _mode: PhantomData },
                    pb3: PB3 { _mode: PhantomData },
                    pb4: PB4 { _mode: PhantomData },
                    pb5: PB5 { _mode: PhantomData },
                    pb6: PB6 { _mode: PhantomData },
                    pb7: PB7 { _mode: PhantomData },
                    pb8: PB8 { _mode: PhantomData },
                    pb9: PB9 { _mode: PhantomData },
                    pb10: PB10 { _mode: PhantomData },
                    pb11: PB11 { _mode: PhantomData },
                    pb12: PB12 { _mode: PhantomData },
                    pb13: PB13 { _mode: PhantomData },
                    pb14: PB14 { _mode: PhantomData },
                    pb15: PB15 { _mode: PhantomData },
                }
            }
        }
        #[doc = " Opaque AFRL register"]
        pub struct AFRL {
            _0: (),
        }
        impl AFRL {
            #[allow(dead_code)]
            pub(crate) fn afr(&mut self) -> &gpiob::AFRL {
                unsafe { &(*GPIOB::ptr()).afrl }
            }
        }
        #[doc = " Opaque AFRH register"]
        pub struct AFRH {
            _0: (),
        }
        impl AFRH {
            #[allow(dead_code)]
            pub(crate) fn afr(&mut self) -> &gpiob::AFRH {
                unsafe { &(*GPIOB::ptr()).afrh }
            }
        }
        #[doc = " Opaque MODER register"]
        pub struct MODER {
            _0: (),
        }
        impl MODER {
            pub(crate) fn moder(&mut self) -> &gpiob::MODER {
                unsafe { &(*GPIOB::ptr()).moder }
            }
        }
        #[doc = " Opaque OTYPER register"]
        pub struct OTYPER {
            _0: (),
        }
        impl OTYPER {
            pub(crate) fn otyper(&mut self) -> &gpiob::OTYPER {
                unsafe { &(*GPIOB::ptr()).otyper }
            }
        }
        #[doc = " Opaque PUPDR register"]
        pub struct PUPDR {
            _0: (),
        }
        impl PUPDR {
            pub(crate) fn pupdr(&mut self) -> &gpiob::PUPDR {
                unsafe { &(*GPIOB::ptr()).pupdr }
            }
        }
        #[doc = " Partially erased pin"]
        pub struct PBx<MODE> {
            i: u8,
            _mode: PhantomData<MODE>,
        }
        impl<MODE> PBx<MODE> {
            #[doc = " Erases the port letter from the type"]
            #[doc = ""]
            #[doc = " This is useful when you want to collect the pins into an array where you"]
            #[doc = " need all the elements to have the same type"]
            pub fn downgrade(self) -> PXx<MODE> {
                PXx {
                    i: self.i,
                    gpio: Gpio::GPIOB,
                    _mode: self._mode,
                }
            }
        }
        impl<MODE> OutputPin for PBx<Output<MODE>> {
            type Error = Infallible;
            fn set_high(&mut self) -> Result<(), Self::Error> {
                unsafe { (*GPIOB::ptr()).bsrr.write(|w| w.bits(1 << self.i)) }
                Ok(())
            }
            fn set_low(&mut self) -> Result<(), Self::Error> {
                unsafe { (*GPIOB::ptr()).bsrr.write(|w| w.bits(1 << (16 + self.i))) }
                Ok(())
            }
        }
        #[cfg(feature = "unproven")]
        impl<MODE> InputPin for PBx<Input<MODE>> {
            type Error = Infallible;
            fn is_high(&self) -> Result<bool, Self::Error> {
                Ok(!self.is_low()?)
            }
            fn is_low(&self) -> Result<bool, Self::Error> {
                Ok(unsafe { (*GPIOB::ptr()).idr.read().bits() & (1 << self.i) == 0 })
            }
        }
        #[cfg(feature = "unproven")]
        impl InputPin for PBx<Output<OpenDrain>> {
            type Error = Infallible;
            fn is_high(&self) -> Result<bool, Self::Error> {
                Ok(!self.is_low()?)
            }
            fn is_low(&self) -> Result<bool, Self::Error> {
                Ok(unsafe { (*GPIOB::ptr()).idr.read().bits() & (1 << self.i) == 0 })
            }
        }
        #[cfg(feature = "unproven")]
        impl<MODE> StatefulOutputPin for PBx<Output<MODE>> {
            fn is_set_high(&self) -> Result<bool, Self::Error> {
                self.is_set_low().map(|b| !b)
            }
            fn is_set_low(&self) -> Result<bool, Self::Error> {
                Ok(unsafe { (*GPIOB::ptr()).odr.read().bits() & (1 << self.i) == 0 })
            }
        }
        #[cfg(feature = "unproven")]
        impl<MODE> toggleable::Default for PBx<Output<MODE>> {}
        #[doc = "Pin `PB0`"]
        pub struct PB0<MODE> {
            _mode: PhantomData<MODE>,
        }
        impl<MODE> PB0<MODE> {
            #[doc = "Configures `PB0` to serve as alternate function: `AF2`"]
            pub fn into_af2(self, moder: &mut MODER, afr: &mut AFRL) -> PB0<AF2> {
                moder.moder().modify(|_, w| w.moder0().alternate());
                afr.afr().modify(|_, w| w.afrl0().af2());
                PB0 { _mode: PhantomData }
            }
            #[doc = "Configures `PB0` to serve as alternate function: `AF3`"]
            pub fn into_af3(self, moder: &mut MODER, afr: &mut AFRL) -> PB0<AF3> {
                moder.moder().modify(|_, w| w.moder0().alternate());
                afr.afr().modify(|_, w| w.afrl0().af3());
                PB0 { _mode: PhantomData }
            }
            #[doc = "Configures `PB0` to serve as alternate function: `AF4`"]
            pub fn into_af4(self, moder: &mut MODER, afr: &mut AFRL) -> PB0<AF4> {
                moder.moder().modify(|_, w| w.moder0().alternate());
                afr.afr().modify(|_, w| w.afrl0().af4());
                PB0 { _mode: PhantomData }
            }
            #[doc = "Configures `PB0` to serve as alternate function: `AF6`"]
            pub fn into_af6(self, moder: &mut MODER, afr: &mut AFRL) -> PB0<AF6> {
                moder.moder().modify(|_, w| w.moder0().alternate());
                afr.afr().modify(|_, w| w.afrl0().af6());
                PB0 { _mode: PhantomData }
            }
            #[doc = "Configures `PB0` to serve as alternate function: `AF15`"]
            pub fn into_af15(self, moder: &mut MODER, afr: &mut AFRL) -> PB0<AF15> {
                moder.moder().modify(|_, w| w.moder0().alternate());
                afr.afr().modify(|_, w| w.afrl0().af15());
                PB0 { _mode: PhantomData }
            }
            #[doc = " Configures the pin to operate as a floating input pin"]
            pub fn into_floating_input(
                self,
                moder: &mut MODER,
                pupdr: &mut PUPDR,
            ) -> PB0<Input<Floating>> {
                moder.moder().modify(|_, w| w.moder0().input());
                pupdr.pupdr().modify(|_, w| w.pupdr0().floating());
                PB0 { _mode: PhantomData }
            }
            #[doc = " Configures the pin to operate as a pulled down input pin"]
            pub fn into_pull_down_input(
                self,
                moder: &mut MODER,
                pupdr: &mut PUPDR,
            ) -> PB0<Input<PullDown>> {
                moder.moder().modify(|_, w| w.moder0().input());
                pupdr.pupdr().modify(|_, w| w.pupdr0().pull_down());
                PB0 { _mode: PhantomData }
            }
            #[doc = " Configures the pin to operate as a pulled up input pin"]
            pub fn into_pull_up_input(
                self,
                moder: &mut MODER,
                pupdr: &mut PUPDR,
            ) -> PB0<Input<PullUp>> {
                moder.moder().modify(|_, w| w.moder0().input());
                pupdr.pupdr().modify(|_, w| w.pupdr0().pull_up());
                PB0 { _mode: PhantomData }
            }
            #[doc = " Configures the pin to operate as an open drain output pin"]
            pub fn into_open_drain_output(
                self,
                moder: &mut MODER,
                otyper: &mut OTYPER,
            ) -> PB0<Output<OpenDrain>> {
                moder.moder().modify(|_, w| w.moder0().output());
                otyper.otyper().modify(|_, w| w.ot0().open_drain());
                PB0 { _mode: PhantomData }
            }
            #[doc = " Configures the pin to operate as an push pull output pin"]
            pub fn into_push_pull_output(
                self,
                moder: &mut MODER,
                otyper: &mut OTYPER,
            ) -> PB0<Output<PushPull>> {
                moder.moder().modify(|_, w| w.moder0().output());
                otyper.otyper().modify(|_, w| w.ot0().push_pull());
                PB0 { _mode: PhantomData }
            }
            #[doc = " Configures the pin to operate as analog, with disabled schmitt trigger."]
            #[doc = " This mode is suitable when the pin is connected to the DAC or ADC."]
            pub fn into_analog(self, moder: &mut MODER, pupdr: &mut PUPDR) -> PB0<Analog> {
                moder.moder().modify(|_, w| w.moder0().analog());
                pupdr.pupdr().modify(|_, w| w.pupdr0().floating());
                PB0 { _mode: PhantomData }
            }
        }
        impl PB0<Output<OpenDrain>> {
            #[doc = " Enables / disables the internal pull up"]
            pub fn internal_pull_up(&mut self, pupdr: &mut PUPDR, on: bool) {
                pupdr.pupdr().modify(|_, w| {
                    if on {
                        w.pupdr0().pull_up()
                    } else {
                        w.pupdr0().floating()
                    }
                });
            }
        }
        impl<MODE> PB0<Output<MODE>> {
            #[doc = " Erases the pin number from the type"]
            #[doc = ""]
            #[doc = " This is useful when you want to collect the pins into an array where you"]
            #[doc = " need all the elements to have the same type"]
            pub fn downgrade(self) -> PBx<Output<MODE>> {
                PBx {
                    i: 0,
                    _mode: self._mode,
                }
            }
        }
        impl<MODE> PB0<Input<MODE>> {
            #[doc = " Erases the pin number from the type"]
            #[doc = ""]
            #[doc = " This is useful when you want to collect the pins into an array where you"]
            #[doc = " need all the elements to have the same type"]
            pub fn downgrade(self) -> PBx<Input<MODE>> {
                PBx {
                    i: 0,
                    _mode: self._mode,
                }
            }
        }
        impl<MODE> OutputPin for PB0<Output<MODE>> {
            type Error = Infallible;
            fn set_high(&mut self) -> Result<(), Self::Error> {
                unsafe { (*GPIOB::ptr()).bsrr.write(|w| w.bs0().set()) }
                Ok(())
            }
            fn set_low(&mut self) -> Result<(), Self::Error> {
                unsafe { (*GPIOB::ptr()).bsrr.write(|w| w.br0().reset()) }
                Ok(())
            }
        }
        #[cfg(feature = "unproven")]
        impl<MODE> InputPin for PB0<Input<MODE>> {
            type Error = Infallible;
            fn is_high(&self) -> Result<bool, Self::Error> {
                Ok(!self.is_low()?)
            }
            fn is_low(&self) -> Result<bool, Self::Error> {
                Ok(unsafe { (*GPIOB::ptr()).idr.read().idr0().is_low() })
            }
        }
        #[cfg(feature = "unproven")]
        impl InputPin for PB0<Output<OpenDrain>> {
            type Error = Infallible;
            fn is_high(&self) -> Result<bool, Self::Error> {
                Ok(!self.is_low()?)
            }
            fn is_low(&self) -> Result<bool, Self::Error> {
                Ok(unsafe { (*GPIOB::ptr()).idr.read().idr0().is_low() })
            }
        }
        #[cfg(feature = "unproven")]
        impl<MODE> StatefulOutputPin for PB0<Output<MODE>> {
            fn is_set_high(&self) -> Result<bool, Self::Error> {
                self.is_set_low().map(|b| !b)
            }
            fn is_set_low(&self) -> Result<bool, Self::Error> {
                Ok(unsafe { (*GPIOB::ptr()).odr.read().odr0().is_low() })
            }
        }
        #[cfg(feature = "unproven")]
        impl<MODE> toggleable::Default for PB0<Output<MODE>> {}
        #[doc = "Pin `PB1`"]
        pub struct PB1<MODE> {
            _mode: PhantomData<MODE>,
        }
        impl<MODE> PB1<MODE> {
            #[doc = "Configures `PB1` to serve as alternate function: `AF2`"]
            pub fn into_af2(self, moder: &mut MODER, afr: &mut AFRL) -> PB1<AF2> {
                moder.moder().modify(|_, w| w.moder1().alternate());
                afr.afr().modify(|_, w| w.afrl1().af2());
                PB1 { _mode: PhantomData }
            }
            #[doc = "Configures `PB1` to serve as alternate function: `AF3`"]
            pub fn into_af3(self, moder: &mut MODER, afr: &mut AFRL) -> PB1<AF3> {
                moder.moder().modify(|_, w| w.moder1().alternate());
                afr.afr().modify(|_, w| w.afrl1().af3());
                PB1 { _mode: PhantomData }
            }
            #[doc = "Configures `PB1` to serve as alternate function: `AF4`"]
            pub fn into_af4(self, moder: &mut MODER, afr: &mut AFRL) -> PB1<AF4> {
                moder.moder().modify(|_, w| w.moder1().alternate());
                afr.afr().modify(|_, w| w.afrl1().af4());
                PB1 { _mode: PhantomData }
            }
            #[doc = "Configures `PB1` to serve as alternate function: `AF6`"]
            pub fn into_af6(self, moder: &mut MODER, afr: &mut AFRL) -> PB1<AF6> {
                moder.moder().modify(|_, w| w.moder1().alternate());
                afr.afr().modify(|_, w| w.afrl1().af6());
                PB1 { _mode: PhantomData }
            }
            #[doc = "Configures `PB1` to serve as alternate function: `AF8`"]
            pub fn into_af8(self, moder: &mut MODER, afr: &mut AFRL) -> PB1<AF8> {
                moder.moder().modify(|_, w| w.moder1().alternate());
                afr.afr().modify(|_, w| w.afrl1().af8());
                PB1 { _mode: PhantomData }
            }
            #[doc = "Configures `PB1` to serve as alternate function: `AF15`"]
            pub fn into_af15(self, moder: &mut MODER, afr: &mut AFRL) -> PB1<AF15> {
                moder.moder().modify(|_, w| w.moder1().alternate());
                afr.afr().modify(|_, w| w.afrl1().af15());
                PB1 { _mode: PhantomData }
            }
            #[doc = " Configures the pin to operate as a floating input pin"]
            pub fn into_floating_input(
                self,
                moder: &mut MODER,
                pupdr: &mut PUPDR,
            ) -> PB1<Input<Floating>> {
                moder.moder().modify(|_, w| w.moder1().input());
                pupdr.pupdr().modify(|_, w| w.pupdr1().floating());
                PB1 { _mode: PhantomData }
            }
            #[doc = " Configures the pin to operate as a pulled down input pin"]
            pub fn into_pull_down_input(
                self,
                moder: &mut MODER,
                pupdr: &mut PUPDR,
            ) -> PB1<Input<PullDown>> {
                moder.moder().modify(|_, w| w.moder1().input());
                pupdr.pupdr().modify(|_, w| w.pupdr1().pull_down());
                PB1 { _mode: PhantomData }
            }
            #[doc = " Configures the pin to operate as a pulled up input pin"]
            pub fn into_pull_up_input(
                self,
                moder: &mut MODER,
                pupdr: &mut PUPDR,
            ) -> PB1<Input<PullUp>> {
                moder.moder().modify(|_, w| w.moder1().input());
                pupdr.pupdr().modify(|_, w| w.pupdr1().pull_up());
                PB1 { _mode: PhantomData }
            }
            #[doc = " Configures the pin to operate as an open drain output pin"]
            pub fn into_open_drain_output(
                self,
                moder: &mut MODER,
                otyper: &mut OTYPER,
            ) -> PB1<Output<OpenDrain>> {
                moder.moder().modify(|_, w| w.moder1().output());
                otyper.otyper().modify(|_, w| w.ot1().open_drain());
                PB1 { _mode: PhantomData }
            }
            #[doc = " Configures the pin to operate as an push pull output pin"]
            pub fn into_push_pull_output(
                self,
                moder: &mut MODER,
                otyper: &mut OTYPER,
            ) -> PB1<Output<PushPull>> {
                moder.moder().modify(|_, w| w.moder1().output());
                otyper.otyper().modify(|_, w| w.ot1().push_pull());
                PB1 { _mode: PhantomData }
            }
            #[doc = " Configures the pin to operate as analog, with disabled schmitt trigger."]
            #[doc = " This mode is suitable when the pin is connected to the DAC or ADC."]
            pub fn into_analog(self, moder: &mut MODER, pupdr: &mut PUPDR) -> PB1<Analog> {
                moder.moder().modify(|_, w| w.moder1().analog());
                pupdr.pupdr().modify(|_, w| w.pupdr1().floating());
                PB1 { _mode: PhantomData }
            }
        }
        impl PB1<Output<OpenDrain>> {
            #[doc = " Enables / disables the internal pull up"]
            pub fn internal_pull_up(&mut self, pupdr: &mut PUPDR, on: bool) {
                pupdr.pupdr().modify(|_, w| {
                    if on {
                        w.pupdr1().pull_up()
                    } else {
                        w.pupdr1().floating()
                    }
                });
            }
        }
        impl<MODE> PB1<Output<MODE>> {
            #[doc = " Erases the pin number from the type"]
            #[doc = ""]
            #[doc = " This is useful when you want to collect the pins into an array where you"]
            #[doc = " need all the elements to have the same type"]
            pub fn downgrade(self) -> PBx<Output<MODE>> {
                PBx {
                    i: 1,
                    _mode: self._mode,
                }
            }
        }
        impl<MODE> PB1<Input<MODE>> {
            #[doc = " Erases the pin number from the type"]
            #[doc = ""]
            #[doc = " This is useful when you want to collect the pins into an array where you"]
            #[doc = " need all the elements to have the same type"]
            pub fn downgrade(self) -> PBx<Input<MODE>> {
                PBx {
                    i: 1,
                    _mode: self._mode,
                }
            }
        }
        impl<MODE> OutputPin for PB1<Output<MODE>> {
            type Error = Infallible;
            fn set_high(&mut self) -> Result<(), Self::Error> {
                unsafe { (*GPIOB::ptr()).bsrr.write(|w| w.bs1().set()) }
                Ok(())
            }
            fn set_low(&mut self) -> Result<(), Self::Error> {
                unsafe { (*GPIOB::ptr()).bsrr.write(|w| w.br1().reset()) }
                Ok(())
            }
        }
        #[cfg(feature = "unproven")]
        impl<MODE> InputPin for PB1<Input<MODE>> {
            type Error = Infallible;
            fn is_high(&self) -> Result<bool, Self::Error> {
                Ok(!self.is_low()?)
            }
            fn is_low(&self) -> Result<bool, Self::Error> {
                Ok(unsafe { (*GPIOB::ptr()).idr.read().idr1().is_low() })
            }
        }
        #[cfg(feature = "unproven")]
        impl InputPin for PB1<Output<OpenDrain>> {
            type Error = Infallible;
            fn is_high(&self) -> Result<bool, Self::Error> {
                Ok(!self.is_low()?)
            }
            fn is_low(&self) -> Result<bool, Self::Error> {
                Ok(unsafe { (*GPIOB::ptr()).idr.read().idr1().is_low() })
            }
        }
        #[cfg(feature = "unproven")]
        impl<MODE> StatefulOutputPin for PB1<Output<MODE>> {
            fn is_set_high(&self) -> Result<bool, Self::Error> {
                self.is_set_low().map(|b| !b)
            }
            fn is_set_low(&self) -> Result<bool, Self::Error> {
                Ok(unsafe { (*GPIOB::ptr()).odr.read().odr1().is_low() })
            }
        }
        #[cfg(feature = "unproven")]
        impl<MODE> toggleable::Default for PB1<Output<MODE>> {}
        #[doc = "Pin `PB2`"]
        pub struct PB2<MODE> {
            _mode: PhantomData<MODE>,
        }
        impl<MODE> PB2<MODE> {
            #[doc = "Configures `PB2` to serve as alternate function: `AF3`"]
            pub fn into_af3(self, moder: &mut MODER, afr: &mut AFRL) -> PB2<AF3> {
                moder.moder().modify(|_, w| w.moder2().alternate());
                afr.afr().modify(|_, w| w.afrl2().af3());
                PB2 { _mode: PhantomData }
            }
            #[doc = "Configures `PB2` to serve as alternate function: `AF15`"]
            pub fn into_af15(self, moder: &mut MODER, afr: &mut AFRL) -> PB2<AF15> {
                moder.moder().modify(|_, w| w.moder2().alternate());
                afr.afr().modify(|_, w| w.afrl2().af15());
                PB2 { _mode: PhantomData }
            }
            #[doc = " Configures the pin to operate as a floating input pin"]
            pub fn into_floating_input(
                self,
                moder: &mut MODER,
                pupdr: &mut PUPDR,
            ) -> PB2<Input<Floating>> {
                moder.moder().modify(|_, w| w.moder2().input());
                pupdr.pupdr().modify(|_, w| w.pupdr2().floating());
                PB2 { _mode: PhantomData }
            }
            #[doc = " Configures the pin to operate as a pulled down input pin"]
            pub fn into_pull_down_input(
                self,
                moder: &mut MODER,
                pupdr: &mut PUPDR,
            ) -> PB2<Input<PullDown>> {
                moder.moder().modify(|_, w| w.moder2().input());
                pupdr.pupdr().modify(|_, w| w.pupdr2().pull_down());
                PB2 { _mode: PhantomData }
            }
            #[doc = " Configures the pin to operate as a pulled up input pin"]
            pub fn into_pull_up_input(
                self,
                moder: &mut MODER,
                pupdr: &mut PUPDR,
            ) -> PB2<Input<PullUp>> {
                moder.moder().modify(|_, w| w.moder2().input());
                pupdr.pupdr().modify(|_, w| w.pupdr2().pull_up());
                PB2 { _mode: PhantomData }
            }
            #[doc = " Configures the pin to operate as an open drain output pin"]
            pub fn into_open_drain_output(
                self,
                moder: &mut MODER,
                otyper: &mut OTYPER,
            ) -> PB2<Output<OpenDrain>> {
                moder.moder().modify(|_, w| w.moder2().output());
                otyper.otyper().modify(|_, w| w.ot2().open_drain());
                PB2 { _mode: PhantomData }
            }
            #[doc = " Configures the pin to operate as an push pull output pin"]
            pub fn into_push_pull_output(
                self,
                moder: &mut MODER,
                otyper: &mut OTYPER,
            ) -> PB2<Output<PushPull>> {
                moder.moder().modify(|_, w| w.moder2().output());
                otyper.otyper().modify(|_, w| w.ot2().push_pull());
                PB2 { _mode: PhantomData }
            }
            #[doc = " Configures the pin to operate as analog, with disabled schmitt trigger."]
            #[doc = " This mode is suitable when the pin is connected to the DAC or ADC."]
            pub fn into_analog(self, moder: &mut MODER, pupdr: &mut PUPDR) -> PB2<Analog> {
                moder.moder().modify(|_, w| w.moder2().analog());
                pupdr.pupdr().modify(|_, w| w.pupdr2().floating());
                PB2 { _mode: PhantomData }
            }
        }
        impl PB2<Output<OpenDrain>> {
            #[doc = " Enables / disables the internal pull up"]
            pub fn internal_pull_up(&mut self, pupdr: &mut PUPDR, on: bool) {
                pupdr.pupdr().modify(|_, w| {
                    if on {
                        w.pupdr2().pull_up()
                    } else {
                        w.pupdr2().floating()
                    }
                });
            }
        }
        impl<MODE> PB2<Output<MODE>> {
            #[doc = " Erases the pin number from the type"]
            #[doc = ""]
            #[doc = " This is useful when you want to collect the pins into an array where you"]
            #[doc = " need all the elements to have the same type"]
            pub fn downgrade(self) -> PBx<Output<MODE>> {
                PBx {
                    i: 2,
                    _mode: self._mode,
                }
            }
        }
        impl<MODE> PB2<Input<MODE>> {
            #[doc = " Erases the pin number from the type"]
            #[doc = ""]
            #[doc = " This is useful when you want to collect the pins into an array where you"]
            #[doc = " need all the elements to have the same type"]
            pub fn downgrade(self) -> PBx<Input<MODE>> {
                PBx {
                    i: 2,
                    _mode: self._mode,
                }
            }
        }
        impl<MODE> OutputPin for PB2<Output<MODE>> {
            type Error = Infallible;
            fn set_high(&mut self) -> Result<(), Self::Error> {
                unsafe { (*GPIOB::ptr()).bsrr.write(|w| w.bs2().set()) }
                Ok(())
            }
            fn set_low(&mut self) -> Result<(), Self::Error> {
                unsafe { (*GPIOB::ptr()).bsrr.write(|w| w.br2().reset()) }
                Ok(())
            }
        }
        #[cfg(feature = "unproven")]
        impl<MODE> InputPin for PB2<Input<MODE>> {
            type Error = Infallible;
            fn is_high(&self) -> Result<bool, Self::Error> {
                Ok(!self.is_low()?)
            }
            fn is_low(&self) -> Result<bool, Self::Error> {
                Ok(unsafe { (*GPIOB::ptr()).idr.read().idr2().is_low() })
            }
        }
        #[cfg(feature = "unproven")]
        impl InputPin for PB2<Output<OpenDrain>> {
            type Error = Infallible;
            fn is_high(&self) -> Result<bool, Self::Error> {
                Ok(!self.is_low()?)
            }
            fn is_low(&self) -> Result<bool, Self::Error> {
                Ok(unsafe { (*GPIOB::ptr()).idr.read().idr2().is_low() })
            }
        }
        #[cfg(feature = "unproven")]
        impl<MODE> StatefulOutputPin for PB2<Output<MODE>> {
            fn is_set_high(&self) -> Result<bool, Self::Error> {
                self.is_set_low().map(|b| !b)
            }
            fn is_set_low(&self) -> Result<bool, Self::Error> {
                Ok(unsafe { (*GPIOB::ptr()).odr.read().odr2().is_low() })
            }
        }
        #[cfg(feature = "unproven")]
        impl<MODE> toggleable::Default for PB2<Output<MODE>> {}
        #[doc = "Pin `PB3`"]
        pub struct PB3<MODE> {
            _mode: PhantomData<MODE>,
        }
        impl<MODE> PB3<MODE> {
            #[doc = "Configures `PB3` to serve as alternate function: `AF0`"]
            pub fn into_af0(self, moder: &mut MODER, afr: &mut AFRL) -> PB3<AF0> {
                moder.moder().modify(|_, w| w.moder3().alternate());
                afr.afr().modify(|_, w| w.afrl3().af0());
                PB3 { _mode: PhantomData }
            }
            #[doc = "Configures `PB3` to serve as alternate function: `AF1`"]
            pub fn into_af1(self, moder: &mut MODER, afr: &mut AFRL) -> PB3<AF1> {
                moder.moder().modify(|_, w| w.moder3().alternate());
                afr.afr().modify(|_, w| w.afrl3().af1());
                PB3 { _mode: PhantomData }
            }
            #[doc = "Configures `PB3` to serve as alternate function: `AF2`"]
            pub fn into_af2(self, moder: &mut MODER, afr: &mut AFRL) -> PB3<AF2> {
                moder.moder().modify(|_, w| w.moder3().alternate());
                afr.afr().modify(|_, w| w.afrl3().af2());
                PB3 { _mode: PhantomData }
            }
            #[doc = "Configures `PB3` to serve as alternate function: `AF3`"]
            pub fn into_af3(self, moder: &mut MODER, afr: &mut AFRL) -> PB3<AF3> {
                moder.moder().modify(|_, w| w.moder3().alternate());
                afr.afr().modify(|_, w| w.afrl3().af3());
                PB3 { _mode: PhantomData }
            }
            #[doc = "Configures `PB3` to serve as alternate function: `AF4`"]
            pub fn into_af4(self, moder: &mut MODER, afr: &mut AFRL) -> PB3<AF4> {
                moder.moder().modify(|_, w| w.moder3().alternate());
                afr.afr().modify(|_, w| w.afrl3().af4());
                PB3 { _mode: PhantomData }
            }
            #[doc = "Configures `PB3` to serve as alternate function: `AF5`"]
            pub fn into_af5(self, moder: &mut MODER, afr: &mut AFRL) -> PB3<AF5> {
                moder.moder().modify(|_, w| w.moder3().alternate());
                afr.afr().modify(|_, w| w.afrl3().af5());
                PB3 { _mode: PhantomData }
            }
            #[doc = "Configures `PB3` to serve as alternate function: `AF6`"]
            pub fn into_af6(self, moder: &mut MODER, afr: &mut AFRL) -> PB3<AF6> {
                moder.moder().modify(|_, w| w.moder3().alternate());
                afr.afr().modify(|_, w| w.afrl3().af6());
                PB3 { _mode: PhantomData }
            }
            #[doc = "Configures `PB3` to serve as alternate function: `AF7`"]
            pub fn into_af7(self, moder: &mut MODER, afr: &mut AFRL) -> PB3<AF7> {
                moder.moder().modify(|_, w| w.moder3().alternate());
                afr.afr().modify(|_, w| w.afrl3().af7());
                PB3 { _mode: PhantomData }
            }
            #[doc = "Configures `PB3` to serve as alternate function: `AF10`"]
            pub fn into_af10(self, moder: &mut MODER, afr: &mut AFRL) -> PB3<AF10> {
                moder.moder().modify(|_, w| w.moder3().alternate());
                afr.afr().modify(|_, w| w.afrl3().af10());
                PB3 { _mode: PhantomData }
            }
            #[doc = "Configures `PB3` to serve as alternate function: `AF15`"]
            pub fn into_af15(self, moder: &mut MODER, afr: &mut AFRL) -> PB3<AF15> {
                moder.moder().modify(|_, w| w.moder3().alternate());
                afr.afr().modify(|_, w| w.afrl3().af15());
                PB3 { _mode: PhantomData }
            }
            #[doc = " Configures the pin to operate as a floating input pin"]
            pub fn into_floating_input(
                self,
                moder: &mut MODER,
                pupdr: &mut PUPDR,
            ) -> PB3<Input<Floating>> {
                moder.moder().modify(|_, w| w.moder3().input());
                pupdr.pupdr().modify(|_, w| w.pupdr3().floating());
                PB3 { _mode: PhantomData }
            }
            #[doc = " Configures the pin to operate as a pulled down input pin"]
            pub fn into_pull_down_input(
                self,
                moder: &mut MODER,
                pupdr: &mut PUPDR,
            ) -> PB3<Input<PullDown>> {
                moder.moder().modify(|_, w| w.moder3().input());
                pupdr.pupdr().modify(|_, w| w.pupdr3().pull_down());
                PB3 { _mode: PhantomData }
            }
            #[doc = " Configures the pin to operate as a pulled up input pin"]
            pub fn into_pull_up_input(
                self,
                moder: &mut MODER,
                pupdr: &mut PUPDR,
            ) -> PB3<Input<PullUp>> {
                moder.moder().modify(|_, w| w.moder3().input());
                pupdr.pupdr().modify(|_, w| w.pupdr3().pull_up());
                PB3 { _mode: PhantomData }
            }
            #[doc = " Configures the pin to operate as an open drain output pin"]
            pub fn into_open_drain_output(
                self,
                moder: &mut MODER,
                otyper: &mut OTYPER,
            ) -> PB3<Output<OpenDrain>> {
                moder.moder().modify(|_, w| w.moder3().output());
                otyper.otyper().modify(|_, w| w.ot3().open_drain());
                PB3 { _mode: PhantomData }
            }
            #[doc = " Configures the pin to operate as an push pull output pin"]
            pub fn into_push_pull_output(
                self,
                moder: &mut MODER,
                otyper: &mut OTYPER,
            ) -> PB3<Output<PushPull>> {
                moder.moder().modify(|_, w| w.moder3().output());
                otyper.otyper().modify(|_, w| w.ot3().push_pull());
                PB3 { _mode: PhantomData }
            }
            #[doc = " Configures the pin to operate as analog, with disabled schmitt trigger."]
            #[doc = " This mode is suitable when the pin is connected to the DAC or ADC."]
            pub fn into_analog(self, moder: &mut MODER, pupdr: &mut PUPDR) -> PB3<Analog> {
                moder.moder().modify(|_, w| w.moder3().analog());
                pupdr.pupdr().modify(|_, w| w.pupdr3().floating());
                PB3 { _mode: PhantomData }
            }
        }
        impl PB3<Output<OpenDrain>> {
            #[doc = " Enables / disables the internal pull up"]
            pub fn internal_pull_up(&mut self, pupdr: &mut PUPDR, on: bool) {
                pupdr.pupdr().modify(|_, w| {
                    if on {
                        w.pupdr3().pull_up()
                    } else {
                        w.pupdr3().floating()
                    }
                });
            }
        }
        impl<MODE> PB3<Output<MODE>> {
            #[doc = " Erases the pin number from the type"]
            #[doc = ""]
            #[doc = " This is useful when you want to collect the pins into an array where you"]
            #[doc = " need all the elements to have the same type"]
            pub fn downgrade(self) -> PBx<Output<MODE>> {
                PBx {
                    i: 3,
                    _mode: self._mode,
                }
            }
        }
        impl<MODE> PB3<Input<MODE>> {
            #[doc = " Erases the pin number from the type"]
            #[doc = ""]
            #[doc = " This is useful when you want to collect the pins into an array where you"]
            #[doc = " need all the elements to have the same type"]
            pub fn downgrade(self) -> PBx<Input<MODE>> {
                PBx {
                    i: 3,
                    _mode: self._mode,
                }
            }
        }
        impl<MODE> OutputPin for PB3<Output<MODE>> {
            type Error = Infallible;
            fn set_high(&mut self) -> Result<(), Self::Error> {
                unsafe { (*GPIOB::ptr()).bsrr.write(|w| w.bs3().set()) }
                Ok(())
            }
            fn set_low(&mut self) -> Result<(), Self::Error> {
                unsafe { (*GPIOB::ptr()).bsrr.write(|w| w.br3().reset()) }
                Ok(())
            }
        }
        #[cfg(feature = "unproven")]
        impl<MODE> InputPin for PB3<Input<MODE>> {
            type Error = Infallible;
            fn is_high(&self) -> Result<bool, Self::Error> {
                Ok(!self.is_low()?)
            }
            fn is_low(&self) -> Result<bool, Self::Error> {
                Ok(unsafe { (*GPIOB::ptr()).idr.read().idr3().is_low() })
            }
        }
        #[cfg(feature = "unproven")]
        impl InputPin for PB3<Output<OpenDrain>> {
            type Error = Infallible;
            fn is_high(&self) -> Result<bool, Self::Error> {
                Ok(!self.is_low()?)
            }
            fn is_low(&self) -> Result<bool, Self::Error> {
                Ok(unsafe { (*GPIOB::ptr()).idr.read().idr3().is_low() })
            }
        }
        #[cfg(feature = "unproven")]
        impl<MODE> StatefulOutputPin for PB3<Output<MODE>> {
            fn is_set_high(&self) -> Result<bool, Self::Error> {
                self.is_set_low().map(|b| !b)
            }
            fn is_set_low(&self) -> Result<bool, Self::Error> {
                Ok(unsafe { (*GPIOB::ptr()).odr.read().odr3().is_low() })
            }
        }
        #[cfg(feature = "unproven")]
        impl<MODE> toggleable::Default for PB3<Output<MODE>> {}
        #[doc = "Pin `PB4`"]
        pub struct PB4<MODE> {
            _mode: PhantomData<MODE>,
        }
        impl<MODE> PB4<MODE> {
            #[doc = "Configures `PB4` to serve as alternate function: `AF0`"]
            pub fn into_af0(self, moder: &mut MODER, afr: &mut AFRL) -> PB4<AF0> {
                moder.moder().modify(|_, w| w.moder4().alternate());
                afr.afr().modify(|_, w| w.afrl4().af0());
                PB4 { _mode: PhantomData }
            }
            #[doc = "Configures `PB4` to serve as alternate function: `AF1`"]
            pub fn into_af1(self, moder: &mut MODER, afr: &mut AFRL) -> PB4<AF1> {
                moder.moder().modify(|_, w| w.moder4().alternate());
                afr.afr().modify(|_, w| w.afrl4().af1());
                PB4 { _mode: PhantomData }
            }
            #[doc = "Configures `PB4` to serve as alternate function: `AF2`"]
            pub fn into_af2(self, moder: &mut MODER, afr: &mut AFRL) -> PB4<AF2> {
                moder.moder().modify(|_, w| w.moder4().alternate());
                afr.afr().modify(|_, w| w.afrl4().af2());
                PB4 { _mode: PhantomData }
            }
            #[doc = "Configures `PB4` to serve as alternate function: `AF3`"]
            pub fn into_af3(self, moder: &mut MODER, afr: &mut AFRL) -> PB4<AF3> {
                moder.moder().modify(|_, w| w.moder4().alternate());
                afr.afr().modify(|_, w| w.afrl4().af3());
                PB4 { _mode: PhantomData }
            }
            #[doc = "Configures `PB4` to serve as alternate function: `AF4`"]
            pub fn into_af4(self, moder: &mut MODER, afr: &mut AFRL) -> PB4<AF4> {
                moder.moder().modify(|_, w| w.moder4().alternate());
                afr.afr().modify(|_, w| w.afrl4().af4());
                PB4 { _mode: PhantomData }
            }
            #[doc = "Configures `PB4` to serve as alternate function: `AF5`"]
            pub fn into_af5(self, moder: &mut MODER, afr: &mut AFRL) -> PB4<AF5> {
                moder.moder().modify(|_, w| w.moder4().alternate());
                afr.afr().modify(|_, w| w.afrl4().af5());
                PB4 { _mode: PhantomData }
            }
            #[doc = "Configures `PB4` to serve as alternate function: `AF6`"]
            pub fn into_af6(self, moder: &mut MODER, afr: &mut AFRL) -> PB4<AF6> {
                moder.moder().modify(|_, w| w.moder4().alternate());
                afr.afr().modify(|_, w| w.afrl4().af6());
                PB4 { _mode: PhantomData }
            }
            #[doc = "Configures `PB4` to serve as alternate function: `AF7`"]
            pub fn into_af7(self, moder: &mut MODER, afr: &mut AFRL) -> PB4<AF7> {
                moder.moder().modify(|_, w| w.moder4().alternate());
                afr.afr().modify(|_, w| w.afrl4().af7());
                PB4 { _mode: PhantomData }
            }
            #[doc = "Configures `PB4` to serve as alternate function: `AF10`"]
            pub fn into_af10(self, moder: &mut MODER, afr: &mut AFRL) -> PB4<AF10> {
                moder.moder().modify(|_, w| w.moder4().alternate());
                afr.afr().modify(|_, w| w.afrl4().af10());
                PB4 { _mode: PhantomData }
            }
            #[doc = "Configures `PB4` to serve as alternate function: `AF15`"]
            pub fn into_af15(self, moder: &mut MODER, afr: &mut AFRL) -> PB4<AF15> {
                moder.moder().modify(|_, w| w.moder4().alternate());
                afr.afr().modify(|_, w| w.afrl4().af15());
                PB4 { _mode: PhantomData }
            }
            #[doc = " Configures the pin to operate as a floating input pin"]
            pub fn into_floating_input(
                self,
                moder: &mut MODER,
                pupdr: &mut PUPDR,
            ) -> PB4<Input<Floating>> {
                moder.moder().modify(|_, w| w.moder4().input());
                pupdr.pupdr().modify(|_, w| w.pupdr4().floating());
                PB4 { _mode: PhantomData }
            }
            #[doc = " Configures the pin to operate as a pulled down input pin"]
            pub fn into_pull_down_input(
                self,
                moder: &mut MODER,
                pupdr: &mut PUPDR,
            ) -> PB4<Input<PullDown>> {
                moder.moder().modify(|_, w| w.moder4().input());
                pupdr.pupdr().modify(|_, w| w.pupdr4().pull_down());
                PB4 { _mode: PhantomData }
            }
            #[doc = " Configures the pin to operate as a pulled up input pin"]
            pub fn into_pull_up_input(
                self,
                moder: &mut MODER,
                pupdr: &mut PUPDR,
            ) -> PB4<Input<PullUp>> {
                moder.moder().modify(|_, w| w.moder4().input());
                pupdr.pupdr().modify(|_, w| w.pupdr4().pull_up());
                PB4 { _mode: PhantomData }
            }
            #[doc = " Configures the pin to operate as an open drain output pin"]
            pub fn into_open_drain_output(
                self,
                moder: &mut MODER,
                otyper: &mut OTYPER,
            ) -> PB4<Output<OpenDrain>> {
                moder.moder().modify(|_, w| w.moder4().output());
                otyper.otyper().modify(|_, w| w.ot4().open_drain());
                PB4 { _mode: PhantomData }
            }
            #[doc = " Configures the pin to operate as an push pull output pin"]
            pub fn into_push_pull_output(
                self,
                moder: &mut MODER,
                otyper: &mut OTYPER,
            ) -> PB4<Output<PushPull>> {
                moder.moder().modify(|_, w| w.moder4().output());
                otyper.otyper().modify(|_, w| w.ot4().push_pull());
                PB4 { _mode: PhantomData }
            }
            #[doc = " Configures the pin to operate as analog, with disabled schmitt trigger."]
            #[doc = " This mode is suitable when the pin is connected to the DAC or ADC."]
            pub fn into_analog(self, moder: &mut MODER, pupdr: &mut PUPDR) -> PB4<Analog> {
                moder.moder().modify(|_, w| w.moder4().analog());
                pupdr.pupdr().modify(|_, w| w.pupdr4().floating());
                PB4 { _mode: PhantomData }
            }
        }
        impl PB4<Output<OpenDrain>> {
            #[doc = " Enables / disables the internal pull up"]
            pub fn internal_pull_up(&mut self, pupdr: &mut PUPDR, on: bool) {
                pupdr.pupdr().modify(|_, w| {
                    if on {
                        w.pupdr4().pull_up()
                    } else {
                        w.pupdr4().floating()
                    }
                });
            }
        }
        impl<MODE> PB4<Output<MODE>> {
            #[doc = " Erases the pin number from the type"]
            #[doc = ""]
            #[doc = " This is useful when you want to collect the pins into an array where you"]
            #[doc = " need all the elements to have the same type"]
            pub fn downgrade(self) -> PBx<Output<MODE>> {
                PBx {
                    i: 4,
                    _mode: self._mode,
                }
            }
        }
        impl<MODE> PB4<Input<MODE>> {
            #[doc = " Erases the pin number from the type"]
            #[doc = ""]
            #[doc = " This is useful when you want to collect the pins into an array where you"]
            #[doc = " need all the elements to have the same type"]
            pub fn downgrade(self) -> PBx<Input<MODE>> {
                PBx {
                    i: 4,
                    _mode: self._mode,
                }
            }
        }
        impl<MODE> OutputPin for PB4<Output<MODE>> {
            type Error = Infallible;
            fn set_high(&mut self) -> Result<(), Self::Error> {
                unsafe { (*GPIOB::ptr()).bsrr.write(|w| w.bs4().set()) }
                Ok(())
            }
            fn set_low(&mut self) -> Result<(), Self::Error> {
                unsafe { (*GPIOB::ptr()).bsrr.write(|w| w.br4().reset()) }
                Ok(())
            }
        }
        #[cfg(feature = "unproven")]
        impl<MODE> InputPin for PB4<Input<MODE>> {
            type Error = Infallible;
            fn is_high(&self) -> Result<bool, Self::Error> {
                Ok(!self.is_low()?)
            }
            fn is_low(&self) -> Result<bool, Self::Error> {
                Ok(unsafe { (*GPIOB::ptr()).idr.read().idr4().is_low() })
            }
        }
        #[cfg(feature = "unproven")]
        impl InputPin for PB4<Output<OpenDrain>> {
            type Error = Infallible;
            fn is_high(&self) -> Result<bool, Self::Error> {
                Ok(!self.is_low()?)
            }
            fn is_low(&self) -> Result<bool, Self::Error> {
                Ok(unsafe { (*GPIOB::ptr()).idr.read().idr4().is_low() })
            }
        }
        #[cfg(feature = "unproven")]
        impl<MODE> StatefulOutputPin for PB4<Output<MODE>> {
            fn is_set_high(&self) -> Result<bool, Self::Error> {
                self.is_set_low().map(|b| !b)
            }
            fn is_set_low(&self) -> Result<bool, Self::Error> {
                Ok(unsafe { (*GPIOB::ptr()).odr.read().odr4().is_low() })
            }
        }
        #[cfg(feature = "unproven")]
        impl<MODE> toggleable::Default for PB4<Output<MODE>> {}
        #[doc = "Pin `PB5`"]
        pub struct PB5<MODE> {
            _mode: PhantomData<MODE>,
        }
        impl<MODE> PB5<MODE> {
            #[doc = "Configures `PB5` to serve as alternate function: `AF1`"]
            pub fn into_af1(self, moder: &mut MODER, afr: &mut AFRL) -> PB5<AF1> {
                moder.moder().modify(|_, w| w.moder5().alternate());
                afr.afr().modify(|_, w| w.afrl5().af1());
                PB5 { _mode: PhantomData }
            }
            #[doc = "Configures `PB5` to serve as alternate function: `AF2`"]
            pub fn into_af2(self, moder: &mut MODER, afr: &mut AFRL) -> PB5<AF2> {
                moder.moder().modify(|_, w| w.moder5().alternate());
                afr.afr().modify(|_, w| w.afrl5().af2());
                PB5 { _mode: PhantomData }
            }
            #[doc = "Configures `PB5` to serve as alternate function: `AF3`"]
            pub fn into_af3(self, moder: &mut MODER, afr: &mut AFRL) -> PB5<AF3> {
                moder.moder().modify(|_, w| w.moder5().alternate());
                afr.afr().modify(|_, w| w.afrl5().af3());
                PB5 { _mode: PhantomData }
            }
            #[doc = "Configures `PB5` to serve as alternate function: `AF4`"]
            pub fn into_af4(self, moder: &mut MODER, afr: &mut AFRL) -> PB5<AF4> {
                moder.moder().modify(|_, w| w.moder5().alternate());
                afr.afr().modify(|_, w| w.afrl5().af4());
                PB5 { _mode: PhantomData }
            }
            #[doc = "Configures `PB5` to serve as alternate function: `AF5`"]
            pub fn into_af5(self, moder: &mut MODER, afr: &mut AFRL) -> PB5<AF5> {
                moder.moder().modify(|_, w| w.moder5().alternate());
                afr.afr().modify(|_, w| w.afrl5().af5());
                PB5 { _mode: PhantomData }
            }
            #[doc = "Configures `PB5` to serve as alternate function: `AF6`"]
            pub fn into_af6(self, moder: &mut MODER, afr: &mut AFRL) -> PB5<AF6> {
                moder.moder().modify(|_, w| w.moder5().alternate());
                afr.afr().modify(|_, w| w.afrl5().af6());
                PB5 { _mode: PhantomData }
            }
            #[doc = "Configures `PB5` to serve as alternate function: `AF7`"]
            pub fn into_af7(self, moder: &mut MODER, afr: &mut AFRL) -> PB5<AF7> {
                moder.moder().modify(|_, w| w.moder5().alternate());
                afr.afr().modify(|_, w| w.afrl5().af7());
                PB5 { _mode: PhantomData }
            }
            #[doc = "Configures `PB5` to serve as alternate function: `AF10`"]
            pub fn into_af10(self, moder: &mut MODER, afr: &mut AFRL) -> PB5<AF10> {
                moder.moder().modify(|_, w| w.moder5().alternate());
                afr.afr().modify(|_, w| w.afrl5().af10());
                PB5 { _mode: PhantomData }
            }
            #[doc = "Configures `PB5` to serve as alternate function: `AF15`"]
            pub fn into_af15(self, moder: &mut MODER, afr: &mut AFRL) -> PB5<AF15> {
                moder.moder().modify(|_, w| w.moder5().alternate());
                afr.afr().modify(|_, w| w.afrl5().af15());
                PB5 { _mode: PhantomData }
            }
            #[doc = " Configures the pin to operate as a floating input pin"]
            pub fn into_floating_input(
                self,
                moder: &mut MODER,
                pupdr: &mut PUPDR,
            ) -> PB5<Input<Floating>> {
                moder.moder().modify(|_, w| w.moder5().input());
                pupdr.pupdr().modify(|_, w| w.pupdr5().floating());
                PB5 { _mode: PhantomData }
            }
            #[doc = " Configures the pin to operate as a pulled down input pin"]
            pub fn into_pull_down_input(
                self,
                moder: &mut MODER,
                pupdr: &mut PUPDR,
            ) -> PB5<Input<PullDown>> {
                moder.moder().modify(|_, w| w.moder5().input());
                pupdr.pupdr().modify(|_, w| w.pupdr5().pull_down());
                PB5 { _mode: PhantomData }
            }
            #[doc = " Configures the pin to operate as a pulled up input pin"]
            pub fn into_pull_up_input(
                self,
                moder: &mut MODER,
                pupdr: &mut PUPDR,
            ) -> PB5<Input<PullUp>> {
                moder.moder().modify(|_, w| w.moder5().input());
                pupdr.pupdr().modify(|_, w| w.pupdr5().pull_up());
                PB5 { _mode: PhantomData }
            }
            #[doc = " Configures the pin to operate as an open drain output pin"]
            pub fn into_open_drain_output(
                self,
                moder: &mut MODER,
                otyper: &mut OTYPER,
            ) -> PB5<Output<OpenDrain>> {
                moder.moder().modify(|_, w| w.moder5().output());
                otyper.otyper().modify(|_, w| w.ot5().open_drain());
                PB5 { _mode: PhantomData }
            }
            #[doc = " Configures the pin to operate as an push pull output pin"]
            pub fn into_push_pull_output(
                self,
                moder: &mut MODER,
                otyper: &mut OTYPER,
            ) -> PB5<Output<PushPull>> {
                moder.moder().modify(|_, w| w.moder5().output());
                otyper.otyper().modify(|_, w| w.ot5().push_pull());
                PB5 { _mode: PhantomData }
            }
            #[doc = " Configures the pin to operate as analog, with disabled schmitt trigger."]
            #[doc = " This mode is suitable when the pin is connected to the DAC or ADC."]
            pub fn into_analog(self, moder: &mut MODER, pupdr: &mut PUPDR) -> PB5<Analog> {
                moder.moder().modify(|_, w| w.moder5().analog());
                pupdr.pupdr().modify(|_, w| w.pupdr5().floating());
                PB5 { _mode: PhantomData }
            }
        }
        impl PB5<Output<OpenDrain>> {
            #[doc = " Enables / disables the internal pull up"]
            pub fn internal_pull_up(&mut self, pupdr: &mut PUPDR, on: bool) {
                pupdr.pupdr().modify(|_, w| {
                    if on {
                        w.pupdr5().pull_up()
                    } else {
                        w.pupdr5().floating()
                    }
                });
            }
        }
        impl<MODE> PB5<Output<MODE>> {
            #[doc = " Erases the pin number from the type"]
            #[doc = ""]
            #[doc = " This is useful when you want to collect the pins into an array where you"]
            #[doc = " need all the elements to have the same type"]
            pub fn downgrade(self) -> PBx<Output<MODE>> {
                PBx {
                    i: 5,
                    _mode: self._mode,
                }
            }
        }
        impl<MODE> PB5<Input<MODE>> {
            #[doc = " Erases the pin number from the type"]
            #[doc = ""]
            #[doc = " This is useful when you want to collect the pins into an array where you"]
            #[doc = " need all the elements to have the same type"]
            pub fn downgrade(self) -> PBx<Input<MODE>> {
                PBx {
                    i: 5,
                    _mode: self._mode,
                }
            }
        }
        impl<MODE> OutputPin for PB5<Output<MODE>> {
            type Error = Infallible;
            fn set_high(&mut self) -> Result<(), Self::Error> {
                unsafe { (*GPIOB::ptr()).bsrr.write(|w| w.bs5().set()) }
                Ok(())
            }
            fn set_low(&mut self) -> Result<(), Self::Error> {
                unsafe { (*GPIOB::ptr()).bsrr.write(|w| w.br5().reset()) }
                Ok(())
            }
        }
        #[cfg(feature = "unproven")]
        impl<MODE> InputPin for PB5<Input<MODE>> {
            type Error = Infallible;
            fn is_high(&self) -> Result<bool, Self::Error> {
                Ok(!self.is_low()?)
            }
            fn is_low(&self) -> Result<bool, Self::Error> {
                Ok(unsafe { (*GPIOB::ptr()).idr.read().idr5().is_low() })
            }
        }
        #[cfg(feature = "unproven")]
        impl InputPin for PB5<Output<OpenDrain>> {
            type Error = Infallible;
            fn is_high(&self) -> Result<bool, Self::Error> {
                Ok(!self.is_low()?)
            }
            fn is_low(&self) -> Result<bool, Self::Error> {
                Ok(unsafe { (*GPIOB::ptr()).idr.read().idr5().is_low() })
            }
        }
        #[cfg(feature = "unproven")]
        impl<MODE> StatefulOutputPin for PB5<Output<MODE>> {
            fn is_set_high(&self) -> Result<bool, Self::Error> {
                self.is_set_low().map(|b| !b)
            }
            fn is_set_low(&self) -> Result<bool, Self::Error> {
                Ok(unsafe { (*GPIOB::ptr()).odr.read().odr5().is_low() })
            }
        }
        #[cfg(feature = "unproven")]
        impl<MODE> toggleable::Default for PB5<Output<MODE>> {}
        #[doc = "Pin `PB6`"]
        pub struct PB6<MODE> {
            _mode: PhantomData<MODE>,
        }
        impl<MODE> PB6<MODE> {
            #[doc = "Configures `PB6` to serve as alternate function: `AF1`"]
            pub fn into_af1(self, moder: &mut MODER, afr: &mut AFRL) -> PB6<AF1> {
                moder.moder().modify(|_, w| w.moder6().alternate());
                afr.afr().modify(|_, w| w.afrl6().af1());
                PB6 { _mode: PhantomData }
            }
            #[doc = "Configures `PB6` to serve as alternate function: `AF2`"]
            pub fn into_af2(self, moder: &mut MODER, afr: &mut AFRL) -> PB6<AF2> {
                moder.moder().modify(|_, w| w.moder6().alternate());
                afr.afr().modify(|_, w| w.afrl6().af2());
                PB6 { _mode: PhantomData }
            }
            #[doc = "Configures `PB6` to serve as alternate function: `AF3`"]
            pub fn into_af3(self, moder: &mut MODER, afr: &mut AFRL) -> PB6<AF3> {
                moder.moder().modify(|_, w| w.moder6().alternate());
                afr.afr().modify(|_, w| w.afrl6().af3());
                PB6 { _mode: PhantomData }
            }
            #[doc = "Configures `PB6` to serve as alternate function: `AF4`"]
            pub fn into_af4(self, moder: &mut MODER, afr: &mut AFRL) -> PB6<AF4> {
                moder.moder().modify(|_, w| w.moder6().alternate());
                afr.afr().modify(|_, w| w.afrl6().af4());
                PB6 { _mode: PhantomData }
            }
            #[doc = "Configures `PB6` to serve as alternate function: `AF5`"]
            pub fn into_af5(self, moder: &mut MODER, afr: &mut AFRL) -> PB6<AF5> {
                moder.moder().modify(|_, w| w.moder6().alternate());
                afr.afr().modify(|_, w| w.afrl6().af5());
                PB6 { _mode: PhantomData }
            }
            #[doc = "Configures `PB6` to serve as alternate function: `AF6`"]
            pub fn into_af6(self, moder: &mut MODER, afr: &mut AFRL) -> PB6<AF6> {
                moder.moder().modify(|_, w| w.moder6().alternate());
                afr.afr().modify(|_, w| w.afrl6().af6());
                PB6 { _mode: PhantomData }
            }
            #[doc = "Configures `PB6` to serve as alternate function: `AF7`"]
            pub fn into_af7(self, moder: &mut MODER, afr: &mut AFRL) -> PB6<AF7> {
                moder.moder().modify(|_, w| w.moder6().alternate());
                afr.afr().modify(|_, w| w.afrl6().af7());
                PB6 { _mode: PhantomData }
            }
            #[doc = "Configures `PB6` to serve as alternate function: `AF10`"]
            pub fn into_af10(self, moder: &mut MODER, afr: &mut AFRL) -> PB6<AF10> {
                moder.moder().modify(|_, w| w.moder6().alternate());
                afr.afr().modify(|_, w| w.afrl6().af10());
                PB6 { _mode: PhantomData }
            }
            #[doc = "Configures `PB6` to serve as alternate function: `AF15`"]
            pub fn into_af15(self, moder: &mut MODER, afr: &mut AFRL) -> PB6<AF15> {
                moder.moder().modify(|_, w| w.moder6().alternate());
                afr.afr().modify(|_, w| w.afrl6().af15());
                PB6 { _mode: PhantomData }
            }
            #[doc = " Configures the pin to operate as a floating input pin"]
            pub fn into_floating_input(
                self,
                moder: &mut MODER,
                pupdr: &mut PUPDR,
            ) -> PB6<Input<Floating>> {
                moder.moder().modify(|_, w| w.moder6().input());
                pupdr.pupdr().modify(|_, w| w.pupdr6().floating());
                PB6 { _mode: PhantomData }
            }
            #[doc = " Configures the pin to operate as a pulled down input pin"]
            pub fn into_pull_down_input(
                self,
                moder: &mut MODER,
                pupdr: &mut PUPDR,
            ) -> PB6<Input<PullDown>> {
                moder.moder().modify(|_, w| w.moder6().input());
                pupdr.pupdr().modify(|_, w| w.pupdr6().pull_down());
                PB6 { _mode: PhantomData }
            }
            #[doc = " Configures the pin to operate as a pulled up input pin"]
            pub fn into_pull_up_input(
                self,
                moder: &mut MODER,
                pupdr: &mut PUPDR,
            ) -> PB6<Input<PullUp>> {
                moder.moder().modify(|_, w| w.moder6().input());
                pupdr.pupdr().modify(|_, w| w.pupdr6().pull_up());
                PB6 { _mode: PhantomData }
            }
            #[doc = " Configures the pin to operate as an open drain output pin"]
            pub fn into_open_drain_output(
                self,
                moder: &mut MODER,
                otyper: &mut OTYPER,
            ) -> PB6<Output<OpenDrain>> {
                moder.moder().modify(|_, w| w.moder6().output());
                otyper.otyper().modify(|_, w| w.ot6().open_drain());
                PB6 { _mode: PhantomData }
            }
            #[doc = " Configures the pin to operate as an push pull output pin"]
            pub fn into_push_pull_output(
                self,
                moder: &mut MODER,
                otyper: &mut OTYPER,
            ) -> PB6<Output<PushPull>> {
                moder.moder().modify(|_, w| w.moder6().output());
                otyper.otyper().modify(|_, w| w.ot6().push_pull());
                PB6 { _mode: PhantomData }
            }
            #[doc = " Configures the pin to operate as analog, with disabled schmitt trigger."]
            #[doc = " This mode is suitable when the pin is connected to the DAC or ADC."]
            pub fn into_analog(self, moder: &mut MODER, pupdr: &mut PUPDR) -> PB6<Analog> {
                moder.moder().modify(|_, w| w.moder6().analog());
                pupdr.pupdr().modify(|_, w| w.pupdr6().floating());
                PB6 { _mode: PhantomData }
            }
        }
        impl PB6<Output<OpenDrain>> {
            #[doc = " Enables / disables the internal pull up"]
            pub fn internal_pull_up(&mut self, pupdr: &mut PUPDR, on: bool) {
                pupdr.pupdr().modify(|_, w| {
                    if on {
                        w.pupdr6().pull_up()
                    } else {
                        w.pupdr6().floating()
                    }
                });
            }
        }
        impl<MODE> PB6<Output<MODE>> {
            #[doc = " Erases the pin number from the type"]
            #[doc = ""]
            #[doc = " This is useful when you want to collect the pins into an array where you"]
            #[doc = " need all the elements to have the same type"]
            pub fn downgrade(self) -> PBx<Output<MODE>> {
                PBx {
                    i: 6,
                    _mode: self._mode,
                }
            }
        }
        impl<MODE> PB6<Input<MODE>> {
            #[doc = " Erases the pin number from the type"]
            #[doc = ""]
            #[doc = " This is useful when you want to collect the pins into an array where you"]
            #[doc = " need all the elements to have the same type"]
            pub fn downgrade(self) -> PBx<Input<MODE>> {
                PBx {
                    i: 6,
                    _mode: self._mode,
                }
            }
        }
        impl<MODE> OutputPin for PB6<Output<MODE>> {
            type Error = Infallible;
            fn set_high(&mut self) -> Result<(), Self::Error> {
                unsafe { (*GPIOB::ptr()).bsrr.write(|w| w.bs6().set()) }
                Ok(())
            }
            fn set_low(&mut self) -> Result<(), Self::Error> {
                unsafe { (*GPIOB::ptr()).bsrr.write(|w| w.br6().reset()) }
                Ok(())
            }
        }
        #[cfg(feature = "unproven")]
        impl<MODE> InputPin for PB6<Input<MODE>> {
            type Error = Infallible;
            fn is_high(&self) -> Result<bool, Self::Error> {
                Ok(!self.is_low()?)
            }
            fn is_low(&self) -> Result<bool, Self::Error> {
                Ok(unsafe { (*GPIOB::ptr()).idr.read().idr6().is_low() })
            }
        }
        #[cfg(feature = "unproven")]
        impl InputPin for PB6<Output<OpenDrain>> {
            type Error = Infallible;
            fn is_high(&self) -> Result<bool, Self::Error> {
                Ok(!self.is_low()?)
            }
            fn is_low(&self) -> Result<bool, Self::Error> {
                Ok(unsafe { (*GPIOB::ptr()).idr.read().idr6().is_low() })
            }
        }
        #[cfg(feature = "unproven")]
        impl<MODE> StatefulOutputPin for PB6<Output<MODE>> {
            fn is_set_high(&self) -> Result<bool, Self::Error> {
                self.is_set_low().map(|b| !b)
            }
            fn is_set_low(&self) -> Result<bool, Self::Error> {
                Ok(unsafe { (*GPIOB::ptr()).odr.read().odr6().is_low() })
            }
        }
        #[cfg(feature = "unproven")]
        impl<MODE> toggleable::Default for PB6<Output<MODE>> {}
        #[doc = "Pin `PB7`"]
        pub struct PB7<MODE> {
            _mode: PhantomData<MODE>,
        }
        impl<MODE> PB7<MODE> {
            #[doc = "Configures `PB7` to serve as alternate function: `AF1`"]
            pub fn into_af1(self, moder: &mut MODER, afr: &mut AFRL) -> PB7<AF1> {
                moder.moder().modify(|_, w| w.moder7().alternate());
                afr.afr().modify(|_, w| w.afrl7().af1());
                PB7 { _mode: PhantomData }
            }
            #[doc = "Configures `PB7` to serve as alternate function: `AF2`"]
            pub fn into_af2(self, moder: &mut MODER, afr: &mut AFRL) -> PB7<AF2> {
                moder.moder().modify(|_, w| w.moder7().alternate());
                afr.afr().modify(|_, w| w.afrl7().af2());
                PB7 { _mode: PhantomData }
            }
            #[doc = "Configures `PB7` to serve as alternate function: `AF3`"]
            pub fn into_af3(self, moder: &mut MODER, afr: &mut AFRL) -> PB7<AF3> {
                moder.moder().modify(|_, w| w.moder7().alternate());
                afr.afr().modify(|_, w| w.afrl7().af3());
                PB7 { _mode: PhantomData }
            }
            #[doc = "Configures `PB7` to serve as alternate function: `AF4`"]
            pub fn into_af4(self, moder: &mut MODER, afr: &mut AFRL) -> PB7<AF4> {
                moder.moder().modify(|_, w| w.moder7().alternate());
                afr.afr().modify(|_, w| w.afrl7().af4());
                PB7 { _mode: PhantomData }
            }
            #[doc = "Configures `PB7` to serve as alternate function: `AF5`"]
            pub fn into_af5(self, moder: &mut MODER, afr: &mut AFRL) -> PB7<AF5> {
                moder.moder().modify(|_, w| w.moder7().alternate());
                afr.afr().modify(|_, w| w.afrl7().af5());
                PB7 { _mode: PhantomData }
            }
            #[doc = "Configures `PB7` to serve as alternate function: `AF7`"]
            pub fn into_af7(self, moder: &mut MODER, afr: &mut AFRL) -> PB7<AF7> {
                moder.moder().modify(|_, w| w.moder7().alternate());
                afr.afr().modify(|_, w| w.afrl7().af7());
                PB7 { _mode: PhantomData }
            }
            #[doc = "Configures `PB7` to serve as alternate function: `AF10`"]
            pub fn into_af10(self, moder: &mut MODER, afr: &mut AFRL) -> PB7<AF10> {
                moder.moder().modify(|_, w| w.moder7().alternate());
                afr.afr().modify(|_, w| w.afrl7().af10());
                PB7 { _mode: PhantomData }
            }
            #[doc = "Configures `PB7` to serve as alternate function: `AF15`"]
            pub fn into_af15(self, moder: &mut MODER, afr: &mut AFRL) -> PB7<AF15> {
                moder.moder().modify(|_, w| w.moder7().alternate());
                afr.afr().modify(|_, w| w.afrl7().af15());
                PB7 { _mode: PhantomData }
            }
            #[doc = " Configures the pin to operate as a floating input pin"]
            pub fn into_floating_input(
                self,
                moder: &mut MODER,
                pupdr: &mut PUPDR,
            ) -> PB7<Input<Floating>> {
                moder.moder().modify(|_, w| w.moder7().input());
                pupdr.pupdr().modify(|_, w| w.pupdr7().floating());
                PB7 { _mode: PhantomData }
            }
            #[doc = " Configures the pin to operate as a pulled down input pin"]
            pub fn into_pull_down_input(
                self,
                moder: &mut MODER,
                pupdr: &mut PUPDR,
            ) -> PB7<Input<PullDown>> {
                moder.moder().modify(|_, w| w.moder7().input());
                pupdr.pupdr().modify(|_, w| w.pupdr7().pull_down());
                PB7 { _mode: PhantomData }
            }
            #[doc = " Configures the pin to operate as a pulled up input pin"]
            pub fn into_pull_up_input(
                self,
                moder: &mut MODER,
                pupdr: &mut PUPDR,
            ) -> PB7<Input<PullUp>> {
                moder.moder().modify(|_, w| w.moder7().input());
                pupdr.pupdr().modify(|_, w| w.pupdr7().pull_up());
                PB7 { _mode: PhantomData }
            }
            #[doc = " Configures the pin to operate as an open drain output pin"]
            pub fn into_open_drain_output(
                self,
                moder: &mut MODER,
                otyper: &mut OTYPER,
            ) -> PB7<Output<OpenDrain>> {
                moder.moder().modify(|_, w| w.moder7().output());
                otyper.otyper().modify(|_, w| w.ot7().open_drain());
                PB7 { _mode: PhantomData }
            }
            #[doc = " Configures the pin to operate as an push pull output pin"]
            pub fn into_push_pull_output(
                self,
                moder: &mut MODER,
                otyper: &mut OTYPER,
            ) -> PB7<Output<PushPull>> {
                moder.moder().modify(|_, w| w.moder7().output());
                otyper.otyper().modify(|_, w| w.ot7().push_pull());
                PB7 { _mode: PhantomData }
            }
            #[doc = " Configures the pin to operate as analog, with disabled schmitt trigger."]
            #[doc = " This mode is suitable when the pin is connected to the DAC or ADC."]
            pub fn into_analog(self, moder: &mut MODER, pupdr: &mut PUPDR) -> PB7<Analog> {
                moder.moder().modify(|_, w| w.moder7().analog());
                pupdr.pupdr().modify(|_, w| w.pupdr7().floating());
                PB7 { _mode: PhantomData }
            }
        }
        impl PB7<Output<OpenDrain>> {
            #[doc = " Enables / disables the internal pull up"]
            pub fn internal_pull_up(&mut self, pupdr: &mut PUPDR, on: bool) {
                pupdr.pupdr().modify(|_, w| {
                    if on {
                        w.pupdr7().pull_up()
                    } else {
                        w.pupdr7().floating()
                    }
                });
            }
        }
        impl<MODE> PB7<Output<MODE>> {
            #[doc = " Erases the pin number from the type"]
            #[doc = ""]
            #[doc = " This is useful when you want to collect the pins into an array where you"]
            #[doc = " need all the elements to have the same type"]
            pub fn downgrade(self) -> PBx<Output<MODE>> {
                PBx {
                    i: 7,
                    _mode: self._mode,
                }
            }
        }
        impl<MODE> PB7<Input<MODE>> {
            #[doc = " Erases the pin number from the type"]
            #[doc = ""]
            #[doc = " This is useful when you want to collect the pins into an array where you"]
            #[doc = " need all the elements to have the same type"]
            pub fn downgrade(self) -> PBx<Input<MODE>> {
                PBx {
                    i: 7,
                    _mode: self._mode,
                }
            }
        }
        impl<MODE> OutputPin for PB7<Output<MODE>> {
            type Error = Infallible;
            fn set_high(&mut self) -> Result<(), Self::Error> {
                unsafe { (*GPIOB::ptr()).bsrr.write(|w| w.bs7().set()) }
                Ok(())
            }
            fn set_low(&mut self) -> Result<(), Self::Error> {
                unsafe { (*GPIOB::ptr()).bsrr.write(|w| w.br7().reset()) }
                Ok(())
            }
        }
        #[cfg(feature = "unproven")]
        impl<MODE> InputPin for PB7<Input<MODE>> {
            type Error = Infallible;
            fn is_high(&self) -> Result<bool, Self::Error> {
                Ok(!self.is_low()?)
            }
            fn is_low(&self) -> Result<bool, Self::Error> {
                Ok(unsafe { (*GPIOB::ptr()).idr.read().idr7().is_low() })
            }
        }
        #[cfg(feature = "unproven")]
        impl InputPin for PB7<Output<OpenDrain>> {
            type Error = Infallible;
            fn is_high(&self) -> Result<bool, Self::Error> {
                Ok(!self.is_low()?)
            }
            fn is_low(&self) -> Result<bool, Self::Error> {
                Ok(unsafe { (*GPIOB::ptr()).idr.read().idr7().is_low() })
            }
        }
        #[cfg(feature = "unproven")]
        impl<MODE> StatefulOutputPin for PB7<Output<MODE>> {
            fn is_set_high(&self) -> Result<bool, Self::Error> {
                self.is_set_low().map(|b| !b)
            }
            fn is_set_low(&self) -> Result<bool, Self::Error> {
                Ok(unsafe { (*GPIOB::ptr()).odr.read().odr7().is_low() })
            }
        }
        #[cfg(feature = "unproven")]
        impl<MODE> toggleable::Default for PB7<Output<MODE>> {}
        #[doc = "Pin `PB8`"]
        pub struct PB8<MODE> {
            _mode: PhantomData<MODE>,
        }
        impl<MODE> PB8<MODE> {
            #[doc = "Configures `PB8` to serve as alternate function: `AF1`"]
            pub fn into_af1(self, moder: &mut MODER, afr: &mut AFRH) -> PB8<AF1> {
                moder.moder().modify(|_, w| w.moder8().alternate());
                afr.afr().modify(|_, w| w.afrh8().af1());
                PB8 { _mode: PhantomData }
            }
            #[doc = "Configures `PB8` to serve as alternate function: `AF2`"]
            pub fn into_af2(self, moder: &mut MODER, afr: &mut AFRH) -> PB8<AF2> {
                moder.moder().modify(|_, w| w.moder8().alternate());
                afr.afr().modify(|_, w| w.afrh8().af2());
                PB8 { _mode: PhantomData }
            }
            #[doc = "Configures `PB8` to serve as alternate function: `AF3`"]
            pub fn into_af3(self, moder: &mut MODER, afr: &mut AFRH) -> PB8<AF3> {
                moder.moder().modify(|_, w| w.moder8().alternate());
                afr.afr().modify(|_, w| w.afrh8().af3());
                PB8 { _mode: PhantomData }
            }
            #[doc = "Configures `PB8` to serve as alternate function: `AF4`"]
            pub fn into_af4(self, moder: &mut MODER, afr: &mut AFRH) -> PB8<AF4> {
                moder.moder().modify(|_, w| w.moder8().alternate());
                afr.afr().modify(|_, w| w.afrh8().af4());
                PB8 { _mode: PhantomData }
            }
            #[doc = "Configures `PB8` to serve as alternate function: `AF8`"]
            pub fn into_af8(self, moder: &mut MODER, afr: &mut AFRH) -> PB8<AF8> {
                moder.moder().modify(|_, w| w.moder8().alternate());
                afr.afr().modify(|_, w| w.afrh8().af8());
                PB8 { _mode: PhantomData }
            }
            #[doc = "Configures `PB8` to serve as alternate function: `AF9`"]
            pub fn into_af9(self, moder: &mut MODER, afr: &mut AFRH) -> PB8<AF9> {
                moder.moder().modify(|_, w| w.moder8().alternate());
                afr.afr().modify(|_, w| w.afrh8().af9());
                PB8 { _mode: PhantomData }
            }
            #[doc = "Configures `PB8` to serve as alternate function: `AF10`"]
            pub fn into_af10(self, moder: &mut MODER, afr: &mut AFRH) -> PB8<AF10> {
                moder.moder().modify(|_, w| w.moder8().alternate());
                afr.afr().modify(|_, w| w.afrh8().af10());
                PB8 { _mode: PhantomData }
            }
            #[doc = "Configures `PB8` to serve as alternate function: `AF12`"]
            pub fn into_af12(self, moder: &mut MODER, afr: &mut AFRH) -> PB8<AF12> {
                moder.moder().modify(|_, w| w.moder8().alternate());
                afr.afr().modify(|_, w| w.afrh8().af12());
                PB8 { _mode: PhantomData }
            }
            #[doc = "Configures `PB8` to serve as alternate function: `AF15`"]
            pub fn into_af15(self, moder: &mut MODER, afr: &mut AFRH) -> PB8<AF15> {
                moder.moder().modify(|_, w| w.moder8().alternate());
                afr.afr().modify(|_, w| w.afrh8().af15());
                PB8 { _mode: PhantomData }
            }
            #[doc = " Configures the pin to operate as a floating input pin"]
            pub fn into_floating_input(
                self,
                moder: &mut MODER,
                pupdr: &mut PUPDR,
            ) -> PB8<Input<Floating>> {
                moder.moder().modify(|_, w| w.moder8().input());
                pupdr.pupdr().modify(|_, w| w.pupdr8().floating());
                PB8 { _mode: PhantomData }
            }
            #[doc = " Configures the pin to operate as a pulled down input pin"]
            pub fn into_pull_down_input(
                self,
                moder: &mut MODER,
                pupdr: &mut PUPDR,
            ) -> PB8<Input<PullDown>> {
                moder.moder().modify(|_, w| w.moder8().input());
                pupdr.pupdr().modify(|_, w| w.pupdr8().pull_down());
                PB8 { _mode: PhantomData }
            }
            #[doc = " Configures the pin to operate as a pulled up input pin"]
            pub fn into_pull_up_input(
                self,
                moder: &mut MODER,
                pupdr: &mut PUPDR,
            ) -> PB8<Input<PullUp>> {
                moder.moder().modify(|_, w| w.moder8().input());
                pupdr.pupdr().modify(|_, w| w.pupdr8().pull_up());
                PB8 { _mode: PhantomData }
            }
            #[doc = " Configures the pin to operate as an open drain output pin"]
            pub fn into_open_drain_output(
                self,
                moder: &mut MODER,
                otyper: &mut OTYPER,
            ) -> PB8<Output<OpenDrain>> {
                moder.moder().modify(|_, w| w.moder8().output());
                otyper.otyper().modify(|_, w| w.ot8().open_drain());
                PB8 { _mode: PhantomData }
            }
            #[doc = " Configures the pin to operate as an push pull output pin"]
            pub fn into_push_pull_output(
                self,
                moder: &mut MODER,
                otyper: &mut OTYPER,
            ) -> PB8<Output<PushPull>> {
                moder.moder().modify(|_, w| w.moder8().output());
                otyper.otyper().modify(|_, w| w.ot8().push_pull());
                PB8 { _mode: PhantomData }
            }
            #[doc = " Configures the pin to operate as analog, with disabled schmitt trigger."]
            #[doc = " This mode is suitable when the pin is connected to the DAC or ADC."]
            pub fn into_analog(self, moder: &mut MODER, pupdr: &mut PUPDR) -> PB8<Analog> {
                moder.moder().modify(|_, w| w.moder8().analog());
                pupdr.pupdr().modify(|_, w| w.pupdr8().floating());
                PB8 { _mode: PhantomData }
            }
        }
        impl PB8<Output<OpenDrain>> {
            #[doc = " Enables / disables the internal pull up"]
            pub fn internal_pull_up(&mut self, pupdr: &mut PUPDR, on: bool) {
                pupdr.pupdr().modify(|_, w| {
                    if on {
                        w.pupdr8().pull_up()
                    } else {
                        w.pupdr8().floating()
                    }
                });
            }
        }
        impl<MODE> PB8<Output<MODE>> {
            #[doc = " Erases the pin number from the type"]
            #[doc = ""]
            #[doc = " This is useful when you want to collect the pins into an array where you"]
            #[doc = " need all the elements to have the same type"]
            pub fn downgrade(self) -> PBx<Output<MODE>> {
                PBx {
                    i: 8,
                    _mode: self._mode,
                }
            }
        }
        impl<MODE> PB8<Input<MODE>> {
            #[doc = " Erases the pin number from the type"]
            #[doc = ""]
            #[doc = " This is useful when you want to collect the pins into an array where you"]
            #[doc = " need all the elements to have the same type"]
            pub fn downgrade(self) -> PBx<Input<MODE>> {
                PBx {
                    i: 8,
                    _mode: self._mode,
                }
            }
        }
        impl<MODE> OutputPin for PB8<Output<MODE>> {
            type Error = Infallible;
            fn set_high(&mut self) -> Result<(), Self::Error> {
                unsafe { (*GPIOB::ptr()).bsrr.write(|w| w.bs8().set()) }
                Ok(())
            }
            fn set_low(&mut self) -> Result<(), Self::Error> {
                unsafe { (*GPIOB::ptr()).bsrr.write(|w| w.br8().reset()) }
                Ok(())
            }
        }
        #[cfg(feature = "unproven")]
        impl<MODE> InputPin for PB8<Input<MODE>> {
            type Error = Infallible;
            fn is_high(&self) -> Result<bool, Self::Error> {
                Ok(!self.is_low()?)
            }
            fn is_low(&self) -> Result<bool, Self::Error> {
                Ok(unsafe { (*GPIOB::ptr()).idr.read().idr8().is_low() })
            }
        }
        #[cfg(feature = "unproven")]
        impl InputPin for PB8<Output<OpenDrain>> {
            type Error = Infallible;
            fn is_high(&self) -> Result<bool, Self::Error> {
                Ok(!self.is_low()?)
            }
            fn is_low(&self) -> Result<bool, Self::Error> {
                Ok(unsafe { (*GPIOB::ptr()).idr.read().idr8().is_low() })
            }
        }
        #[cfg(feature = "unproven")]
        impl<MODE> StatefulOutputPin for PB8<Output<MODE>> {
            fn is_set_high(&self) -> Result<bool, Self::Error> {
                self.is_set_low().map(|b| !b)
            }
            fn is_set_low(&self) -> Result<bool, Self::Error> {
                Ok(unsafe { (*GPIOB::ptr()).odr.read().odr8().is_low() })
            }
        }
        #[cfg(feature = "unproven")]
        impl<MODE> toggleable::Default for PB8<Output<MODE>> {}
        #[doc = "Pin `PB9`"]
        pub struct PB9<MODE> {
            _mode: PhantomData<MODE>,
        }
        impl<MODE> PB9<MODE> {
            #[doc = "Configures `PB9` to serve as alternate function: `AF1`"]
            pub fn into_af1(self, moder: &mut MODER, afr: &mut AFRH) -> PB9<AF1> {
                moder.moder().modify(|_, w| w.moder9().alternate());
                afr.afr().modify(|_, w| w.afrh9().af1());
                PB9 { _mode: PhantomData }
            }
            #[doc = "Configures `PB9` to serve as alternate function: `AF2`"]
            pub fn into_af2(self, moder: &mut MODER, afr: &mut AFRH) -> PB9<AF2> {
                moder.moder().modify(|_, w| w.moder9().alternate());
                afr.afr().modify(|_, w| w.afrh9().af2());
                PB9 { _mode: PhantomData }
            }
            #[doc = "Configures `PB9` to serve as alternate function: `AF4`"]
            pub fn into_af4(self, moder: &mut MODER, afr: &mut AFRH) -> PB9<AF4> {
                moder.moder().modify(|_, w| w.moder9().alternate());
                afr.afr().modify(|_, w| w.afrh9().af4());
                PB9 { _mode: PhantomData }
            }
            #[doc = "Configures `PB9` to serve as alternate function: `AF6`"]
            pub fn into_af6(self, moder: &mut MODER, afr: &mut AFRH) -> PB9<AF6> {
                moder.moder().modify(|_, w| w.moder9().alternate());
                afr.afr().modify(|_, w| w.afrh9().af6());
                PB9 { _mode: PhantomData }
            }
            #[doc = "Configures `PB9` to serve as alternate function: `AF8`"]
            pub fn into_af8(self, moder: &mut MODER, afr: &mut AFRH) -> PB9<AF8> {
                moder.moder().modify(|_, w| w.moder9().alternate());
                afr.afr().modify(|_, w| w.afrh9().af8());
                PB9 { _mode: PhantomData }
            }
            #[doc = "Configures `PB9` to serve as alternate function: `AF9`"]
            pub fn into_af9(self, moder: &mut MODER, afr: &mut AFRH) -> PB9<AF9> {
                moder.moder().modify(|_, w| w.moder9().alternate());
                afr.afr().modify(|_, w| w.afrh9().af9());
                PB9 { _mode: PhantomData }
            }
            #[doc = "Configures `PB9` to serve as alternate function: `AF10`"]
            pub fn into_af10(self, moder: &mut MODER, afr: &mut AFRH) -> PB9<AF10> {
                moder.moder().modify(|_, w| w.moder9().alternate());
                afr.afr().modify(|_, w| w.afrh9().af10());
                PB9 { _mode: PhantomData }
            }
            #[doc = "Configures `PB9` to serve as alternate function: `AF15`"]
            pub fn into_af15(self, moder: &mut MODER, afr: &mut AFRH) -> PB9<AF15> {
                moder.moder().modify(|_, w| w.moder9().alternate());
                afr.afr().modify(|_, w| w.afrh9().af15());
                PB9 { _mode: PhantomData }
            }
            #[doc = " Configures the pin to operate as a floating input pin"]
            pub fn into_floating_input(
                self,
                moder: &mut MODER,
                pupdr: &mut PUPDR,
            ) -> PB9<Input<Floating>> {
                moder.moder().modify(|_, w| w.moder9().input());
                pupdr.pupdr().modify(|_, w| w.pupdr9().floating());
                PB9 { _mode: PhantomData }
            }
            #[doc = " Configures the pin to operate as a pulled down input pin"]
            pub fn into_pull_down_input(
                self,
                moder: &mut MODER,
                pupdr: &mut PUPDR,
            ) -> PB9<Input<PullDown>> {
                moder.moder().modify(|_, w| w.moder9().input());
                pupdr.pupdr().modify(|_, w| w.pupdr9().pull_down());
                PB9 { _mode: PhantomData }
            }
            #[doc = " Configures the pin to operate as a pulled up input pin"]
            pub fn into_pull_up_input(
                self,
                moder: &mut MODER,
                pupdr: &mut PUPDR,
            ) -> PB9<Input<PullUp>> {
                moder.moder().modify(|_, w| w.moder9().input());
                pupdr.pupdr().modify(|_, w| w.pupdr9().pull_up());
                PB9 { _mode: PhantomData }
            }
            #[doc = " Configures the pin to operate as an open drain output pin"]
            pub fn into_open_drain_output(
                self,
                moder: &mut MODER,
                otyper: &mut OTYPER,
            ) -> PB9<Output<OpenDrain>> {
                moder.moder().modify(|_, w| w.moder9().output());
                otyper.otyper().modify(|_, w| w.ot9().open_drain());
                PB9 { _mode: PhantomData }
            }
            #[doc = " Configures the pin to operate as an push pull output pin"]
            pub fn into_push_pull_output(
                self,
                moder: &mut MODER,
                otyper: &mut OTYPER,
            ) -> PB9<Output<PushPull>> {
                moder.moder().modify(|_, w| w.moder9().output());
                otyper.otyper().modify(|_, w| w.ot9().push_pull());
                PB9 { _mode: PhantomData }
            }
            #[doc = " Configures the pin to operate as analog, with disabled schmitt trigger."]
            #[doc = " This mode is suitable when the pin is connected to the DAC or ADC."]
            pub fn into_analog(self, moder: &mut MODER, pupdr: &mut PUPDR) -> PB9<Analog> {
                moder.moder().modify(|_, w| w.moder9().analog());
                pupdr.pupdr().modify(|_, w| w.pupdr9().floating());
                PB9 { _mode: PhantomData }
            }
        }
        impl PB9<Output<OpenDrain>> {
            #[doc = " Enables / disables the internal pull up"]
            pub fn internal_pull_up(&mut self, pupdr: &mut PUPDR, on: bool) {
                pupdr.pupdr().modify(|_, w| {
                    if on {
                        w.pupdr9().pull_up()
                    } else {
                        w.pupdr9().floating()
                    }
                });
            }
        }
        impl<MODE> PB9<Output<MODE>> {
            #[doc = " Erases the pin number from the type"]
            #[doc = ""]
            #[doc = " This is useful when you want to collect the pins into an array where you"]
            #[doc = " need all the elements to have the same type"]
            pub fn downgrade(self) -> PBx<Output<MODE>> {
                PBx {
                    i: 9,
                    _mode: self._mode,
                }
            }
        }
        impl<MODE> PB9<Input<MODE>> {
            #[doc = " Erases the pin number from the type"]
            #[doc = ""]
            #[doc = " This is useful when you want to collect the pins into an array where you"]
            #[doc = " need all the elements to have the same type"]
            pub fn downgrade(self) -> PBx<Input<MODE>> {
                PBx {
                    i: 9,
                    _mode: self._mode,
                }
            }
        }
        impl<MODE> OutputPin for PB9<Output<MODE>> {
            type Error = Infallible;
            fn set_high(&mut self) -> Result<(), Self::Error> {
                unsafe { (*GPIOB::ptr()).bsrr.write(|w| w.bs9().set()) }
                Ok(())
            }
            fn set_low(&mut self) -> Result<(), Self::Error> {
                unsafe { (*GPIOB::ptr()).bsrr.write(|w| w.br9().reset()) }
                Ok(())
            }
        }
        #[cfg(feature = "unproven")]
        impl<MODE> InputPin for PB9<Input<MODE>> {
            type Error = Infallible;
            fn is_high(&self) -> Result<bool, Self::Error> {
                Ok(!self.is_low()?)
            }
            fn is_low(&self) -> Result<bool, Self::Error> {
                Ok(unsafe { (*GPIOB::ptr()).idr.read().idr9().is_low() })
            }
        }
        #[cfg(feature = "unproven")]
        impl InputPin for PB9<Output<OpenDrain>> {
            type Error = Infallible;
            fn is_high(&self) -> Result<bool, Self::Error> {
                Ok(!self.is_low()?)
            }
            fn is_low(&self) -> Result<bool, Self::Error> {
                Ok(unsafe { (*GPIOB::ptr()).idr.read().idr9().is_low() })
            }
        }
        #[cfg(feature = "unproven")]
        impl<MODE> StatefulOutputPin for PB9<Output<MODE>> {
            fn is_set_high(&self) -> Result<bool, Self::Error> {
                self.is_set_low().map(|b| !b)
            }
            fn is_set_low(&self) -> Result<bool, Self::Error> {
                Ok(unsafe { (*GPIOB::ptr()).odr.read().odr9().is_low() })
            }
        }
        #[cfg(feature = "unproven")]
        impl<MODE> toggleable::Default for PB9<Output<MODE>> {}
        #[doc = "Pin `PB10`"]
        pub struct PB10<MODE> {
            _mode: PhantomData<MODE>,
        }
        impl<MODE> PB10<MODE> {
            #[doc = "Configures `PB10` to serve as alternate function: `AF1`"]
            pub fn into_af1(self, moder: &mut MODER, afr: &mut AFRH) -> PB10<AF1> {
                moder.moder().modify(|_, w| w.moder10().alternate());
                afr.afr().modify(|_, w| w.afrh10().af1());
                PB10 { _mode: PhantomData }
            }
            #[doc = "Configures `PB10` to serve as alternate function: `AF3`"]
            pub fn into_af3(self, moder: &mut MODER, afr: &mut AFRH) -> PB10<AF3> {
                moder.moder().modify(|_, w| w.moder10().alternate());
                afr.afr().modify(|_, w| w.afrh10().af3());
                PB10 { _mode: PhantomData }
            }
            #[doc = "Configures `PB10` to serve as alternate function: `AF7`"]
            pub fn into_af7(self, moder: &mut MODER, afr: &mut AFRH) -> PB10<AF7> {
                moder.moder().modify(|_, w| w.moder10().alternate());
                afr.afr().modify(|_, w| w.afrh10().af7());
                PB10 { _mode: PhantomData }
            }
            #[doc = "Configures `PB10` to serve as alternate function: `AF15`"]
            pub fn into_af15(self, moder: &mut MODER, afr: &mut AFRH) -> PB10<AF15> {
                moder.moder().modify(|_, w| w.moder10().alternate());
                afr.afr().modify(|_, w| w.afrh10().af15());
                PB10 { _mode: PhantomData }
            }
            #[doc = " Configures the pin to operate as a floating input pin"]
            pub fn into_floating_input(
                self,
                moder: &mut MODER,
                pupdr: &mut PUPDR,
            ) -> PB10<Input<Floating>> {
                moder.moder().modify(|_, w| w.moder10().input());
                pupdr.pupdr().modify(|_, w| w.pupdr10().floating());
                PB10 { _mode: PhantomData }
            }
            #[doc = " Configures the pin to operate as a pulled down input pin"]
            pub fn into_pull_down_input(
                self,
                moder: &mut MODER,
                pupdr: &mut PUPDR,
            ) -> PB10<Input<PullDown>> {
                moder.moder().modify(|_, w| w.moder10().input());
                pupdr.pupdr().modify(|_, w| w.pupdr10().pull_down());
                PB10 { _mode: PhantomData }
            }
            #[doc = " Configures the pin to operate as a pulled up input pin"]
            pub fn into_pull_up_input(
                self,
                moder: &mut MODER,
                pupdr: &mut PUPDR,
            ) -> PB10<Input<PullUp>> {
                moder.moder().modify(|_, w| w.moder10().input());
                pupdr.pupdr().modify(|_, w| w.pupdr10().pull_up());
                PB10 { _mode: PhantomData }
            }
            #[doc = " Configures the pin to operate as an open drain output pin"]
            pub fn into_open_drain_output(
                self,
                moder: &mut MODER,
                otyper: &mut OTYPER,
            ) -> PB10<Output<OpenDrain>> {
                moder.moder().modify(|_, w| w.moder10().output());
                otyper.otyper().modify(|_, w| w.ot10().open_drain());
                PB10 { _mode: PhantomData }
            }
            #[doc = " Configures the pin to operate as an push pull output pin"]
            pub fn into_push_pull_output(
                self,
                moder: &mut MODER,
                otyper: &mut OTYPER,
            ) -> PB10<Output<PushPull>> {
                moder.moder().modify(|_, w| w.moder10().output());
                otyper.otyper().modify(|_, w| w.ot10().push_pull());
                PB10 { _mode: PhantomData }
            }
            #[doc = " Configures the pin to operate as analog, with disabled schmitt trigger."]
            #[doc = " This mode is suitable when the pin is connected to the DAC or ADC."]
            pub fn into_analog(self, moder: &mut MODER, pupdr: &mut PUPDR) -> PB10<Analog> {
                moder.moder().modify(|_, w| w.moder10().analog());
                pupdr.pupdr().modify(|_, w| w.pupdr10().floating());
                PB10 { _mode: PhantomData }
            }
        }
        impl PB10<Output<OpenDrain>> {
            #[doc = " Enables / disables the internal pull up"]
            pub fn internal_pull_up(&mut self, pupdr: &mut PUPDR, on: bool) {
                pupdr.pupdr().modify(|_, w| {
                    if on {
                        w.pupdr10().pull_up()
                    } else {
                        w.pupdr10().floating()
                    }
                });
            }
        }
        impl<MODE> PB10<Output<MODE>> {
            #[doc = " Erases the pin number from the type"]
            #[doc = ""]
            #[doc = " This is useful when you want to collect the pins into an array where you"]
            #[doc = " need all the elements to have the same type"]
            pub fn downgrade(self) -> PBx<Output<MODE>> {
                PBx {
                    i: 10,
                    _mode: self._mode,
                }
            }
        }
        impl<MODE> PB10<Input<MODE>> {
            #[doc = " Erases the pin number from the type"]
            #[doc = ""]
            #[doc = " This is useful when you want to collect the pins into an array where you"]
            #[doc = " need all the elements to have the same type"]
            pub fn downgrade(self) -> PBx<Input<MODE>> {
                PBx {
                    i: 10,
                    _mode: self._mode,
                }
            }
        }
        impl<MODE> OutputPin for PB10<Output<MODE>> {
            type Error = Infallible;
            fn set_high(&mut self) -> Result<(), Self::Error> {
                unsafe { (*GPIOB::ptr()).bsrr.write(|w| w.bs10().set()) }
                Ok(())
            }
            fn set_low(&mut self) -> Result<(), Self::Error> {
                unsafe { (*GPIOB::ptr()).bsrr.write(|w| w.br10().reset()) }
                Ok(())
            }
        }
        #[cfg(feature = "unproven")]
        impl<MODE> InputPin for PB10<Input<MODE>> {
            type Error = Infallible;
            fn is_high(&self) -> Result<bool, Self::Error> {
                Ok(!self.is_low()?)
            }
            fn is_low(&self) -> Result<bool, Self::Error> {
                Ok(unsafe { (*GPIOB::ptr()).idr.read().idr10().is_low() })
            }
        }
        #[cfg(feature = "unproven")]
        impl InputPin for PB10<Output<OpenDrain>> {
            type Error = Infallible;
            fn is_high(&self) -> Result<bool, Self::Error> {
                Ok(!self.is_low()?)
            }
            fn is_low(&self) -> Result<bool, Self::Error> {
                Ok(unsafe { (*GPIOB::ptr()).idr.read().idr10().is_low() })
            }
        }
        #[cfg(feature = "unproven")]
        impl<MODE> StatefulOutputPin for PB10<Output<MODE>> {
            fn is_set_high(&self) -> Result<bool, Self::Error> {
                self.is_set_low().map(|b| !b)
            }
            fn is_set_low(&self) -> Result<bool, Self::Error> {
                Ok(unsafe { (*GPIOB::ptr()).odr.read().odr10().is_low() })
            }
        }
        #[cfg(feature = "unproven")]
        impl<MODE> toggleable::Default for PB10<Output<MODE>> {}
        #[doc = "Pin `PB11`"]
        pub struct PB11<MODE> {
            _mode: PhantomData<MODE>,
        }
        impl<MODE> PB11<MODE> {
            #[doc = "Configures `PB11` to serve as alternate function: `AF1`"]
            pub fn into_af1(self, moder: &mut MODER, afr: &mut AFRH) -> PB11<AF1> {
                moder.moder().modify(|_, w| w.moder11().alternate());
                afr.afr().modify(|_, w| w.afrh11().af1());
                PB11 { _mode: PhantomData }
            }
            #[doc = "Configures `PB11` to serve as alternate function: `AF3`"]
            pub fn into_af3(self, moder: &mut MODER, afr: &mut AFRH) -> PB11<AF3> {
                moder.moder().modify(|_, w| w.moder11().alternate());
                afr.afr().modify(|_, w| w.afrh11().af3());
                PB11 { _mode: PhantomData }
            }
            #[doc = "Configures `PB11` to serve as alternate function: `AF7`"]
            pub fn into_af7(self, moder: &mut MODER, afr: &mut AFRH) -> PB11<AF7> {
                moder.moder().modify(|_, w| w.moder11().alternate());
                afr.afr().modify(|_, w| w.afrh11().af7());
                PB11 { _mode: PhantomData }
            }
            #[doc = "Configures `PB11` to serve as alternate function: `AF15`"]
            pub fn into_af15(self, moder: &mut MODER, afr: &mut AFRH) -> PB11<AF15> {
                moder.moder().modify(|_, w| w.moder11().alternate());
                afr.afr().modify(|_, w| w.afrh11().af15());
                PB11 { _mode: PhantomData }
            }
            #[doc = " Configures the pin to operate as a floating input pin"]
            pub fn into_floating_input(
                self,
                moder: &mut MODER,
                pupdr: &mut PUPDR,
            ) -> PB11<Input<Floating>> {
                moder.moder().modify(|_, w| w.moder11().input());
                pupdr.pupdr().modify(|_, w| w.pupdr11().floating());
                PB11 { _mode: PhantomData }
            }
            #[doc = " Configures the pin to operate as a pulled down input pin"]
            pub fn into_pull_down_input(
                self,
                moder: &mut MODER,
                pupdr: &mut PUPDR,
            ) -> PB11<Input<PullDown>> {
                moder.moder().modify(|_, w| w.moder11().input());
                pupdr.pupdr().modify(|_, w| w.pupdr11().pull_down());
                PB11 { _mode: PhantomData }
            }
            #[doc = " Configures the pin to operate as a pulled up input pin"]
            pub fn into_pull_up_input(
                self,
                moder: &mut MODER,
                pupdr: &mut PUPDR,
            ) -> PB11<Input<PullUp>> {
                moder.moder().modify(|_, w| w.moder11().input());
                pupdr.pupdr().modify(|_, w| w.pupdr11().pull_up());
                PB11 { _mode: PhantomData }
            }
            #[doc = " Configures the pin to operate as an open drain output pin"]
            pub fn into_open_drain_output(
                self,
                moder: &mut MODER,
                otyper: &mut OTYPER,
            ) -> PB11<Output<OpenDrain>> {
                moder.moder().modify(|_, w| w.moder11().output());
                otyper.otyper().modify(|_, w| w.ot11().open_drain());
                PB11 { _mode: PhantomData }
            }
            #[doc = " Configures the pin to operate as an push pull output pin"]
            pub fn into_push_pull_output(
                self,
                moder: &mut MODER,
                otyper: &mut OTYPER,
            ) -> PB11<Output<PushPull>> {
                moder.moder().modify(|_, w| w.moder11().output());
                otyper.otyper().modify(|_, w| w.ot11().push_pull());
                PB11 { _mode: PhantomData }
            }
            #[doc = " Configures the pin to operate as analog, with disabled schmitt trigger."]
            #[doc = " This mode is suitable when the pin is connected to the DAC or ADC."]
            pub fn into_analog(self, moder: &mut MODER, pupdr: &mut PUPDR) -> PB11<Analog> {
                moder.moder().modify(|_, w| w.moder11().analog());
                pupdr.pupdr().modify(|_, w| w.pupdr11().floating());
                PB11 { _mode: PhantomData }
            }
        }
        impl PB11<Output<OpenDrain>> {
            #[doc = " Enables / disables the internal pull up"]
            pub fn internal_pull_up(&mut self, pupdr: &mut PUPDR, on: bool) {
                pupdr.pupdr().modify(|_, w| {
                    if on {
                        w.pupdr11().pull_up()
                    } else {
                        w.pupdr11().floating()
                    }
                });
            }
        }
        impl<MODE> PB11<Output<MODE>> {
            #[doc = " Erases the pin number from the type"]
            #[doc = ""]
            #[doc = " This is useful when you want to collect the pins into an array where you"]
            #[doc = " need all the elements to have the same type"]
            pub fn downgrade(self) -> PBx<Output<MODE>> {
                PBx {
                    i: 11,
                    _mode: self._mode,
                }
            }
        }
        impl<MODE> PB11<Input<MODE>> {
            #[doc = " Erases the pin number from the type"]
            #[doc = ""]
            #[doc = " This is useful when you want to collect the pins into an array where you"]
            #[doc = " need all the elements to have the same type"]
            pub fn downgrade(self) -> PBx<Input<MODE>> {
                PBx {
                    i: 11,
                    _mode: self._mode,
                }
            }
        }
        impl<MODE> OutputPin for PB11<Output<MODE>> {
            type Error = Infallible;
            fn set_high(&mut self) -> Result<(), Self::Error> {
                unsafe { (*GPIOB::ptr()).bsrr.write(|w| w.bs11().set()) }
                Ok(())
            }
            fn set_low(&mut self) -> Result<(), Self::Error> {
                unsafe { (*GPIOB::ptr()).bsrr.write(|w| w.br11().reset()) }
                Ok(())
            }
        }
        #[cfg(feature = "unproven")]
        impl<MODE> InputPin for PB11<Input<MODE>> {
            type Error = Infallible;
            fn is_high(&self) -> Result<bool, Self::Error> {
                Ok(!self.is_low()?)
            }
            fn is_low(&self) -> Result<bool, Self::Error> {
                Ok(unsafe { (*GPIOB::ptr()).idr.read().idr11().is_low() })
            }
        }
        #[cfg(feature = "unproven")]
        impl InputPin for PB11<Output<OpenDrain>> {
            type Error = Infallible;
            fn is_high(&self) -> Result<bool, Self::Error> {
                Ok(!self.is_low()?)
            }
            fn is_low(&self) -> Result<bool, Self::Error> {
                Ok(unsafe { (*GPIOB::ptr()).idr.read().idr11().is_low() })
            }
        }
        #[cfg(feature = "unproven")]
        impl<MODE> StatefulOutputPin for PB11<Output<MODE>> {
            fn is_set_high(&self) -> Result<bool, Self::Error> {
                self.is_set_low().map(|b| !b)
            }
            fn is_set_low(&self) -> Result<bool, Self::Error> {
                Ok(unsafe { (*GPIOB::ptr()).odr.read().odr11().is_low() })
            }
        }
        #[cfg(feature = "unproven")]
        impl<MODE> toggleable::Default for PB11<Output<MODE>> {}
        #[doc = "Pin `PB12`"]
        pub struct PB12<MODE> {
            _mode: PhantomData<MODE>,
        }
        impl<MODE> PB12<MODE> {
            #[doc = "Configures `PB12` to serve as alternate function: `AF3`"]
            pub fn into_af3(self, moder: &mut MODER, afr: &mut AFRH) -> PB12<AF3> {
                moder.moder().modify(|_, w| w.moder12().alternate());
                afr.afr().modify(|_, w| w.afrh12().af3());
                PB12 { _mode: PhantomData }
            }
            #[doc = "Configures `PB12` to serve as alternate function: `AF4`"]
            pub fn into_af4(self, moder: &mut MODER, afr: &mut AFRH) -> PB12<AF4> {
                moder.moder().modify(|_, w| w.moder12().alternate());
                afr.afr().modify(|_, w| w.afrh12().af4());
                PB12 { _mode: PhantomData }
            }
            #[doc = "Configures `PB12` to serve as alternate function: `AF5`"]
            pub fn into_af5(self, moder: &mut MODER, afr: &mut AFRH) -> PB12<AF5> {
                moder.moder().modify(|_, w| w.moder12().alternate());
                afr.afr().modify(|_, w| w.afrh12().af5());
                PB12 { _mode: PhantomData }
            }
            #[doc = "Configures `PB12` to serve as alternate function: `AF6`"]
            pub fn into_af6(self, moder: &mut MODER, afr: &mut AFRH) -> PB12<AF6> {
                moder.moder().modify(|_, w| w.moder12().alternate());
                afr.afr().modify(|_, w| w.afrh12().af6());
                PB12 { _mode: PhantomData }
            }
            #[doc = "Configures `PB12` to serve as alternate function: `AF7`"]
            pub fn into_af7(self, moder: &mut MODER, afr: &mut AFRH) -> PB12<AF7> {
                moder.moder().modify(|_, w| w.moder12().alternate());
                afr.afr().modify(|_, w| w.afrh12().af7());
                PB12 { _mode: PhantomData }
            }
            #[doc = "Configures `PB12` to serve as alternate function: `AF15`"]
            pub fn into_af15(self, moder: &mut MODER, afr: &mut AFRH) -> PB12<AF15> {
                moder.moder().modify(|_, w| w.moder12().alternate());
                afr.afr().modify(|_, w| w.afrh12().af15());
                PB12 { _mode: PhantomData }
            }
            #[doc = " Configures the pin to operate as a floating input pin"]
            pub fn into_floating_input(
                self,
                moder: &mut MODER,
                pupdr: &mut PUPDR,
            ) -> PB12<Input<Floating>> {
                moder.moder().modify(|_, w| w.moder12().input());
                pupdr.pupdr().modify(|_, w| w.pupdr12().floating());
                PB12 { _mode: PhantomData }
            }
            #[doc = " Configures the pin to operate as a pulled down input pin"]
            pub fn into_pull_down_input(
                self,
                moder: &mut MODER,
                pupdr: &mut PUPDR,
            ) -> PB12<Input<PullDown>> {
                moder.moder().modify(|_, w| w.moder12().input());
                pupdr.pupdr().modify(|_, w| w.pupdr12().pull_down());
                PB12 { _mode: PhantomData }
            }
            #[doc = " Configures the pin to operate as a pulled up input pin"]
            pub fn into_pull_up_input(
                self,
                moder: &mut MODER,
                pupdr: &mut PUPDR,
            ) -> PB12<Input<PullUp>> {
                moder.moder().modify(|_, w| w.moder12().input());
                pupdr.pupdr().modify(|_, w| w.pupdr12().pull_up());
                PB12 { _mode: PhantomData }
            }
            #[doc = " Configures the pin to operate as an open drain output pin"]
            pub fn into_open_drain_output(
                self,
                moder: &mut MODER,
                otyper: &mut OTYPER,
            ) -> PB12<Output<OpenDrain>> {
                moder.moder().modify(|_, w| w.moder12().output());
                otyper.otyper().modify(|_, w| w.ot12().open_drain());
                PB12 { _mode: PhantomData }
            }
            #[doc = " Configures the pin to operate as an push pull output pin"]
            pub fn into_push_pull_output(
                self,
                moder: &mut MODER,
                otyper: &mut OTYPER,
            ) -> PB12<Output<PushPull>> {
                moder.moder().modify(|_, w| w.moder12().output());
                otyper.otyper().modify(|_, w| w.ot12().push_pull());
                PB12 { _mode: PhantomData }
            }
            #[doc = " Configures the pin to operate as analog, with disabled schmitt trigger."]
            #[doc = " This mode is suitable when the pin is connected to the DAC or ADC."]
            pub fn into_analog(self, moder: &mut MODER, pupdr: &mut PUPDR) -> PB12<Analog> {
                moder.moder().modify(|_, w| w.moder12().analog());
                pupdr.pupdr().modify(|_, w| w.pupdr12().floating());
                PB12 { _mode: PhantomData }
            }
        }
        impl PB12<Output<OpenDrain>> {
            #[doc = " Enables / disables the internal pull up"]
            pub fn internal_pull_up(&mut self, pupdr: &mut PUPDR, on: bool) {
                pupdr.pupdr().modify(|_, w| {
                    if on {
                        w.pupdr12().pull_up()
                    } else {
                        w.pupdr12().floating()
                    }
                });
            }
        }
        impl<MODE> PB12<Output<MODE>> {
            #[doc = " Erases the pin number from the type"]
            #[doc = ""]
            #[doc = " This is useful when you want to collect the pins into an array where you"]
            #[doc = " need all the elements to have the same type"]
            pub fn downgrade(self) -> PBx<Output<MODE>> {
                PBx {
                    i: 12,
                    _mode: self._mode,
                }
            }
        }
        impl<MODE> PB12<Input<MODE>> {
            #[doc = " Erases the pin number from the type"]
            #[doc = ""]
            #[doc = " This is useful when you want to collect the pins into an array where you"]
            #[doc = " need all the elements to have the same type"]
            pub fn downgrade(self) -> PBx<Input<MODE>> {
                PBx {
                    i: 12,
                    _mode: self._mode,
                }
            }
        }
        impl<MODE> OutputPin for PB12<Output<MODE>> {
            type Error = Infallible;
            fn set_high(&mut self) -> Result<(), Self::Error> {
                unsafe { (*GPIOB::ptr()).bsrr.write(|w| w.bs12().set()) }
                Ok(())
            }
            fn set_low(&mut self) -> Result<(), Self::Error> {
                unsafe { (*GPIOB::ptr()).bsrr.write(|w| w.br12().reset()) }
                Ok(())
            }
        }
        #[cfg(feature = "unproven")]
        impl<MODE> InputPin for PB12<Input<MODE>> {
            type Error = Infallible;
            fn is_high(&self) -> Result<bool, Self::Error> {
                Ok(!self.is_low()?)
            }
            fn is_low(&self) -> Result<bool, Self::Error> {
                Ok(unsafe { (*GPIOB::ptr()).idr.read().idr12().is_low() })
            }
        }
        #[cfg(feature = "unproven")]
        impl InputPin for PB12<Output<OpenDrain>> {
            type Error = Infallible;
            fn is_high(&self) -> Result<bool, Self::Error> {
                Ok(!self.is_low()?)
            }
            fn is_low(&self) -> Result<bool, Self::Error> {
                Ok(unsafe { (*GPIOB::ptr()).idr.read().idr12().is_low() })
            }
        }
        #[cfg(feature = "unproven")]
        impl<MODE> StatefulOutputPin for PB12<Output<MODE>> {
            fn is_set_high(&self) -> Result<bool, Self::Error> {
                self.is_set_low().map(|b| !b)
            }
            fn is_set_low(&self) -> Result<bool, Self::Error> {
                Ok(unsafe { (*GPIOB::ptr()).odr.read().odr12().is_low() })
            }
        }
        #[cfg(feature = "unproven")]
        impl<MODE> toggleable::Default for PB12<Output<MODE>> {}
        #[doc = "Pin `PB13`"]
        pub struct PB13<MODE> {
            _mode: PhantomData<MODE>,
        }
        impl<MODE> PB13<MODE> {
            #[doc = "Configures `PB13` to serve as alternate function: `AF3`"]
            pub fn into_af3(self, moder: &mut MODER, afr: &mut AFRH) -> PB13<AF3> {
                moder.moder().modify(|_, w| w.moder13().alternate());
                afr.afr().modify(|_, w| w.afrh13().af3());
                PB13 { _mode: PhantomData }
            }
            #[doc = "Configures `PB13` to serve as alternate function: `AF5`"]
            pub fn into_af5(self, moder: &mut MODER, afr: &mut AFRH) -> PB13<AF5> {
                moder.moder().modify(|_, w| w.moder13().alternate());
                afr.afr().modify(|_, w| w.afrh13().af5());
                PB13 { _mode: PhantomData }
            }
            #[doc = "Configures `PB13` to serve as alternate function: `AF6`"]
            pub fn into_af6(self, moder: &mut MODER, afr: &mut AFRH) -> PB13<AF6> {
                moder.moder().modify(|_, w| w.moder13().alternate());
                afr.afr().modify(|_, w| w.afrh13().af6());
                PB13 { _mode: PhantomData }
            }
            #[doc = "Configures `PB13` to serve as alternate function: `AF7`"]
            pub fn into_af7(self, moder: &mut MODER, afr: &mut AFRH) -> PB13<AF7> {
                moder.moder().modify(|_, w| w.moder13().alternate());
                afr.afr().modify(|_, w| w.afrh13().af7());
                PB13 { _mode: PhantomData }
            }
            #[doc = "Configures `PB13` to serve as alternate function: `AF15`"]
            pub fn into_af15(self, moder: &mut MODER, afr: &mut AFRH) -> PB13<AF15> {
                moder.moder().modify(|_, w| w.moder13().alternate());
                afr.afr().modify(|_, w| w.afrh13().af15());
                PB13 { _mode: PhantomData }
            }
            #[doc = " Configures the pin to operate as a floating input pin"]
            pub fn into_floating_input(
                self,
                moder: &mut MODER,
                pupdr: &mut PUPDR,
            ) -> PB13<Input<Floating>> {
                moder.moder().modify(|_, w| w.moder13().input());
                pupdr.pupdr().modify(|_, w| w.pupdr13().floating());
                PB13 { _mode: PhantomData }
            }
            #[doc = " Configures the pin to operate as a pulled down input pin"]
            pub fn into_pull_down_input(
                self,
                moder: &mut MODER,
                pupdr: &mut PUPDR,
            ) -> PB13<Input<PullDown>> {
                moder.moder().modify(|_, w| w.moder13().input());
                pupdr.pupdr().modify(|_, w| w.pupdr13().pull_down());
                PB13 { _mode: PhantomData }
            }
            #[doc = " Configures the pin to operate as a pulled up input pin"]
            pub fn into_pull_up_input(
                self,
                moder: &mut MODER,
                pupdr: &mut PUPDR,
            ) -> PB13<Input<PullUp>> {
                moder.moder().modify(|_, w| w.moder13().input());
                pupdr.pupdr().modify(|_, w| w.pupdr13().pull_up());
                PB13 { _mode: PhantomData }
            }
            #[doc = " Configures the pin to operate as an open drain output pin"]
            pub fn into_open_drain_output(
                self,
                moder: &mut MODER,
                otyper: &mut OTYPER,
            ) -> PB13<Output<OpenDrain>> {
                moder.moder().modify(|_, w| w.moder13().output());
                otyper.otyper().modify(|_, w| w.ot13().open_drain());
                PB13 { _mode: PhantomData }
            }
            #[doc = " Configures the pin to operate as an push pull output pin"]
            pub fn into_push_pull_output(
                self,
                moder: &mut MODER,
                otyper: &mut OTYPER,
            ) -> PB13<Output<PushPull>> {
                moder.moder().modify(|_, w| w.moder13().output());
                otyper.otyper().modify(|_, w| w.ot13().push_pull());
                PB13 { _mode: PhantomData }
            }
            #[doc = " Configures the pin to operate as analog, with disabled schmitt trigger."]
            #[doc = " This mode is suitable when the pin is connected to the DAC or ADC."]
            pub fn into_analog(self, moder: &mut MODER, pupdr: &mut PUPDR) -> PB13<Analog> {
                moder.moder().modify(|_, w| w.moder13().analog());
                pupdr.pupdr().modify(|_, w| w.pupdr13().floating());
                PB13 { _mode: PhantomData }
            }
        }
        impl PB13<Output<OpenDrain>> {
            #[doc = " Enables / disables the internal pull up"]
            pub fn internal_pull_up(&mut self, pupdr: &mut PUPDR, on: bool) {
                pupdr.pupdr().modify(|_, w| {
                    if on {
                        w.pupdr13().pull_up()
                    } else {
                        w.pupdr13().floating()
                    }
                });
            }
        }
        impl<MODE> PB13<Output<MODE>> {
            #[doc = " Erases the pin number from the type"]
            #[doc = ""]
            #[doc = " This is useful when you want to collect the pins into an array where you"]
            #[doc = " need all the elements to have the same type"]
            pub fn downgrade(self) -> PBx<Output<MODE>> {
                PBx {
                    i: 13,
                    _mode: self._mode,
                }
            }
        }
        impl<MODE> PB13<Input<MODE>> {
            #[doc = " Erases the pin number from the type"]
            #[doc = ""]
            #[doc = " This is useful when you want to collect the pins into an array where you"]
            #[doc = " need all the elements to have the same type"]
            pub fn downgrade(self) -> PBx<Input<MODE>> {
                PBx {
                    i: 13,
                    _mode: self._mode,
                }
            }
        }
        impl<MODE> OutputPin for PB13<Output<MODE>> {
            type Error = Infallible;
            fn set_high(&mut self) -> Result<(), Self::Error> {
                unsafe { (*GPIOB::ptr()).bsrr.write(|w| w.bs13().set()) }
                Ok(())
            }
            fn set_low(&mut self) -> Result<(), Self::Error> {
                unsafe { (*GPIOB::ptr()).bsrr.write(|w| w.br13().reset()) }
                Ok(())
            }
        }
        #[cfg(feature = "unproven")]
        impl<MODE> InputPin for PB13<Input<MODE>> {
            type Error = Infallible;
            fn is_high(&self) -> Result<bool, Self::Error> {
                Ok(!self.is_low()?)
            }
            fn is_low(&self) -> Result<bool, Self::Error> {
                Ok(unsafe { (*GPIOB::ptr()).idr.read().idr13().is_low() })
            }
        }
        #[cfg(feature = "unproven")]
        impl InputPin for PB13<Output<OpenDrain>> {
            type Error = Infallible;
            fn is_high(&self) -> Result<bool, Self::Error> {
                Ok(!self.is_low()?)
            }
            fn is_low(&self) -> Result<bool, Self::Error> {
                Ok(unsafe { (*GPIOB::ptr()).idr.read().idr13().is_low() })
            }
        }
        #[cfg(feature = "unproven")]
        impl<MODE> StatefulOutputPin for PB13<Output<MODE>> {
            fn is_set_high(&self) -> Result<bool, Self::Error> {
                self.is_set_low().map(|b| !b)
            }
            fn is_set_low(&self) -> Result<bool, Self::Error> {
                Ok(unsafe { (*GPIOB::ptr()).odr.read().odr13().is_low() })
            }
        }
        #[cfg(feature = "unproven")]
        impl<MODE> toggleable::Default for PB13<Output<MODE>> {}
        #[doc = "Pin `PB14`"]
        pub struct PB14<MODE> {
            _mode: PhantomData<MODE>,
        }
        impl<MODE> PB14<MODE> {
            #[doc = "Configures `PB14` to serve as alternate function: `AF1`"]
            pub fn into_af1(self, moder: &mut MODER, afr: &mut AFRH) -> PB14<AF1> {
                moder.moder().modify(|_, w| w.moder14().alternate());
                afr.afr().modify(|_, w| w.afrh14().af1());
                PB14 { _mode: PhantomData }
            }
            #[doc = "Configures `PB14` to serve as alternate function: `AF3`"]
            pub fn into_af3(self, moder: &mut MODER, afr: &mut AFRH) -> PB14<AF3> {
                moder.moder().modify(|_, w| w.moder14().alternate());
                afr.afr().modify(|_, w| w.afrh14().af3());
                PB14 { _mode: PhantomData }
            }
            #[doc = "Configures `PB14` to serve as alternate function: `AF5`"]
            pub fn into_af5(self, moder: &mut MODER, afr: &mut AFRH) -> PB14<AF5> {
                moder.moder().modify(|_, w| w.moder14().alternate());
                afr.afr().modify(|_, w| w.afrh14().af5());
                PB14 { _mode: PhantomData }
            }
            #[doc = "Configures `PB14` to serve as alternate function: `AF6`"]
            pub fn into_af6(self, moder: &mut MODER, afr: &mut AFRH) -> PB14<AF6> {
                moder.moder().modify(|_, w| w.moder14().alternate());
                afr.afr().modify(|_, w| w.afrh14().af6());
                PB14 { _mode: PhantomData }
            }
            #[doc = "Configures `PB14` to serve as alternate function: `AF7`"]
            pub fn into_af7(self, moder: &mut MODER, afr: &mut AFRH) -> PB14<AF7> {
                moder.moder().modify(|_, w| w.moder14().alternate());
                afr.afr().modify(|_, w| w.afrh14().af7());
                PB14 { _mode: PhantomData }
            }
            #[doc = "Configures `PB14` to serve as alternate function: `AF15`"]
            pub fn into_af15(self, moder: &mut MODER, afr: &mut AFRH) -> PB14<AF15> {
                moder.moder().modify(|_, w| w.moder14().alternate());
                afr.afr().modify(|_, w| w.afrh14().af15());
                PB14 { _mode: PhantomData }
            }
            #[doc = " Configures the pin to operate as a floating input pin"]
            pub fn into_floating_input(
                self,
                moder: &mut MODER,
                pupdr: &mut PUPDR,
            ) -> PB14<Input<Floating>> {
                moder.moder().modify(|_, w| w.moder14().input());
                pupdr.pupdr().modify(|_, w| w.pupdr14().floating());
                PB14 { _mode: PhantomData }
            }
            #[doc = " Configures the pin to operate as a pulled down input pin"]
            pub fn into_pull_down_input(
                self,
                moder: &mut MODER,
                pupdr: &mut PUPDR,
            ) -> PB14<Input<PullDown>> {
                moder.moder().modify(|_, w| w.moder14().input());
                pupdr.pupdr().modify(|_, w| w.pupdr14().pull_down());
                PB14 { _mode: PhantomData }
            }
            #[doc = " Configures the pin to operate as a pulled up input pin"]
            pub fn into_pull_up_input(
                self,
                moder: &mut MODER,
                pupdr: &mut PUPDR,
            ) -> PB14<Input<PullUp>> {
                moder.moder().modify(|_, w| w.moder14().input());
                pupdr.pupdr().modify(|_, w| w.pupdr14().pull_up());
                PB14 { _mode: PhantomData }
            }
            #[doc = " Configures the pin to operate as an open drain output pin"]
            pub fn into_open_drain_output(
                self,
                moder: &mut MODER,
                otyper: &mut OTYPER,
            ) -> PB14<Output<OpenDrain>> {
                moder.moder().modify(|_, w| w.moder14().output());
                otyper.otyper().modify(|_, w| w.ot14().open_drain());
                PB14 { _mode: PhantomData }
            }
            #[doc = " Configures the pin to operate as an push pull output pin"]
            pub fn into_push_pull_output(
                self,
                moder: &mut MODER,
                otyper: &mut OTYPER,
            ) -> PB14<Output<PushPull>> {
                moder.moder().modify(|_, w| w.moder14().output());
                otyper.otyper().modify(|_, w| w.ot14().push_pull());
                PB14 { _mode: PhantomData }
            }
            #[doc = " Configures the pin to operate as analog, with disabled schmitt trigger."]
            #[doc = " This mode is suitable when the pin is connected to the DAC or ADC."]
            pub fn into_analog(self, moder: &mut MODER, pupdr: &mut PUPDR) -> PB14<Analog> {
                moder.moder().modify(|_, w| w.moder14().analog());
                pupdr.pupdr().modify(|_, w| w.pupdr14().floating());
                PB14 { _mode: PhantomData }
            }
        }
        impl PB14<Output<OpenDrain>> {
            #[doc = " Enables / disables the internal pull up"]
            pub fn internal_pull_up(&mut self, pupdr: &mut PUPDR, on: bool) {
                pupdr.pupdr().modify(|_, w| {
                    if on {
                        w.pupdr14().pull_up()
                    } else {
                        w.pupdr14().floating()
                    }
                });
            }
        }
        impl<MODE> PB14<Output<MODE>> {
            #[doc = " Erases the pin number from the type"]
            #[doc = ""]
            #[doc = " This is useful when you want to collect the pins into an array where you"]
            #[doc = " need all the elements to have the same type"]
            pub fn downgrade(self) -> PBx<Output<MODE>> {
                PBx {
                    i: 14,
                    _mode: self._mode,
                }
            }
        }
        impl<MODE> PB14<Input<MODE>> {
            #[doc = " Erases the pin number from the type"]
            #[doc = ""]
            #[doc = " This is useful when you want to collect the pins into an array where you"]
            #[doc = " need all the elements to have the same type"]
            pub fn downgrade(self) -> PBx<Input<MODE>> {
                PBx {
                    i: 14,
                    _mode: self._mode,
                }
            }
        }
        impl<MODE> OutputPin for PB14<Output<MODE>> {
            type Error = Infallible;
            fn set_high(&mut self) -> Result<(), Self::Error> {
                unsafe { (*GPIOB::ptr()).bsrr.write(|w| w.bs14().set()) }
                Ok(())
            }
            fn set_low(&mut self) -> Result<(), Self::Error> {
                unsafe { (*GPIOB::ptr()).bsrr.write(|w| w.br14().reset()) }
                Ok(())
            }
        }
        #[cfg(feature = "unproven")]
        impl<MODE> InputPin for PB14<Input<MODE>> {
            type Error = Infallible;
            fn is_high(&self) -> Result<bool, Self::Error> {
                Ok(!self.is_low()?)
            }
            fn is_low(&self) -> Result<bool, Self::Error> {
                Ok(unsafe { (*GPIOB::ptr()).idr.read().idr14().is_low() })
            }
        }
        #[cfg(feature = "unproven")]
        impl InputPin for PB14<Output<OpenDrain>> {
            type Error = Infallible;
            fn is_high(&self) -> Result<bool, Self::Error> {
                Ok(!self.is_low()?)
            }
            fn is_low(&self) -> Result<bool, Self::Error> {
                Ok(unsafe { (*GPIOB::ptr()).idr.read().idr14().is_low() })
            }
        }
        #[cfg(feature = "unproven")]
        impl<MODE> StatefulOutputPin for PB14<Output<MODE>> {
            fn is_set_high(&self) -> Result<bool, Self::Error> {
                self.is_set_low().map(|b| !b)
            }
            fn is_set_low(&self) -> Result<bool, Self::Error> {
                Ok(unsafe { (*GPIOB::ptr()).odr.read().odr14().is_low() })
            }
        }
        #[cfg(feature = "unproven")]
        impl<MODE> toggleable::Default for PB14<Output<MODE>> {}
        #[doc = "Pin `PB15`"]
        pub struct PB15<MODE> {
            _mode: PhantomData<MODE>,
        }
        impl<MODE> PB15<MODE> {
            #[doc = "Configures `PB15` to serve as alternate function: `AF0`"]
            pub fn into_af0(self, moder: &mut MODER, afr: &mut AFRH) -> PB15<AF0> {
                moder.moder().modify(|_, w| w.moder15().alternate());
                afr.afr().modify(|_, w| w.afrh15().af0());
                PB15 { _mode: PhantomData }
            }
            #[doc = "Configures `PB15` to serve as alternate function: `AF1`"]
            pub fn into_af1(self, moder: &mut MODER, afr: &mut AFRH) -> PB15<AF1> {
                moder.moder().modify(|_, w| w.moder15().alternate());
                afr.afr().modify(|_, w| w.afrh15().af1());
                PB15 { _mode: PhantomData }
            }
            #[doc = "Configures `PB15` to serve as alternate function: `AF2`"]
            pub fn into_af2(self, moder: &mut MODER, afr: &mut AFRH) -> PB15<AF2> {
                moder.moder().modify(|_, w| w.moder15().alternate());
                afr.afr().modify(|_, w| w.afrh15().af2());
                PB15 { _mode: PhantomData }
            }
            #[doc = "Configures `PB15` to serve as alternate function: `AF4`"]
            pub fn into_af4(self, moder: &mut MODER, afr: &mut AFRH) -> PB15<AF4> {
                moder.moder().modify(|_, w| w.moder15().alternate());
                afr.afr().modify(|_, w| w.afrh15().af4());
                PB15 { _mode: PhantomData }
            }
            #[doc = "Configures `PB15` to serve as alternate function: `AF5`"]
            pub fn into_af5(self, moder: &mut MODER, afr: &mut AFRH) -> PB15<AF5> {
                moder.moder().modify(|_, w| w.moder15().alternate());
                afr.afr().modify(|_, w| w.afrh15().af5());
                PB15 { _mode: PhantomData }
            }
            #[doc = "Configures `PB15` to serve as alternate function: `AF15`"]
            pub fn into_af15(self, moder: &mut MODER, afr: &mut AFRH) -> PB15<AF15> {
                moder.moder().modify(|_, w| w.moder15().alternate());
                afr.afr().modify(|_, w| w.afrh15().af15());
                PB15 { _mode: PhantomData }
            }
            #[doc = " Configures the pin to operate as a floating input pin"]
            pub fn into_floating_input(
                self,
                moder: &mut MODER,
                pupdr: &mut PUPDR,
            ) -> PB15<Input<Floating>> {
                moder.moder().modify(|_, w| w.moder15().input());
                pupdr.pupdr().modify(|_, w| w.pupdr15().floating());
                PB15 { _mode: PhantomData }
            }
            #[doc = " Configures the pin to operate as a pulled down input pin"]
            pub fn into_pull_down_input(
                self,
                moder: &mut MODER,
                pupdr: &mut PUPDR,
            ) -> PB15<Input<PullDown>> {
                moder.moder().modify(|_, w| w.moder15().input());
                pupdr.pupdr().modify(|_, w| w.pupdr15().pull_down());
                PB15 { _mode: PhantomData }
            }
            #[doc = " Configures the pin to operate as a pulled up input pin"]
            pub fn into_pull_up_input(
                self,
                moder: &mut MODER,
                pupdr: &mut PUPDR,
            ) -> PB15<Input<PullUp>> {
                moder.moder().modify(|_, w| w.moder15().input());
                pupdr.pupdr().modify(|_, w| w.pupdr15().pull_up());
                PB15 { _mode: PhantomData }
            }
            #[doc = " Configures the pin to operate as an open drain output pin"]
            pub fn into_open_drain_output(
                self,
                moder: &mut MODER,
                otyper: &mut OTYPER,
            ) -> PB15<Output<OpenDrain>> {
                moder.moder().modify(|_, w| w.moder15().output());
                otyper.otyper().modify(|_, w| w.ot15().open_drain());
                PB15 { _mode: PhantomData }
            }
            #[doc = " Configures the pin to operate as an push pull output pin"]
            pub fn into_push_pull_output(
                self,
                moder: &mut MODER,
                otyper: &mut OTYPER,
            ) -> PB15<Output<PushPull>> {
                moder.moder().modify(|_, w| w.moder15().output());
                otyper.otyper().modify(|_, w| w.ot15().push_pull());
                PB15 { _mode: PhantomData }
            }
            #[doc = " Configures the pin to operate as analog, with disabled schmitt trigger."]
            #[doc = " This mode is suitable when the pin is connected to the DAC or ADC."]
            pub fn into_analog(self, moder: &mut MODER, pupdr: &mut PUPDR) -> PB15<Analog> {
                moder.moder().modify(|_, w| w.moder15().analog());
                pupdr.pupdr().modify(|_, w| w.pupdr15().floating());
                PB15 { _mode: PhantomData }
            }
        }
        impl PB15<Output<OpenDrain>> {
            #[doc = " Enables / disables the internal pull up"]
            pub fn internal_pull_up(&mut self, pupdr: &mut PUPDR, on: bool) {
                pupdr.pupdr().modify(|_, w| {
                    if on {
                        w.pupdr15().pull_up()
                    } else {
                        w.pupdr15().floating()
                    }
                });
            }
        }
        impl<MODE> PB15<Output<MODE>> {
            #[doc = " Erases the pin number from the type"]
            #[doc = ""]
            #[doc = " This is useful when you want to collect the pins into an array where you"]
            #[doc = " need all the elements to have the same type"]
            pub fn downgrade(self) -> PBx<Output<MODE>> {
                PBx {
                    i: 15,
                    _mode: self._mode,
                }
            }
        }
        impl<MODE> PB15<Input<MODE>> {
            #[doc = " Erases the pin number from the type"]
            #[doc = ""]
            #[doc = " This is useful when you want to collect the pins into an array where you"]
            #[doc = " need all the elements to have the same type"]
            pub fn downgrade(self) -> PBx<Input<MODE>> {
                PBx {
                    i: 15,
                    _mode: self._mode,
                }
            }
        }
        impl<MODE> OutputPin for PB15<Output<MODE>> {
            type Error = Infallible;
            fn set_high(&mut self) -> Result<(), Self::Error> {
                unsafe { (*GPIOB::ptr()).bsrr.write(|w| w.bs15().set()) }
                Ok(())
            }
            fn set_low(&mut self) -> Result<(), Self::Error> {
                unsafe { (*GPIOB::ptr()).bsrr.write(|w| w.br15().reset()) }
                Ok(())
            }
        }
        #[cfg(feature = "unproven")]
        impl<MODE> InputPin for PB15<Input<MODE>> {
            type Error = Infallible;
            fn is_high(&self) -> Result<bool, Self::Error> {
                Ok(!self.is_low()?)
            }
            fn is_low(&self) -> Result<bool, Self::Error> {
                Ok(unsafe { (*GPIOB::ptr()).idr.read().idr15().is_low() })
            }
        }
        #[cfg(feature = "unproven")]
        impl InputPin for PB15<Output<OpenDrain>> {
            type Error = Infallible;
            fn is_high(&self) -> Result<bool, Self::Error> {
                Ok(!self.is_low()?)
            }
            fn is_low(&self) -> Result<bool, Self::Error> {
                Ok(unsafe { (*GPIOB::ptr()).idr.read().idr15().is_low() })
            }
        }
        #[cfg(feature = "unproven")]
        impl<MODE> StatefulOutputPin for PB15<Output<MODE>> {
            fn is_set_high(&self) -> Result<bool, Self::Error> {
                self.is_set_low().map(|b| !b)
            }
            fn is_set_low(&self) -> Result<bool, Self::Error> {
                Ok(unsafe { (*GPIOB::ptr()).odr.read().odr15().is_low() })
            }
        }
        #[cfg(feature = "unproven")]
        impl<MODE> toggleable::Default for PB15<Output<MODE>> {}
    }
    #[doc = "All Pins and associated functions for GPIO Bank: `GPIOC`"]
    pub mod gpioc {
        use core::marker::PhantomData;
        use core::convert::Infallible;
        use crate::hal::digital::v2::OutputPin;
        #[cfg(feature = "unproven")]
        use crate::hal::digital::v2::InputPin;
        #[cfg(feature = "unproven")]
        use crate::hal::digital::v2::StatefulOutputPin;
        #[cfg(feature = "unproven")]
        use crate::hal::digital::v2::toggleable;
        use crate::pac::{gpioc, GPIOC};
        use crate::rcc::AHB;
        #[allow(unused_imports)]
        use super::{
            AF0, AF1, AF2, AF3, AF4, AF5, AF6, AF7, AF8, AF9, AF10, AF11, AF12, AF13, AF14, AF15,
        };
        use super::{
            Floating, GpioExt, Input, OpenDrain, Output, Analog, PullDown, PullUp, PushPull, PXx,
            Gpio,
        };
        #[doc = " GPIO parts"]
        pub struct Parts {
            #[doc = " Opaque AFRH register"]
            pub afrh: AFRH,
            #[doc = " Opaque AFRL register"]
            pub afrl: AFRL,
            #[doc = " Opaque MODER register"]
            pub moder: MODER,
            #[doc = " Opaque OTYPER register"]
            pub otyper: OTYPER,
            #[doc = " Opaque PUPDR register"]
            pub pupdr: PUPDR,
            #[doc = " Pin"]
            pub pc0: PC0<Input<Floating>>,
            #[doc = " Pin"]
            pub pc1: PC1<Input<Floating>>,
            #[doc = " Pin"]
            pub pc2: PC2<Input<Floating>>,
            #[doc = " Pin"]
            pub pc3: PC3<Input<Floating>>,
            #[doc = " Pin"]
            pub pc4: PC4<Input<Floating>>,
            #[doc = " Pin"]
            pub pc5: PC5<Input<Floating>>,
            #[doc = " Pin"]
            pub pc6: PC6<Input<Floating>>,
            #[doc = " Pin"]
            pub pc7: PC7<Input<Floating>>,
            #[doc = " Pin"]
            pub pc8: PC8<Input<Floating>>,
            #[doc = " Pin"]
            pub pc9: PC9<Input<Floating>>,
            #[doc = " Pin"]
            pub pc10: PC10<Input<Floating>>,
            #[doc = " Pin"]
            pub pc11: PC11<Input<Floating>>,
            #[doc = " Pin"]
            pub pc12: PC12<Input<Floating>>,
            #[doc = " Pin"]
            pub pc13: PC13<Input<Floating>>,
            #[doc = " Pin"]
            pub pc14: PC14<Input<Floating>>,
            #[doc = " Pin"]
            pub pc15: PC15<Input<Floating>>,
        }
        impl GpioExt for GPIOC {
            type Parts = Parts;
            fn split(self, ahb: &mut AHB) -> Parts {
                ahb.enr().modify(|_, w| w.iopcen().set_bit());
                ahb.rstr().modify(|_, w| w.iopcrst().set_bit());
                ahb.rstr().modify(|_, w| w.iopcrst().clear_bit());
                Parts {
                    afrh: AFRH { _0: () },
                    afrl: AFRL { _0: () },
                    moder: MODER { _0: () },
                    otyper: OTYPER { _0: () },
                    pupdr: PUPDR { _0: () },
                    pc0: PC0 { _mode: PhantomData },
                    pc1: PC1 { _mode: PhantomData },
                    pc2: PC2 { _mode: PhantomData },
                    pc3: PC3 { _mode: PhantomData },
                    pc4: PC4 { _mode: PhantomData },
                    pc5: PC5 { _mode: PhantomData },
                    pc6: PC6 { _mode: PhantomData },
                    pc7: PC7 { _mode: PhantomData },
                    pc8: PC8 { _mode: PhantomData },
                    pc9: PC9 { _mode: PhantomData },
                    pc10: PC10 { _mode: PhantomData },
                    pc11: PC11 { _mode: PhantomData },
                    pc12: PC12 { _mode: PhantomData },
                    pc13: PC13 { _mode: PhantomData },
                    pc14: PC14 { _mode: PhantomData },
                    pc15: PC15 { _mode: PhantomData },
                }
            }
        }
        #[doc = " Opaque AFRL register"]
        pub struct AFRL {
            _0: (),
        }
        impl AFRL {
            #[allow(dead_code)]
            pub(crate) fn afr(&mut self) -> &gpioc::AFRL {
                unsafe { &(*GPIOC::ptr()).afrl }
            }
        }
        #[doc = " Opaque AFRH register"]
        pub struct AFRH {
            _0: (),
        }
        impl AFRH {
            #[allow(dead_code)]
            pub(crate) fn afr(&mut self) -> &gpioc::AFRH {
                unsafe { &(*GPIOC::ptr()).afrh }
            }
        }
        #[doc = " Opaque MODER register"]
        pub struct MODER {
            _0: (),
        }
        impl MODER {
            pub(crate) fn moder(&mut self) -> &gpioc::MODER {
                unsafe { &(*GPIOC::ptr()).moder }
            }
        }
        #[doc = " Opaque OTYPER register"]
        pub struct OTYPER {
            _0: (),
        }
        impl OTYPER {
            pub(crate) fn otyper(&mut self) -> &gpioc::OTYPER {
                unsafe { &(*GPIOC::ptr()).otyper }
            }
        }
        #[doc = " Opaque PUPDR register"]
        pub struct PUPDR {
            _0: (),
        }
        impl PUPDR {
            pub(crate) fn pupdr(&mut self) -> &gpioc::PUPDR {
                unsafe { &(*GPIOC::ptr()).pupdr }
            }
        }
        #[doc = " Partially erased pin"]
        pub struct PCx<MODE> {
            i: u8,
            _mode: PhantomData<MODE>,
        }
        impl<MODE> PCx<MODE> {
            #[doc = " Erases the port letter from the type"]
            #[doc = ""]
            #[doc = " This is useful when you want to collect the pins into an array where you"]
            #[doc = " need all the elements to have the same type"]
            pub fn downgrade(self) -> PXx<MODE> {
                PXx {
                    i: self.i,
                    gpio: Gpio::GPIOC,
                    _mode: self._mode,
                }
            }
        }
        impl<MODE> OutputPin for PCx<Output<MODE>> {
            type Error = Infallible;
            fn set_high(&mut self) -> Result<(), Self::Error> {
                unsafe { (*GPIOC::ptr()).bsrr.write(|w| w.bits(1 << self.i)) }
                Ok(())
            }
            fn set_low(&mut self) -> Result<(), Self::Error> {
                unsafe { (*GPIOC::ptr()).bsrr.write(|w| w.bits(1 << (16 + self.i))) }
                Ok(())
            }
        }
        #[cfg(feature = "unproven")]
        impl<MODE> InputPin for PCx<Input<MODE>> {
            type Error = Infallible;
            fn is_high(&self) -> Result<bool, Self::Error> {
                Ok(!self.is_low()?)
            }
            fn is_low(&self) -> Result<bool, Self::Error> {
                Ok(unsafe { (*GPIOC::ptr()).idr.read().bits() & (1 << self.i) == 0 })
            }
        }
        #[cfg(feature = "unproven")]
        impl InputPin for PCx<Output<OpenDrain>> {
            type Error = Infallible;
            fn is_high(&self) -> Result<bool, Self::Error> {
                Ok(!self.is_low()?)
            }
            fn is_low(&self) -> Result<bool, Self::Error> {
                Ok(unsafe { (*GPIOC::ptr()).idr.read().bits() & (1 << self.i) == 0 })
            }
        }
        #[cfg(feature = "unproven")]
        impl<MODE> StatefulOutputPin for PCx<Output<MODE>> {
            fn is_set_high(&self) -> Result<bool, Self::Error> {
                self.is_set_low().map(|b| !b)
            }
            fn is_set_low(&self) -> Result<bool, Self::Error> {
                Ok(unsafe { (*GPIOC::ptr()).odr.read().bits() & (1 << self.i) == 0 })
            }
        }
        #[cfg(feature = "unproven")]
        impl<MODE> toggleable::Default for PCx<Output<MODE>> {}
        #[doc = "Pin `PC0`"]
        pub struct PC0<MODE> {
            _mode: PhantomData<MODE>,
        }
        impl<MODE> PC0<MODE> {
            #[doc = "Configures `PC0` to serve as alternate function: `AF1`"]
            pub fn into_af1(self, moder: &mut MODER, afr: &mut AFRL) -> PC0<AF1> {
                moder.moder().modify(|_, w| w.moder0().alternate());
                afr.afr().modify(|_, w| w.afrl0().af1());
                PC0 { _mode: PhantomData }
            }
            #[doc = " Configures the pin to operate as a floating input pin"]
            pub fn into_floating_input(
                self,
                moder: &mut MODER,
                pupdr: &mut PUPDR,
            ) -> PC0<Input<Floating>> {
                moder.moder().modify(|_, w| w.moder0().input());
                pupdr.pupdr().modify(|_, w| w.pupdr0().floating());
                PC0 { _mode: PhantomData }
            }
            #[doc = " Configures the pin to operate as a pulled down input pin"]
            pub fn into_pull_down_input(
                self,
                moder: &mut MODER,
                pupdr: &mut PUPDR,
            ) -> PC0<Input<PullDown>> {
                moder.moder().modify(|_, w| w.moder0().input());
                pupdr.pupdr().modify(|_, w| w.pupdr0().pull_down());
                PC0 { _mode: PhantomData }
            }
            #[doc = " Configures the pin to operate as a pulled up input pin"]
            pub fn into_pull_up_input(
                self,
                moder: &mut MODER,
                pupdr: &mut PUPDR,
            ) -> PC0<Input<PullUp>> {
                moder.moder().modify(|_, w| w.moder0().input());
                pupdr.pupdr().modify(|_, w| w.pupdr0().pull_up());
                PC0 { _mode: PhantomData }
            }
            #[doc = " Configures the pin to operate as an open drain output pin"]
            pub fn into_open_drain_output(
                self,
                moder: &mut MODER,
                otyper: &mut OTYPER,
            ) -> PC0<Output<OpenDrain>> {
                moder.moder().modify(|_, w| w.moder0().output());
                otyper.otyper().modify(|_, w| w.ot0().open_drain());
                PC0 { _mode: PhantomData }
            }
            #[doc = " Configures the pin to operate as an push pull output pin"]
            pub fn into_push_pull_output(
                self,
                moder: &mut MODER,
                otyper: &mut OTYPER,
            ) -> PC0<Output<PushPull>> {
                moder.moder().modify(|_, w| w.moder0().output());
                otyper.otyper().modify(|_, w| w.ot0().push_pull());
                PC0 { _mode: PhantomData }
            }
            #[doc = " Configures the pin to operate as analog, with disabled schmitt trigger."]
            #[doc = " This mode is suitable when the pin is connected to the DAC or ADC."]
            pub fn into_analog(self, moder: &mut MODER, pupdr: &mut PUPDR) -> PC0<Analog> {
                moder.moder().modify(|_, w| w.moder0().analog());
                pupdr.pupdr().modify(|_, w| w.pupdr0().floating());
                PC0 { _mode: PhantomData }
            }
        }
        impl PC0<Output<OpenDrain>> {
            #[doc = " Enables / disables the internal pull up"]
            pub fn internal_pull_up(&mut self, pupdr: &mut PUPDR, on: bool) {
                pupdr.pupdr().modify(|_, w| {
                    if on {
                        w.pupdr0().pull_up()
                    } else {
                        w.pupdr0().floating()
                    }
                });
            }
        }
        impl<MODE> PC0<Output<MODE>> {
            #[doc = " Erases the pin number from the type"]
            #[doc = ""]
            #[doc = " This is useful when you want to collect the pins into an array where you"]
            #[doc = " need all the elements to have the same type"]
            pub fn downgrade(self) -> PCx<Output<MODE>> {
                PCx {
                    i: 0,
                    _mode: self._mode,
                }
            }
        }
        impl<MODE> PC0<Input<MODE>> {
            #[doc = " Erases the pin number from the type"]
            #[doc = ""]
            #[doc = " This is useful when you want to collect the pins into an array where you"]
            #[doc = " need all the elements to have the same type"]
            pub fn downgrade(self) -> PCx<Input<MODE>> {
                PCx {
                    i: 0,
                    _mode: self._mode,
                }
            }
        }
        impl<MODE> OutputPin for PC0<Output<MODE>> {
            type Error = Infallible;
            fn set_high(&mut self) -> Result<(), Self::Error> {
                unsafe { (*GPIOC::ptr()).bsrr.write(|w| w.bs0().set()) }
                Ok(())
            }
            fn set_low(&mut self) -> Result<(), Self::Error> {
                unsafe { (*GPIOC::ptr()).bsrr.write(|w| w.br0().reset()) }
                Ok(())
            }
        }
        #[cfg(feature = "unproven")]
        impl<MODE> InputPin for PC0<Input<MODE>> {
            type Error = Infallible;
            fn is_high(&self) -> Result<bool, Self::Error> {
                Ok(!self.is_low()?)
            }
            fn is_low(&self) -> Result<bool, Self::Error> {
                Ok(unsafe { (*GPIOC::ptr()).idr.read().idr0().is_low() })
            }
        }
        #[cfg(feature = "unproven")]
        impl InputPin for PC0<Output<OpenDrain>> {
            type Error = Infallible;
            fn is_high(&self) -> Result<bool, Self::Error> {
                Ok(!self.is_low()?)
            }
            fn is_low(&self) -> Result<bool, Self::Error> {
                Ok(unsafe { (*GPIOC::ptr()).idr.read().idr0().is_low() })
            }
        }
        #[cfg(feature = "unproven")]
        impl<MODE> StatefulOutputPin for PC0<Output<MODE>> {
            fn is_set_high(&self) -> Result<bool, Self::Error> {
                self.is_set_low().map(|b| !b)
            }
            fn is_set_low(&self) -> Result<bool, Self::Error> {
                Ok(unsafe { (*GPIOC::ptr()).odr.read().odr0().is_low() })
            }
        }
        #[cfg(feature = "unproven")]
        impl<MODE> toggleable::Default for PC0<Output<MODE>> {}
        #[doc = "Pin `PC1`"]
        pub struct PC1<MODE> {
            _mode: PhantomData<MODE>,
        }
        impl<MODE> PC1<MODE> {
            #[doc = "Configures `PC1` to serve as alternate function: `AF1`"]
            pub fn into_af1(self, moder: &mut MODER, afr: &mut AFRL) -> PC1<AF1> {
                moder.moder().modify(|_, w| w.moder1().alternate());
                afr.afr().modify(|_, w| w.afrl1().af1());
                PC1 { _mode: PhantomData }
            }
            #[doc = " Configures the pin to operate as a floating input pin"]
            pub fn into_floating_input(
                self,
                moder: &mut MODER,
                pupdr: &mut PUPDR,
            ) -> PC1<Input<Floating>> {
                moder.moder().modify(|_, w| w.moder1().input());
                pupdr.pupdr().modify(|_, w| w.pupdr1().floating());
                PC1 { _mode: PhantomData }
            }
            #[doc = " Configures the pin to operate as a pulled down input pin"]
            pub fn into_pull_down_input(
                self,
                moder: &mut MODER,
                pupdr: &mut PUPDR,
            ) -> PC1<Input<PullDown>> {
                moder.moder().modify(|_, w| w.moder1().input());
                pupdr.pupdr().modify(|_, w| w.pupdr1().pull_down());
                PC1 { _mode: PhantomData }
            }
            #[doc = " Configures the pin to operate as a pulled up input pin"]
            pub fn into_pull_up_input(
                self,
                moder: &mut MODER,
                pupdr: &mut PUPDR,
            ) -> PC1<Input<PullUp>> {
                moder.moder().modify(|_, w| w.moder1().input());
                pupdr.pupdr().modify(|_, w| w.pupdr1().pull_up());
                PC1 { _mode: PhantomData }
            }
            #[doc = " Configures the pin to operate as an open drain output pin"]
            pub fn into_open_drain_output(
                self,
                moder: &mut MODER,
                otyper: &mut OTYPER,
            ) -> PC1<Output<OpenDrain>> {
                moder.moder().modify(|_, w| w.moder1().output());
                otyper.otyper().modify(|_, w| w.ot1().open_drain());
                PC1 { _mode: PhantomData }
            }
            #[doc = " Configures the pin to operate as an push pull output pin"]
            pub fn into_push_pull_output(
                self,
                moder: &mut MODER,
                otyper: &mut OTYPER,
            ) -> PC1<Output<PushPull>> {
                moder.moder().modify(|_, w| w.moder1().output());
                otyper.otyper().modify(|_, w| w.ot1().push_pull());
                PC1 { _mode: PhantomData }
            }
            #[doc = " Configures the pin to operate as analog, with disabled schmitt trigger."]
            #[doc = " This mode is suitable when the pin is connected to the DAC or ADC."]
            pub fn into_analog(self, moder: &mut MODER, pupdr: &mut PUPDR) -> PC1<Analog> {
                moder.moder().modify(|_, w| w.moder1().analog());
                pupdr.pupdr().modify(|_, w| w.pupdr1().floating());
                PC1 { _mode: PhantomData }
            }
        }
        impl PC1<Output<OpenDrain>> {
            #[doc = " Enables / disables the internal pull up"]
            pub fn internal_pull_up(&mut self, pupdr: &mut PUPDR, on: bool) {
                pupdr.pupdr().modify(|_, w| {
                    if on {
                        w.pupdr1().pull_up()
                    } else {
                        w.pupdr1().floating()
                    }
                });
            }
        }
        impl<MODE> PC1<Output<MODE>> {
            #[doc = " Erases the pin number from the type"]
            #[doc = ""]
            #[doc = " This is useful when you want to collect the pins into an array where you"]
            #[doc = " need all the elements to have the same type"]
            pub fn downgrade(self) -> PCx<Output<MODE>> {
                PCx {
                    i: 1,
                    _mode: self._mode,
                }
            }
        }
        impl<MODE> PC1<Input<MODE>> {
            #[doc = " Erases the pin number from the type"]
            #[doc = ""]
            #[doc = " This is useful when you want to collect the pins into an array where you"]
            #[doc = " need all the elements to have the same type"]
            pub fn downgrade(self) -> PCx<Input<MODE>> {
                PCx {
                    i: 1,
                    _mode: self._mode,
                }
            }
        }
        impl<MODE> OutputPin for PC1<Output<MODE>> {
            type Error = Infallible;
            fn set_high(&mut self) -> Result<(), Self::Error> {
                unsafe { (*GPIOC::ptr()).bsrr.write(|w| w.bs1().set()) }
                Ok(())
            }
            fn set_low(&mut self) -> Result<(), Self::Error> {
                unsafe { (*GPIOC::ptr()).bsrr.write(|w| w.br1().reset()) }
                Ok(())
            }
        }
        #[cfg(feature = "unproven")]
        impl<MODE> InputPin for PC1<Input<MODE>> {
            type Error = Infallible;
            fn is_high(&self) -> Result<bool, Self::Error> {
                Ok(!self.is_low()?)
            }
            fn is_low(&self) -> Result<bool, Self::Error> {
                Ok(unsafe { (*GPIOC::ptr()).idr.read().idr1().is_low() })
            }
        }
        #[cfg(feature = "unproven")]
        impl InputPin for PC1<Output<OpenDrain>> {
            type Error = Infallible;
            fn is_high(&self) -> Result<bool, Self::Error> {
                Ok(!self.is_low()?)
            }
            fn is_low(&self) -> Result<bool, Self::Error> {
                Ok(unsafe { (*GPIOC::ptr()).idr.read().idr1().is_low() })
            }
        }
        #[cfg(feature = "unproven")]
        impl<MODE> StatefulOutputPin for PC1<Output<MODE>> {
            fn is_set_high(&self) -> Result<bool, Self::Error> {
                self.is_set_low().map(|b| !b)
            }
            fn is_set_low(&self) -> Result<bool, Self::Error> {
                Ok(unsafe { (*GPIOC::ptr()).odr.read().odr1().is_low() })
            }
        }
        #[cfg(feature = "unproven")]
        impl<MODE> toggleable::Default for PC1<Output<MODE>> {}
        #[doc = "Pin `PC2`"]
        pub struct PC2<MODE> {
            _mode: PhantomData<MODE>,
        }
        impl<MODE> PC2<MODE> {
            #[doc = "Configures `PC2` to serve as alternate function: `AF1`"]
            pub fn into_af1(self, moder: &mut MODER, afr: &mut AFRL) -> PC2<AF1> {
                moder.moder().modify(|_, w| w.moder2().alternate());
                afr.afr().modify(|_, w| w.afrl2().af1());
                PC2 { _mode: PhantomData }
            }
            #[doc = "Configures `PC2` to serve as alternate function: `AF3`"]
            pub fn into_af3(self, moder: &mut MODER, afr: &mut AFRL) -> PC2<AF3> {
                moder.moder().modify(|_, w| w.moder2().alternate());
                afr.afr().modify(|_, w| w.afrl2().af3());
                PC2 { _mode: PhantomData }
            }
            #[doc = " Configures the pin to operate as a floating input pin"]
            pub fn into_floating_input(
                self,
                moder: &mut MODER,
                pupdr: &mut PUPDR,
            ) -> PC2<Input<Floating>> {
                moder.moder().modify(|_, w| w.moder2().input());
                pupdr.pupdr().modify(|_, w| w.pupdr2().floating());
                PC2 { _mode: PhantomData }
            }
            #[doc = " Configures the pin to operate as a pulled down input pin"]
            pub fn into_pull_down_input(
                self,
                moder: &mut MODER,
                pupdr: &mut PUPDR,
            ) -> PC2<Input<PullDown>> {
                moder.moder().modify(|_, w| w.moder2().input());
                pupdr.pupdr().modify(|_, w| w.pupdr2().pull_down());
                PC2 { _mode: PhantomData }
            }
            #[doc = " Configures the pin to operate as a pulled up input pin"]
            pub fn into_pull_up_input(
                self,
                moder: &mut MODER,
                pupdr: &mut PUPDR,
            ) -> PC2<Input<PullUp>> {
                moder.moder().modify(|_, w| w.moder2().input());
                pupdr.pupdr().modify(|_, w| w.pupdr2().pull_up());
                PC2 { _mode: PhantomData }
            }
            #[doc = " Configures the pin to operate as an open drain output pin"]
            pub fn into_open_drain_output(
                self,
                moder: &mut MODER,
                otyper: &mut OTYPER,
            ) -> PC2<Output<OpenDrain>> {
                moder.moder().modify(|_, w| w.moder2().output());
                otyper.otyper().modify(|_, w| w.ot2().open_drain());
                PC2 { _mode: PhantomData }
            }
            #[doc = " Configures the pin to operate as an push pull output pin"]
            pub fn into_push_pull_output(
                self,
                moder: &mut MODER,
                otyper: &mut OTYPER,
            ) -> PC2<Output<PushPull>> {
                moder.moder().modify(|_, w| w.moder2().output());
                otyper.otyper().modify(|_, w| w.ot2().push_pull());
                PC2 { _mode: PhantomData }
            }
            #[doc = " Configures the pin to operate as analog, with disabled schmitt trigger."]
            #[doc = " This mode is suitable when the pin is connected to the DAC or ADC."]
            pub fn into_analog(self, moder: &mut MODER, pupdr: &mut PUPDR) -> PC2<Analog> {
                moder.moder().modify(|_, w| w.moder2().analog());
                pupdr.pupdr().modify(|_, w| w.pupdr2().floating());
                PC2 { _mode: PhantomData }
            }
        }
        impl PC2<Output<OpenDrain>> {
            #[doc = " Enables / disables the internal pull up"]
            pub fn internal_pull_up(&mut self, pupdr: &mut PUPDR, on: bool) {
                pupdr.pupdr().modify(|_, w| {
                    if on {
                        w.pupdr2().pull_up()
                    } else {
                        w.pupdr2().floating()
                    }
                });
            }
        }
        impl<MODE> PC2<Output<MODE>> {
            #[doc = " Erases the pin number from the type"]
            #[doc = ""]
            #[doc = " This is useful when you want to collect the pins into an array where you"]
            #[doc = " need all the elements to have the same type"]
            pub fn downgrade(self) -> PCx<Output<MODE>> {
                PCx {
                    i: 2,
                    _mode: self._mode,
                }
            }
        }
        impl<MODE> PC2<Input<MODE>> {
            #[doc = " Erases the pin number from the type"]
            #[doc = ""]
            #[doc = " This is useful when you want to collect the pins into an array where you"]
            #[doc = " need all the elements to have the same type"]
            pub fn downgrade(self) -> PCx<Input<MODE>> {
                PCx {
                    i: 2,
                    _mode: self._mode,
                }
            }
        }
        impl<MODE> OutputPin for PC2<Output<MODE>> {
            type Error = Infallible;
            fn set_high(&mut self) -> Result<(), Self::Error> {
                unsafe { (*GPIOC::ptr()).bsrr.write(|w| w.bs2().set()) }
                Ok(())
            }
            fn set_low(&mut self) -> Result<(), Self::Error> {
                unsafe { (*GPIOC::ptr()).bsrr.write(|w| w.br2().reset()) }
                Ok(())
            }
        }
        #[cfg(feature = "unproven")]
        impl<MODE> InputPin for PC2<Input<MODE>> {
            type Error = Infallible;
            fn is_high(&self) -> Result<bool, Self::Error> {
                Ok(!self.is_low()?)
            }
            fn is_low(&self) -> Result<bool, Self::Error> {
                Ok(unsafe { (*GPIOC::ptr()).idr.read().idr2().is_low() })
            }
        }
        #[cfg(feature = "unproven")]
        impl InputPin for PC2<Output<OpenDrain>> {
            type Error = Infallible;
            fn is_high(&self) -> Result<bool, Self::Error> {
                Ok(!self.is_low()?)
            }
            fn is_low(&self) -> Result<bool, Self::Error> {
                Ok(unsafe { (*GPIOC::ptr()).idr.read().idr2().is_low() })
            }
        }
        #[cfg(feature = "unproven")]
        impl<MODE> StatefulOutputPin for PC2<Output<MODE>> {
            fn is_set_high(&self) -> Result<bool, Self::Error> {
                self.is_set_low().map(|b| !b)
            }
            fn is_set_low(&self) -> Result<bool, Self::Error> {
                Ok(unsafe { (*GPIOC::ptr()).odr.read().odr2().is_low() })
            }
        }
        #[cfg(feature = "unproven")]
        impl<MODE> toggleable::Default for PC2<Output<MODE>> {}
        #[doc = "Pin `PC3`"]
        pub struct PC3<MODE> {
            _mode: PhantomData<MODE>,
        }
        impl<MODE> PC3<MODE> {
            #[doc = "Configures `PC3` to serve as alternate function: `AF1`"]
            pub fn into_af1(self, moder: &mut MODER, afr: &mut AFRL) -> PC3<AF1> {
                moder.moder().modify(|_, w| w.moder3().alternate());
                afr.afr().modify(|_, w| w.afrl3().af1());
                PC3 { _mode: PhantomData }
            }
            #[doc = "Configures `PC3` to serve as alternate function: `AF6`"]
            pub fn into_af6(self, moder: &mut MODER, afr: &mut AFRL) -> PC3<AF6> {
                moder.moder().modify(|_, w| w.moder3().alternate());
                afr.afr().modify(|_, w| w.afrl3().af6());
                PC3 { _mode: PhantomData }
            }
            #[doc = " Configures the pin to operate as a floating input pin"]
            pub fn into_floating_input(
                self,
                moder: &mut MODER,
                pupdr: &mut PUPDR,
            ) -> PC3<Input<Floating>> {
                moder.moder().modify(|_, w| w.moder3().input());
                pupdr.pupdr().modify(|_, w| w.pupdr3().floating());
                PC3 { _mode: PhantomData }
            }
            #[doc = " Configures the pin to operate as a pulled down input pin"]
            pub fn into_pull_down_input(
                self,
                moder: &mut MODER,
                pupdr: &mut PUPDR,
            ) -> PC3<Input<PullDown>> {
                moder.moder().modify(|_, w| w.moder3().input());
                pupdr.pupdr().modify(|_, w| w.pupdr3().pull_down());
                PC3 { _mode: PhantomData }
            }
            #[doc = " Configures the pin to operate as a pulled up input pin"]
            pub fn into_pull_up_input(
                self,
                moder: &mut MODER,
                pupdr: &mut PUPDR,
            ) -> PC3<Input<PullUp>> {
                moder.moder().modify(|_, w| w.moder3().input());
                pupdr.pupdr().modify(|_, w| w.pupdr3().pull_up());
                PC3 { _mode: PhantomData }
            }
            #[doc = " Configures the pin to operate as an open drain output pin"]
            pub fn into_open_drain_output(
                self,
                moder: &mut MODER,
                otyper: &mut OTYPER,
            ) -> PC3<Output<OpenDrain>> {
                moder.moder().modify(|_, w| w.moder3().output());
                otyper.otyper().modify(|_, w| w.ot3().open_drain());
                PC3 { _mode: PhantomData }
            }
            #[doc = " Configures the pin to operate as an push pull output pin"]
            pub fn into_push_pull_output(
                self,
                moder: &mut MODER,
                otyper: &mut OTYPER,
            ) -> PC3<Output<PushPull>> {
                moder.moder().modify(|_, w| w.moder3().output());
                otyper.otyper().modify(|_, w| w.ot3().push_pull());
                PC3 { _mode: PhantomData }
            }
            #[doc = " Configures the pin to operate as analog, with disabled schmitt trigger."]
            #[doc = " This mode is suitable when the pin is connected to the DAC or ADC."]
            pub fn into_analog(self, moder: &mut MODER, pupdr: &mut PUPDR) -> PC3<Analog> {
                moder.moder().modify(|_, w| w.moder3().analog());
                pupdr.pupdr().modify(|_, w| w.pupdr3().floating());
                PC3 { _mode: PhantomData }
            }
        }
        impl PC3<Output<OpenDrain>> {
            #[doc = " Enables / disables the internal pull up"]
            pub fn internal_pull_up(&mut self, pupdr: &mut PUPDR, on: bool) {
                pupdr.pupdr().modify(|_, w| {
                    if on {
                        w.pupdr3().pull_up()
                    } else {
                        w.pupdr3().floating()
                    }
                });
            }
        }
        impl<MODE> PC3<Output<MODE>> {
            #[doc = " Erases the pin number from the type"]
            #[doc = ""]
            #[doc = " This is useful when you want to collect the pins into an array where you"]
            #[doc = " need all the elements to have the same type"]
            pub fn downgrade(self) -> PCx<Output<MODE>> {
                PCx {
                    i: 3,
                    _mode: self._mode,
                }
            }
        }
        impl<MODE> PC3<Input<MODE>> {
            #[doc = " Erases the pin number from the type"]
            #[doc = ""]
            #[doc = " This is useful when you want to collect the pins into an array where you"]
            #[doc = " need all the elements to have the same type"]
            pub fn downgrade(self) -> PCx<Input<MODE>> {
                PCx {
                    i: 3,
                    _mode: self._mode,
                }
            }
        }
        impl<MODE> OutputPin for PC3<Output<MODE>> {
            type Error = Infallible;
            fn set_high(&mut self) -> Result<(), Self::Error> {
                unsafe { (*GPIOC::ptr()).bsrr.write(|w| w.bs3().set()) }
                Ok(())
            }
            fn set_low(&mut self) -> Result<(), Self::Error> {
                unsafe { (*GPIOC::ptr()).bsrr.write(|w| w.br3().reset()) }
                Ok(())
            }
        }
        #[cfg(feature = "unproven")]
        impl<MODE> InputPin for PC3<Input<MODE>> {
            type Error = Infallible;
            fn is_high(&self) -> Result<bool, Self::Error> {
                Ok(!self.is_low()?)
            }
            fn is_low(&self) -> Result<bool, Self::Error> {
                Ok(unsafe { (*GPIOC::ptr()).idr.read().idr3().is_low() })
            }
        }
        #[cfg(feature = "unproven")]
        impl InputPin for PC3<Output<OpenDrain>> {
            type Error = Infallible;
            fn is_high(&self) -> Result<bool, Self::Error> {
                Ok(!self.is_low()?)
            }
            fn is_low(&self) -> Result<bool, Self::Error> {
                Ok(unsafe { (*GPIOC::ptr()).idr.read().idr3().is_low() })
            }
        }
        #[cfg(feature = "unproven")]
        impl<MODE> StatefulOutputPin for PC3<Output<MODE>> {
            fn is_set_high(&self) -> Result<bool, Self::Error> {
                self.is_set_low().map(|b| !b)
            }
            fn is_set_low(&self) -> Result<bool, Self::Error> {
                Ok(unsafe { (*GPIOC::ptr()).odr.read().odr3().is_low() })
            }
        }
        #[cfg(feature = "unproven")]
        impl<MODE> toggleable::Default for PC3<Output<MODE>> {}
        #[doc = "Pin `PC4`"]
        pub struct PC4<MODE> {
            _mode: PhantomData<MODE>,
        }
        impl<MODE> PC4<MODE> {
            #[doc = "Configures `PC4` to serve as alternate function: `AF1`"]
            pub fn into_af1(self, moder: &mut MODER, afr: &mut AFRL) -> PC4<AF1> {
                moder.moder().modify(|_, w| w.moder4().alternate());
                afr.afr().modify(|_, w| w.afrl4().af1());
                PC4 { _mode: PhantomData }
            }
            #[doc = "Configures `PC4` to serve as alternate function: `AF7`"]
            pub fn into_af7(self, moder: &mut MODER, afr: &mut AFRL) -> PC4<AF7> {
                moder.moder().modify(|_, w| w.moder4().alternate());
                afr.afr().modify(|_, w| w.afrl4().af7());
                PC4 { _mode: PhantomData }
            }
            #[doc = " Configures the pin to operate as a floating input pin"]
            pub fn into_floating_input(
                self,
                moder: &mut MODER,
                pupdr: &mut PUPDR,
            ) -> PC4<Input<Floating>> {
                moder.moder().modify(|_, w| w.moder4().input());
                pupdr.pupdr().modify(|_, w| w.pupdr4().floating());
                PC4 { _mode: PhantomData }
            }
            #[doc = " Configures the pin to operate as a pulled down input pin"]
            pub fn into_pull_down_input(
                self,
                moder: &mut MODER,
                pupdr: &mut PUPDR,
            ) -> PC4<Input<PullDown>> {
                moder.moder().modify(|_, w| w.moder4().input());
                pupdr.pupdr().modify(|_, w| w.pupdr4().pull_down());
                PC4 { _mode: PhantomData }
            }
            #[doc = " Configures the pin to operate as a pulled up input pin"]
            pub fn into_pull_up_input(
                self,
                moder: &mut MODER,
                pupdr: &mut PUPDR,
            ) -> PC4<Input<PullUp>> {
                moder.moder().modify(|_, w| w.moder4().input());
                pupdr.pupdr().modify(|_, w| w.pupdr4().pull_up());
                PC4 { _mode: PhantomData }
            }
            #[doc = " Configures the pin to operate as an open drain output pin"]
            pub fn into_open_drain_output(
                self,
                moder: &mut MODER,
                otyper: &mut OTYPER,
            ) -> PC4<Output<OpenDrain>> {
                moder.moder().modify(|_, w| w.moder4().output());
                otyper.otyper().modify(|_, w| w.ot4().open_drain());
                PC4 { _mode: PhantomData }
            }
            #[doc = " Configures the pin to operate as an push pull output pin"]
            pub fn into_push_pull_output(
                self,
                moder: &mut MODER,
                otyper: &mut OTYPER,
            ) -> PC4<Output<PushPull>> {
                moder.moder().modify(|_, w| w.moder4().output());
                otyper.otyper().modify(|_, w| w.ot4().push_pull());
                PC4 { _mode: PhantomData }
            }
            #[doc = " Configures the pin to operate as analog, with disabled schmitt trigger."]
            #[doc = " This mode is suitable when the pin is connected to the DAC or ADC."]
            pub fn into_analog(self, moder: &mut MODER, pupdr: &mut PUPDR) -> PC4<Analog> {
                moder.moder().modify(|_, w| w.moder4().analog());
                pupdr.pupdr().modify(|_, w| w.pupdr4().floating());
                PC4 { _mode: PhantomData }
            }
        }
        impl PC4<Output<OpenDrain>> {
            #[doc = " Enables / disables the internal pull up"]
            pub fn internal_pull_up(&mut self, pupdr: &mut PUPDR, on: bool) {
                pupdr.pupdr().modify(|_, w| {
                    if on {
                        w.pupdr4().pull_up()
                    } else {
                        w.pupdr4().floating()
                    }
                });
            }
        }
        impl<MODE> PC4<Output<MODE>> {
            #[doc = " Erases the pin number from the type"]
            #[doc = ""]
            #[doc = " This is useful when you want to collect the pins into an array where you"]
            #[doc = " need all the elements to have the same type"]
            pub fn downgrade(self) -> PCx<Output<MODE>> {
                PCx {
                    i: 4,
                    _mode: self._mode,
                }
            }
        }
        impl<MODE> PC4<Input<MODE>> {
            #[doc = " Erases the pin number from the type"]
            #[doc = ""]
            #[doc = " This is useful when you want to collect the pins into an array where you"]
            #[doc = " need all the elements to have the same type"]
            pub fn downgrade(self) -> PCx<Input<MODE>> {
                PCx {
                    i: 4,
                    _mode: self._mode,
                }
            }
        }
        impl<MODE> OutputPin for PC4<Output<MODE>> {
            type Error = Infallible;
            fn set_high(&mut self) -> Result<(), Self::Error> {
                unsafe { (*GPIOC::ptr()).bsrr.write(|w| w.bs4().set()) }
                Ok(())
            }
            fn set_low(&mut self) -> Result<(), Self::Error> {
                unsafe { (*GPIOC::ptr()).bsrr.write(|w| w.br4().reset()) }
                Ok(())
            }
        }
        #[cfg(feature = "unproven")]
        impl<MODE> InputPin for PC4<Input<MODE>> {
            type Error = Infallible;
            fn is_high(&self) -> Result<bool, Self::Error> {
                Ok(!self.is_low()?)
            }
            fn is_low(&self) -> Result<bool, Self::Error> {
                Ok(unsafe { (*GPIOC::ptr()).idr.read().idr4().is_low() })
            }
        }
        #[cfg(feature = "unproven")]
        impl InputPin for PC4<Output<OpenDrain>> {
            type Error = Infallible;
            fn is_high(&self) -> Result<bool, Self::Error> {
                Ok(!self.is_low()?)
            }
            fn is_low(&self) -> Result<bool, Self::Error> {
                Ok(unsafe { (*GPIOC::ptr()).idr.read().idr4().is_low() })
            }
        }
        #[cfg(feature = "unproven")]
        impl<MODE> StatefulOutputPin for PC4<Output<MODE>> {
            fn is_set_high(&self) -> Result<bool, Self::Error> {
                self.is_set_low().map(|b| !b)
            }
            fn is_set_low(&self) -> Result<bool, Self::Error> {
                Ok(unsafe { (*GPIOC::ptr()).odr.read().odr4().is_low() })
            }
        }
        #[cfg(feature = "unproven")]
        impl<MODE> toggleable::Default for PC4<Output<MODE>> {}
        #[doc = "Pin `PC5`"]
        pub struct PC5<MODE> {
            _mode: PhantomData<MODE>,
        }
        impl<MODE> PC5<MODE> {
            #[doc = "Configures `PC5` to serve as alternate function: `AF1`"]
            pub fn into_af1(self, moder: &mut MODER, afr: &mut AFRL) -> PC5<AF1> {
                moder.moder().modify(|_, w| w.moder5().alternate());
                afr.afr().modify(|_, w| w.afrl5().af1());
                PC5 { _mode: PhantomData }
            }
            #[doc = "Configures `PC5` to serve as alternate function: `AF3`"]
            pub fn into_af3(self, moder: &mut MODER, afr: &mut AFRL) -> PC5<AF3> {
                moder.moder().modify(|_, w| w.moder5().alternate());
                afr.afr().modify(|_, w| w.afrl5().af3());
                PC5 { _mode: PhantomData }
            }
            #[doc = "Configures `PC5` to serve as alternate function: `AF7`"]
            pub fn into_af7(self, moder: &mut MODER, afr: &mut AFRL) -> PC5<AF7> {
                moder.moder().modify(|_, w| w.moder5().alternate());
                afr.afr().modify(|_, w| w.afrl5().af7());
                PC5 { _mode: PhantomData }
            }
            #[doc = " Configures the pin to operate as a floating input pin"]
            pub fn into_floating_input(
                self,
                moder: &mut MODER,
                pupdr: &mut PUPDR,
            ) -> PC5<Input<Floating>> {
                moder.moder().modify(|_, w| w.moder5().input());
                pupdr.pupdr().modify(|_, w| w.pupdr5().floating());
                PC5 { _mode: PhantomData }
            }
            #[doc = " Configures the pin to operate as a pulled down input pin"]
            pub fn into_pull_down_input(
                self,
                moder: &mut MODER,
                pupdr: &mut PUPDR,
            ) -> PC5<Input<PullDown>> {
                moder.moder().modify(|_, w| w.moder5().input());
                pupdr.pupdr().modify(|_, w| w.pupdr5().pull_down());
                PC5 { _mode: PhantomData }
            }
            #[doc = " Configures the pin to operate as a pulled up input pin"]
            pub fn into_pull_up_input(
                self,
                moder: &mut MODER,
                pupdr: &mut PUPDR,
            ) -> PC5<Input<PullUp>> {
                moder.moder().modify(|_, w| w.moder5().input());
                pupdr.pupdr().modify(|_, w| w.pupdr5().pull_up());
                PC5 { _mode: PhantomData }
            }
            #[doc = " Configures the pin to operate as an open drain output pin"]
            pub fn into_open_drain_output(
                self,
                moder: &mut MODER,
                otyper: &mut OTYPER,
            ) -> PC5<Output<OpenDrain>> {
                moder.moder().modify(|_, w| w.moder5().output());
                otyper.otyper().modify(|_, w| w.ot5().open_drain());
                PC5 { _mode: PhantomData }
            }
            #[doc = " Configures the pin to operate as an push pull output pin"]
            pub fn into_push_pull_output(
                self,
                moder: &mut MODER,
                otyper: &mut OTYPER,
            ) -> PC5<Output<PushPull>> {
                moder.moder().modify(|_, w| w.moder5().output());
                otyper.otyper().modify(|_, w| w.ot5().push_pull());
                PC5 { _mode: PhantomData }
            }
            #[doc = " Configures the pin to operate as analog, with disabled schmitt trigger."]
            #[doc = " This mode is suitable when the pin is connected to the DAC or ADC."]
            pub fn into_analog(self, moder: &mut MODER, pupdr: &mut PUPDR) -> PC5<Analog> {
                moder.moder().modify(|_, w| w.moder5().analog());
                pupdr.pupdr().modify(|_, w| w.pupdr5().floating());
                PC5 { _mode: PhantomData }
            }
        }
        impl PC5<Output<OpenDrain>> {
            #[doc = " Enables / disables the internal pull up"]
            pub fn internal_pull_up(&mut self, pupdr: &mut PUPDR, on: bool) {
                pupdr.pupdr().modify(|_, w| {
                    if on {
                        w.pupdr5().pull_up()
                    } else {
                        w.pupdr5().floating()
                    }
                });
            }
        }
        impl<MODE> PC5<Output<MODE>> {
            #[doc = " Erases the pin number from the type"]
            #[doc = ""]
            #[doc = " This is useful when you want to collect the pins into an array where you"]
            #[doc = " need all the elements to have the same type"]
            pub fn downgrade(self) -> PCx<Output<MODE>> {
                PCx {
                    i: 5,
                    _mode: self._mode,
                }
            }
        }
        impl<MODE> PC5<Input<MODE>> {
            #[doc = " Erases the pin number from the type"]
            #[doc = ""]
            #[doc = " This is useful when you want to collect the pins into an array where you"]
            #[doc = " need all the elements to have the same type"]
            pub fn downgrade(self) -> PCx<Input<MODE>> {
                PCx {
                    i: 5,
                    _mode: self._mode,
                }
            }
        }
        impl<MODE> OutputPin for PC5<Output<MODE>> {
            type Error = Infallible;
            fn set_high(&mut self) -> Result<(), Self::Error> {
                unsafe { (*GPIOC::ptr()).bsrr.write(|w| w.bs5().set()) }
                Ok(())
            }
            fn set_low(&mut self) -> Result<(), Self::Error> {
                unsafe { (*GPIOC::ptr()).bsrr.write(|w| w.br5().reset()) }
                Ok(())
            }
        }
        #[cfg(feature = "unproven")]
        impl<MODE> InputPin for PC5<Input<MODE>> {
            type Error = Infallible;
            fn is_high(&self) -> Result<bool, Self::Error> {
                Ok(!self.is_low()?)
            }
            fn is_low(&self) -> Result<bool, Self::Error> {
                Ok(unsafe { (*GPIOC::ptr()).idr.read().idr5().is_low() })
            }
        }
        #[cfg(feature = "unproven")]
        impl InputPin for PC5<Output<OpenDrain>> {
            type Error = Infallible;
            fn is_high(&self) -> Result<bool, Self::Error> {
                Ok(!self.is_low()?)
            }
            fn is_low(&self) -> Result<bool, Self::Error> {
                Ok(unsafe { (*GPIOC::ptr()).idr.read().idr5().is_low() })
            }
        }
        #[cfg(feature = "unproven")]
        impl<MODE> StatefulOutputPin for PC5<Output<MODE>> {
            fn is_set_high(&self) -> Result<bool, Self::Error> {
                self.is_set_low().map(|b| !b)
            }
            fn is_set_low(&self) -> Result<bool, Self::Error> {
                Ok(unsafe { (*GPIOC::ptr()).odr.read().odr5().is_low() })
            }
        }
        #[cfg(feature = "unproven")]
        impl<MODE> toggleable::Default for PC5<Output<MODE>> {}
        #[doc = "Pin `PC6`"]
        pub struct PC6<MODE> {
            _mode: PhantomData<MODE>,
        }
        impl<MODE> PC6<MODE> {
            #[doc = "Configures `PC6` to serve as alternate function: `AF1`"]
            pub fn into_af1(self, moder: &mut MODER, afr: &mut AFRL) -> PC6<AF1> {
                moder.moder().modify(|_, w| w.moder6().alternate());
                afr.afr().modify(|_, w| w.afrl6().af1());
                PC6 { _mode: PhantomData }
            }
            #[doc = "Configures `PC6` to serve as alternate function: `AF2`"]
            pub fn into_af2(self, moder: &mut MODER, afr: &mut AFRL) -> PC6<AF2> {
                moder.moder().modify(|_, w| w.moder6().alternate());
                afr.afr().modify(|_, w| w.afrl6().af2());
                PC6 { _mode: PhantomData }
            }
            #[doc = "Configures `PC6` to serve as alternate function: `AF4`"]
            pub fn into_af4(self, moder: &mut MODER, afr: &mut AFRL) -> PC6<AF4> {
                moder.moder().modify(|_, w| w.moder6().alternate());
                afr.afr().modify(|_, w| w.afrl6().af4());
                PC6 { _mode: PhantomData }
            }
            #[doc = "Configures `PC6` to serve as alternate function: `AF6`"]
            pub fn into_af6(self, moder: &mut MODER, afr: &mut AFRL) -> PC6<AF6> {
                moder.moder().modify(|_, w| w.moder6().alternate());
                afr.afr().modify(|_, w| w.afrl6().af6());
                PC6 { _mode: PhantomData }
            }
            #[doc = "Configures `PC6` to serve as alternate function: `AF7`"]
            pub fn into_af7(self, moder: &mut MODER, afr: &mut AFRL) -> PC6<AF7> {
                moder.moder().modify(|_, w| w.moder6().alternate());
                afr.afr().modify(|_, w| w.afrl6().af7());
                PC6 { _mode: PhantomData }
            }
            #[doc = " Configures the pin to operate as a floating input pin"]
            pub fn into_floating_input(
                self,
                moder: &mut MODER,
                pupdr: &mut PUPDR,
            ) -> PC6<Input<Floating>> {
                moder.moder().modify(|_, w| w.moder6().input());
                pupdr.pupdr().modify(|_, w| w.pupdr6().floating());
                PC6 { _mode: PhantomData }
            }
            #[doc = " Configures the pin to operate as a pulled down input pin"]
            pub fn into_pull_down_input(
                self,
                moder: &mut MODER,
                pupdr: &mut PUPDR,
            ) -> PC6<Input<PullDown>> {
                moder.moder().modify(|_, w| w.moder6().input());
                pupdr.pupdr().modify(|_, w| w.pupdr6().pull_down());
                PC6 { _mode: PhantomData }
            }
            #[doc = " Configures the pin to operate as a pulled up input pin"]
            pub fn into_pull_up_input(
                self,
                moder: &mut MODER,
                pupdr: &mut PUPDR,
            ) -> PC6<Input<PullUp>> {
                moder.moder().modify(|_, w| w.moder6().input());
                pupdr.pupdr().modify(|_, w| w.pupdr6().pull_up());
                PC6 { _mode: PhantomData }
            }
            #[doc = " Configures the pin to operate as an open drain output pin"]
            pub fn into_open_drain_output(
                self,
                moder: &mut MODER,
                otyper: &mut OTYPER,
            ) -> PC6<Output<OpenDrain>> {
                moder.moder().modify(|_, w| w.moder6().output());
                otyper.otyper().modify(|_, w| w.ot6().open_drain());
                PC6 { _mode: PhantomData }
            }
            #[doc = " Configures the pin to operate as an push pull output pin"]
            pub fn into_push_pull_output(
                self,
                moder: &mut MODER,
                otyper: &mut OTYPER,
            ) -> PC6<Output<PushPull>> {
                moder.moder().modify(|_, w| w.moder6().output());
                otyper.otyper().modify(|_, w| w.ot6().push_pull());
                PC6 { _mode: PhantomData }
            }
            #[doc = " Configures the pin to operate as analog, with disabled schmitt trigger."]
            #[doc = " This mode is suitable when the pin is connected to the DAC or ADC."]
            pub fn into_analog(self, moder: &mut MODER, pupdr: &mut PUPDR) -> PC6<Analog> {
                moder.moder().modify(|_, w| w.moder6().analog());
                pupdr.pupdr().modify(|_, w| w.pupdr6().floating());
                PC6 { _mode: PhantomData }
            }
        }
        impl PC6<Output<OpenDrain>> {
            #[doc = " Enables / disables the internal pull up"]
            pub fn internal_pull_up(&mut self, pupdr: &mut PUPDR, on: bool) {
                pupdr.pupdr().modify(|_, w| {
                    if on {
                        w.pupdr6().pull_up()
                    } else {
                        w.pupdr6().floating()
                    }
                });
            }
        }
        impl<MODE> PC6<Output<MODE>> {
            #[doc = " Erases the pin number from the type"]
            #[doc = ""]
            #[doc = " This is useful when you want to collect the pins into an array where you"]
            #[doc = " need all the elements to have the same type"]
            pub fn downgrade(self) -> PCx<Output<MODE>> {
                PCx {
                    i: 6,
                    _mode: self._mode,
                }
            }
        }
        impl<MODE> PC6<Input<MODE>> {
            #[doc = " Erases the pin number from the type"]
            #[doc = ""]
            #[doc = " This is useful when you want to collect the pins into an array where you"]
            #[doc = " need all the elements to have the same type"]
            pub fn downgrade(self) -> PCx<Input<MODE>> {
                PCx {
                    i: 6,
                    _mode: self._mode,
                }
            }
        }
        impl<MODE> OutputPin for PC6<Output<MODE>> {
            type Error = Infallible;
            fn set_high(&mut self) -> Result<(), Self::Error> {
                unsafe { (*GPIOC::ptr()).bsrr.write(|w| w.bs6().set()) }
                Ok(())
            }
            fn set_low(&mut self) -> Result<(), Self::Error> {
                unsafe { (*GPIOC::ptr()).bsrr.write(|w| w.br6().reset()) }
                Ok(())
            }
        }
        #[cfg(feature = "unproven")]
        impl<MODE> InputPin for PC6<Input<MODE>> {
            type Error = Infallible;
            fn is_high(&self) -> Result<bool, Self::Error> {
                Ok(!self.is_low()?)
            }
            fn is_low(&self) -> Result<bool, Self::Error> {
                Ok(unsafe { (*GPIOC::ptr()).idr.read().idr6().is_low() })
            }
        }
        #[cfg(feature = "unproven")]
        impl InputPin for PC6<Output<OpenDrain>> {
            type Error = Infallible;
            fn is_high(&self) -> Result<bool, Self::Error> {
                Ok(!self.is_low()?)
            }
            fn is_low(&self) -> Result<bool, Self::Error> {
                Ok(unsafe { (*GPIOC::ptr()).idr.read().idr6().is_low() })
            }
        }
        #[cfg(feature = "unproven")]
        impl<MODE> StatefulOutputPin for PC6<Output<MODE>> {
            fn is_set_high(&self) -> Result<bool, Self::Error> {
                self.is_set_low().map(|b| !b)
            }
            fn is_set_low(&self) -> Result<bool, Self::Error> {
                Ok(unsafe { (*GPIOC::ptr()).odr.read().odr6().is_low() })
            }
        }
        #[cfg(feature = "unproven")]
        impl<MODE> toggleable::Default for PC6<Output<MODE>> {}
        #[doc = "Pin `PC7`"]
        pub struct PC7<MODE> {
            _mode: PhantomData<MODE>,
        }
        impl<MODE> PC7<MODE> {
            #[doc = "Configures `PC7` to serve as alternate function: `AF1`"]
            pub fn into_af1(self, moder: &mut MODER, afr: &mut AFRL) -> PC7<AF1> {
                moder.moder().modify(|_, w| w.moder7().alternate());
                afr.afr().modify(|_, w| w.afrl7().af1());
                PC7 { _mode: PhantomData }
            }
            #[doc = "Configures `PC7` to serve as alternate function: `AF2`"]
            pub fn into_af2(self, moder: &mut MODER, afr: &mut AFRL) -> PC7<AF2> {
                moder.moder().modify(|_, w| w.moder7().alternate());
                afr.afr().modify(|_, w| w.afrl7().af2());
                PC7 { _mode: PhantomData }
            }
            #[doc = "Configures `PC7` to serve as alternate function: `AF4`"]
            pub fn into_af4(self, moder: &mut MODER, afr: &mut AFRL) -> PC7<AF4> {
                moder.moder().modify(|_, w| w.moder7().alternate());
                afr.afr().modify(|_, w| w.afrl7().af4());
                PC7 { _mode: PhantomData }
            }
            #[doc = "Configures `PC7` to serve as alternate function: `AF6`"]
            pub fn into_af6(self, moder: &mut MODER, afr: &mut AFRL) -> PC7<AF6> {
                moder.moder().modify(|_, w| w.moder7().alternate());
                afr.afr().modify(|_, w| w.afrl7().af6());
                PC7 { _mode: PhantomData }
            }
            #[doc = "Configures `PC7` to serve as alternate function: `AF7`"]
            pub fn into_af7(self, moder: &mut MODER, afr: &mut AFRL) -> PC7<AF7> {
                moder.moder().modify(|_, w| w.moder7().alternate());
                afr.afr().modify(|_, w| w.afrl7().af7());
                PC7 { _mode: PhantomData }
            }
            #[doc = " Configures the pin to operate as a floating input pin"]
            pub fn into_floating_input(
                self,
                moder: &mut MODER,
                pupdr: &mut PUPDR,
            ) -> PC7<Input<Floating>> {
                moder.moder().modify(|_, w| w.moder7().input());
                pupdr.pupdr().modify(|_, w| w.pupdr7().floating());
                PC7 { _mode: PhantomData }
            }
            #[doc = " Configures the pin to operate as a pulled down input pin"]
            pub fn into_pull_down_input(
                self,
                moder: &mut MODER,
                pupdr: &mut PUPDR,
            ) -> PC7<Input<PullDown>> {
                moder.moder().modify(|_, w| w.moder7().input());
                pupdr.pupdr().modify(|_, w| w.pupdr7().pull_down());
                PC7 { _mode: PhantomData }
            }
            #[doc = " Configures the pin to operate as a pulled up input pin"]
            pub fn into_pull_up_input(
                self,
                moder: &mut MODER,
                pupdr: &mut PUPDR,
            ) -> PC7<Input<PullUp>> {
                moder.moder().modify(|_, w| w.moder7().input());
                pupdr.pupdr().modify(|_, w| w.pupdr7().pull_up());
                PC7 { _mode: PhantomData }
            }
            #[doc = " Configures the pin to operate as an open drain output pin"]
            pub fn into_open_drain_output(
                self,
                moder: &mut MODER,
                otyper: &mut OTYPER,
            ) -> PC7<Output<OpenDrain>> {
                moder.moder().modify(|_, w| w.moder7().output());
                otyper.otyper().modify(|_, w| w.ot7().open_drain());
                PC7 { _mode: PhantomData }
            }
            #[doc = " Configures the pin to operate as an push pull output pin"]
            pub fn into_push_pull_output(
                self,
                moder: &mut MODER,
                otyper: &mut OTYPER,
            ) -> PC7<Output<PushPull>> {
                moder.moder().modify(|_, w| w.moder7().output());
                otyper.otyper().modify(|_, w| w.ot7().push_pull());
                PC7 { _mode: PhantomData }
            }
            #[doc = " Configures the pin to operate as analog, with disabled schmitt trigger."]
            #[doc = " This mode is suitable when the pin is connected to the DAC or ADC."]
            pub fn into_analog(self, moder: &mut MODER, pupdr: &mut PUPDR) -> PC7<Analog> {
                moder.moder().modify(|_, w| w.moder7().analog());
                pupdr.pupdr().modify(|_, w| w.pupdr7().floating());
                PC7 { _mode: PhantomData }
            }
        }
        impl PC7<Output<OpenDrain>> {
            #[doc = " Enables / disables the internal pull up"]
            pub fn internal_pull_up(&mut self, pupdr: &mut PUPDR, on: bool) {
                pupdr.pupdr().modify(|_, w| {
                    if on {
                        w.pupdr7().pull_up()
                    } else {
                        w.pupdr7().floating()
                    }
                });
            }
        }
        impl<MODE> PC7<Output<MODE>> {
            #[doc = " Erases the pin number from the type"]
            #[doc = ""]
            #[doc = " This is useful when you want to collect the pins into an array where you"]
            #[doc = " need all the elements to have the same type"]
            pub fn downgrade(self) -> PCx<Output<MODE>> {
                PCx {
                    i: 7,
                    _mode: self._mode,
                }
            }
        }
        impl<MODE> PC7<Input<MODE>> {
            #[doc = " Erases the pin number from the type"]
            #[doc = ""]
            #[doc = " This is useful when you want to collect the pins into an array where you"]
            #[doc = " need all the elements to have the same type"]
            pub fn downgrade(self) -> PCx<Input<MODE>> {
                PCx {
                    i: 7,
                    _mode: self._mode,
                }
            }
        }
        impl<MODE> OutputPin for PC7<Output<MODE>> {
            type Error = Infallible;
            fn set_high(&mut self) -> Result<(), Self::Error> {
                unsafe { (*GPIOC::ptr()).bsrr.write(|w| w.bs7().set()) }
                Ok(())
            }
            fn set_low(&mut self) -> Result<(), Self::Error> {
                unsafe { (*GPIOC::ptr()).bsrr.write(|w| w.br7().reset()) }
                Ok(())
            }
        }
        #[cfg(feature = "unproven")]
        impl<MODE> InputPin for PC7<Input<MODE>> {
            type Error = Infallible;
            fn is_high(&self) -> Result<bool, Self::Error> {
                Ok(!self.is_low()?)
            }
            fn is_low(&self) -> Result<bool, Self::Error> {
                Ok(unsafe { (*GPIOC::ptr()).idr.read().idr7().is_low() })
            }
        }
        #[cfg(feature = "unproven")]
        impl InputPin for PC7<Output<OpenDrain>> {
            type Error = Infallible;
            fn is_high(&self) -> Result<bool, Self::Error> {
                Ok(!self.is_low()?)
            }
            fn is_low(&self) -> Result<bool, Self::Error> {
                Ok(unsafe { (*GPIOC::ptr()).idr.read().idr7().is_low() })
            }
        }
        #[cfg(feature = "unproven")]
        impl<MODE> StatefulOutputPin for PC7<Output<MODE>> {
            fn is_set_high(&self) -> Result<bool, Self::Error> {
                self.is_set_low().map(|b| !b)
            }
            fn is_set_low(&self) -> Result<bool, Self::Error> {
                Ok(unsafe { (*GPIOC::ptr()).odr.read().odr7().is_low() })
            }
        }
        #[cfg(feature = "unproven")]
        impl<MODE> toggleable::Default for PC7<Output<MODE>> {}
        #[doc = "Pin `PC8`"]
        pub struct PC8<MODE> {
            _mode: PhantomData<MODE>,
        }
        impl<MODE> PC8<MODE> {
            #[doc = "Configures `PC8` to serve as alternate function: `AF1`"]
            pub fn into_af1(self, moder: &mut MODER, afr: &mut AFRH) -> PC8<AF1> {
                moder.moder().modify(|_, w| w.moder8().alternate());
                afr.afr().modify(|_, w| w.afrh8().af1());
                PC8 { _mode: PhantomData }
            }
            #[doc = "Configures `PC8` to serve as alternate function: `AF2`"]
            pub fn into_af2(self, moder: &mut MODER, afr: &mut AFRH) -> PC8<AF2> {
                moder.moder().modify(|_, w| w.moder8().alternate());
                afr.afr().modify(|_, w| w.afrh8().af2());
                PC8 { _mode: PhantomData }
            }
            #[doc = "Configures `PC8` to serve as alternate function: `AF4`"]
            pub fn into_af4(self, moder: &mut MODER, afr: &mut AFRH) -> PC8<AF4> {
                moder.moder().modify(|_, w| w.moder8().alternate());
                afr.afr().modify(|_, w| w.afrh8().af4());
                PC8 { _mode: PhantomData }
            }
            #[doc = "Configures `PC8` to serve as alternate function: `AF7`"]
            pub fn into_af7(self, moder: &mut MODER, afr: &mut AFRH) -> PC8<AF7> {
                moder.moder().modify(|_, w| w.moder8().alternate());
                afr.afr().modify(|_, w| w.afrh8().af7());
                PC8 { _mode: PhantomData }
            }
            #[doc = " Configures the pin to operate as a floating input pin"]
            pub fn into_floating_input(
                self,
                moder: &mut MODER,
                pupdr: &mut PUPDR,
            ) -> PC8<Input<Floating>> {
                moder.moder().modify(|_, w| w.moder8().input());
                pupdr.pupdr().modify(|_, w| w.pupdr8().floating());
                PC8 { _mode: PhantomData }
            }
            #[doc = " Configures the pin to operate as a pulled down input pin"]
            pub fn into_pull_down_input(
                self,
                moder: &mut MODER,
                pupdr: &mut PUPDR,
            ) -> PC8<Input<PullDown>> {
                moder.moder().modify(|_, w| w.moder8().input());
                pupdr.pupdr().modify(|_, w| w.pupdr8().pull_down());
                PC8 { _mode: PhantomData }
            }
            #[doc = " Configures the pin to operate as a pulled up input pin"]
            pub fn into_pull_up_input(
                self,
                moder: &mut MODER,
                pupdr: &mut PUPDR,
            ) -> PC8<Input<PullUp>> {
                moder.moder().modify(|_, w| w.moder8().input());
                pupdr.pupdr().modify(|_, w| w.pupdr8().pull_up());
                PC8 { _mode: PhantomData }
            }
            #[doc = " Configures the pin to operate as an open drain output pin"]
            pub fn into_open_drain_output(
                self,
                moder: &mut MODER,
                otyper: &mut OTYPER,
            ) -> PC8<Output<OpenDrain>> {
                moder.moder().modify(|_, w| w.moder8().output());
                otyper.otyper().modify(|_, w| w.ot8().open_drain());
                PC8 { _mode: PhantomData }
            }
            #[doc = " Configures the pin to operate as an push pull output pin"]
            pub fn into_push_pull_output(
                self,
                moder: &mut MODER,
                otyper: &mut OTYPER,
            ) -> PC8<Output<PushPull>> {
                moder.moder().modify(|_, w| w.moder8().output());
                otyper.otyper().modify(|_, w| w.ot8().push_pull());
                PC8 { _mode: PhantomData }
            }
            #[doc = " Configures the pin to operate as analog, with disabled schmitt trigger."]
            #[doc = " This mode is suitable when the pin is connected to the DAC or ADC."]
            pub fn into_analog(self, moder: &mut MODER, pupdr: &mut PUPDR) -> PC8<Analog> {
                moder.moder().modify(|_, w| w.moder8().analog());
                pupdr.pupdr().modify(|_, w| w.pupdr8().floating());
                PC8 { _mode: PhantomData }
            }
        }
        impl PC8<Output<OpenDrain>> {
            #[doc = " Enables / disables the internal pull up"]
            pub fn internal_pull_up(&mut self, pupdr: &mut PUPDR, on: bool) {
                pupdr.pupdr().modify(|_, w| {
                    if on {
                        w.pupdr8().pull_up()
                    } else {
                        w.pupdr8().floating()
                    }
                });
            }
        }
        impl<MODE> PC8<Output<MODE>> {
            #[doc = " Erases the pin number from the type"]
            #[doc = ""]
            #[doc = " This is useful when you want to collect the pins into an array where you"]
            #[doc = " need all the elements to have the same type"]
            pub fn downgrade(self) -> PCx<Output<MODE>> {
                PCx {
                    i: 8,
                    _mode: self._mode,
                }
            }
        }
        impl<MODE> PC8<Input<MODE>> {
            #[doc = " Erases the pin number from the type"]
            #[doc = ""]
            #[doc = " This is useful when you want to collect the pins into an array where you"]
            #[doc = " need all the elements to have the same type"]
            pub fn downgrade(self) -> PCx<Input<MODE>> {
                PCx {
                    i: 8,
                    _mode: self._mode,
                }
            }
        }
        impl<MODE> OutputPin for PC8<Output<MODE>> {
            type Error = Infallible;
            fn set_high(&mut self) -> Result<(), Self::Error> {
                unsafe { (*GPIOC::ptr()).bsrr.write(|w| w.bs8().set()) }
                Ok(())
            }
            fn set_low(&mut self) -> Result<(), Self::Error> {
                unsafe { (*GPIOC::ptr()).bsrr.write(|w| w.br8().reset()) }
                Ok(())
            }
        }
        #[cfg(feature = "unproven")]
        impl<MODE> InputPin for PC8<Input<MODE>> {
            type Error = Infallible;
            fn is_high(&self) -> Result<bool, Self::Error> {
                Ok(!self.is_low()?)
            }
            fn is_low(&self) -> Result<bool, Self::Error> {
                Ok(unsafe { (*GPIOC::ptr()).idr.read().idr8().is_low() })
            }
        }
        #[cfg(feature = "unproven")]
        impl InputPin for PC8<Output<OpenDrain>> {
            type Error = Infallible;
            fn is_high(&self) -> Result<bool, Self::Error> {
                Ok(!self.is_low()?)
            }
            fn is_low(&self) -> Result<bool, Self::Error> {
                Ok(unsafe { (*GPIOC::ptr()).idr.read().idr8().is_low() })
            }
        }
        #[cfg(feature = "unproven")]
        impl<MODE> StatefulOutputPin for PC8<Output<MODE>> {
            fn is_set_high(&self) -> Result<bool, Self::Error> {
                self.is_set_low().map(|b| !b)
            }
            fn is_set_low(&self) -> Result<bool, Self::Error> {
                Ok(unsafe { (*GPIOC::ptr()).odr.read().odr8().is_low() })
            }
        }
        #[cfg(feature = "unproven")]
        impl<MODE> toggleable::Default for PC8<Output<MODE>> {}
        #[doc = "Pin `PC9`"]
        pub struct PC9<MODE> {
            _mode: PhantomData<MODE>,
        }
        impl<MODE> PC9<MODE> {
            #[doc = "Configures `PC9` to serve as alternate function: `AF1`"]
            pub fn into_af1(self, moder: &mut MODER, afr: &mut AFRH) -> PC9<AF1> {
                moder.moder().modify(|_, w| w.moder9().alternate());
                afr.afr().modify(|_, w| w.afrh9().af1());
                PC9 { _mode: PhantomData }
            }
            #[doc = "Configures `PC9` to serve as alternate function: `AF2`"]
            pub fn into_af2(self, moder: &mut MODER, afr: &mut AFRH) -> PC9<AF2> {
                moder.moder().modify(|_, w| w.moder9().alternate());
                afr.afr().modify(|_, w| w.afrh9().af2());
                PC9 { _mode: PhantomData }
            }
            #[doc = "Configures `PC9` to serve as alternate function: `AF4`"]
            pub fn into_af4(self, moder: &mut MODER, afr: &mut AFRH) -> PC9<AF4> {
                moder.moder().modify(|_, w| w.moder9().alternate());
                afr.afr().modify(|_, w| w.afrh9().af4());
                PC9 { _mode: PhantomData }
            }
            #[doc = "Configures `PC9` to serve as alternate function: `AF5`"]
            pub fn into_af5(self, moder: &mut MODER, afr: &mut AFRH) -> PC9<AF5> {
                moder.moder().modify(|_, w| w.moder9().alternate());
                afr.afr().modify(|_, w| w.afrh9().af5());
                PC9 { _mode: PhantomData }
            }
            #[doc = "Configures `PC9` to serve as alternate function: `AF6`"]
            pub fn into_af6(self, moder: &mut MODER, afr: &mut AFRH) -> PC9<AF6> {
                moder.moder().modify(|_, w| w.moder9().alternate());
                afr.afr().modify(|_, w| w.afrh9().af6());
                PC9 { _mode: PhantomData }
            }
            #[doc = " Configures the pin to operate as a floating input pin"]
            pub fn into_floating_input(
                self,
                moder: &mut MODER,
                pupdr: &mut PUPDR,
            ) -> PC9<Input<Floating>> {
                moder.moder().modify(|_, w| w.moder9().input());
                pupdr.pupdr().modify(|_, w| w.pupdr9().floating());
                PC9 { _mode: PhantomData }
            }
            #[doc = " Configures the pin to operate as a pulled down input pin"]
            pub fn into_pull_down_input(
                self,
                moder: &mut MODER,
                pupdr: &mut PUPDR,
            ) -> PC9<Input<PullDown>> {
                moder.moder().modify(|_, w| w.moder9().input());
                pupdr.pupdr().modify(|_, w| w.pupdr9().pull_down());
                PC9 { _mode: PhantomData }
            }
            #[doc = " Configures the pin to operate as a pulled up input pin"]
            pub fn into_pull_up_input(
                self,
                moder: &mut MODER,
                pupdr: &mut PUPDR,
            ) -> PC9<Input<PullUp>> {
                moder.moder().modify(|_, w| w.moder9().input());
                pupdr.pupdr().modify(|_, w| w.pupdr9().pull_up());
                PC9 { _mode: PhantomData }
            }
            #[doc = " Configures the pin to operate as an open drain output pin"]
            pub fn into_open_drain_output(
                self,
                moder: &mut MODER,
                otyper: &mut OTYPER,
            ) -> PC9<Output<OpenDrain>> {
                moder.moder().modify(|_, w| w.moder9().output());
                otyper.otyper().modify(|_, w| w.ot9().open_drain());
                PC9 { _mode: PhantomData }
            }
            #[doc = " Configures the pin to operate as an push pull output pin"]
            pub fn into_push_pull_output(
                self,
                moder: &mut MODER,
                otyper: &mut OTYPER,
            ) -> PC9<Output<PushPull>> {
                moder.moder().modify(|_, w| w.moder9().output());
                otyper.otyper().modify(|_, w| w.ot9().push_pull());
                PC9 { _mode: PhantomData }
            }
            #[doc = " Configures the pin to operate as analog, with disabled schmitt trigger."]
            #[doc = " This mode is suitable when the pin is connected to the DAC or ADC."]
            pub fn into_analog(self, moder: &mut MODER, pupdr: &mut PUPDR) -> PC9<Analog> {
                moder.moder().modify(|_, w| w.moder9().analog());
                pupdr.pupdr().modify(|_, w| w.pupdr9().floating());
                PC9 { _mode: PhantomData }
            }
        }
        impl PC9<Output<OpenDrain>> {
            #[doc = " Enables / disables the internal pull up"]
            pub fn internal_pull_up(&mut self, pupdr: &mut PUPDR, on: bool) {
                pupdr.pupdr().modify(|_, w| {
                    if on {
                        w.pupdr9().pull_up()
                    } else {
                        w.pupdr9().floating()
                    }
                });
            }
        }
        impl<MODE> PC9<Output<MODE>> {
            #[doc = " Erases the pin number from the type"]
            #[doc = ""]
            #[doc = " This is useful when you want to collect the pins into an array where you"]
            #[doc = " need all the elements to have the same type"]
            pub fn downgrade(self) -> PCx<Output<MODE>> {
                PCx {
                    i: 9,
                    _mode: self._mode,
                }
            }
        }
        impl<MODE> PC9<Input<MODE>> {
            #[doc = " Erases the pin number from the type"]
            #[doc = ""]
            #[doc = " This is useful when you want to collect the pins into an array where you"]
            #[doc = " need all the elements to have the same type"]
            pub fn downgrade(self) -> PCx<Input<MODE>> {
                PCx {
                    i: 9,
                    _mode: self._mode,
                }
            }
        }
        impl<MODE> OutputPin for PC9<Output<MODE>> {
            type Error = Infallible;
            fn set_high(&mut self) -> Result<(), Self::Error> {
                unsafe { (*GPIOC::ptr()).bsrr.write(|w| w.bs9().set()) }
                Ok(())
            }
            fn set_low(&mut self) -> Result<(), Self::Error> {
                unsafe { (*GPIOC::ptr()).bsrr.write(|w| w.br9().reset()) }
                Ok(())
            }
        }
        #[cfg(feature = "unproven")]
        impl<MODE> InputPin for PC9<Input<MODE>> {
            type Error = Infallible;
            fn is_high(&self) -> Result<bool, Self::Error> {
                Ok(!self.is_low()?)
            }
            fn is_low(&self) -> Result<bool, Self::Error> {
                Ok(unsafe { (*GPIOC::ptr()).idr.read().idr9().is_low() })
            }
        }
        #[cfg(feature = "unproven")]
        impl InputPin for PC9<Output<OpenDrain>> {
            type Error = Infallible;
            fn is_high(&self) -> Result<bool, Self::Error> {
                Ok(!self.is_low()?)
            }
            fn is_low(&self) -> Result<bool, Self::Error> {
                Ok(unsafe { (*GPIOC::ptr()).idr.read().idr9().is_low() })
            }
        }
        #[cfg(feature = "unproven")]
        impl<MODE> StatefulOutputPin for PC9<Output<MODE>> {
            fn is_set_high(&self) -> Result<bool, Self::Error> {
                self.is_set_low().map(|b| !b)
            }
            fn is_set_low(&self) -> Result<bool, Self::Error> {
                Ok(unsafe { (*GPIOC::ptr()).odr.read().odr9().is_low() })
            }
        }
        #[cfg(feature = "unproven")]
        impl<MODE> toggleable::Default for PC9<Output<MODE>> {}
        #[doc = "Pin `PC10`"]
        pub struct PC10<MODE> {
            _mode: PhantomData<MODE>,
        }
        impl<MODE> PC10<MODE> {
            #[doc = "Configures `PC10` to serve as alternate function: `AF1`"]
            pub fn into_af1(self, moder: &mut MODER, afr: &mut AFRH) -> PC10<AF1> {
                moder.moder().modify(|_, w| w.moder10().alternate());
                afr.afr().modify(|_, w| w.afrh10().af1());
                PC10 { _mode: PhantomData }
            }
            #[doc = "Configures `PC10` to serve as alternate function: `AF4`"]
            pub fn into_af4(self, moder: &mut MODER, afr: &mut AFRH) -> PC10<AF4> {
                moder.moder().modify(|_, w| w.moder10().alternate());
                afr.afr().modify(|_, w| w.afrh10().af4());
                PC10 { _mode: PhantomData }
            }
            #[doc = "Configures `PC10` to serve as alternate function: `AF5`"]
            pub fn into_af5(self, moder: &mut MODER, afr: &mut AFRH) -> PC10<AF5> {
                moder.moder().modify(|_, w| w.moder10().alternate());
                afr.afr().modify(|_, w| w.afrh10().af5());
                PC10 { _mode: PhantomData }
            }
            #[doc = "Configures `PC10` to serve as alternate function: `AF6`"]
            pub fn into_af6(self, moder: &mut MODER, afr: &mut AFRH) -> PC10<AF6> {
                moder.moder().modify(|_, w| w.moder10().alternate());
                afr.afr().modify(|_, w| w.afrh10().af6());
                PC10 { _mode: PhantomData }
            }
            #[doc = "Configures `PC10` to serve as alternate function: `AF7`"]
            pub fn into_af7(self, moder: &mut MODER, afr: &mut AFRH) -> PC10<AF7> {
                moder.moder().modify(|_, w| w.moder10().alternate());
                afr.afr().modify(|_, w| w.afrh10().af7());
                PC10 { _mode: PhantomData }
            }
            #[doc = " Configures the pin to operate as a floating input pin"]
            pub fn into_floating_input(
                self,
                moder: &mut MODER,
                pupdr: &mut PUPDR,
            ) -> PC10<Input<Floating>> {
                moder.moder().modify(|_, w| w.moder10().input());
                pupdr.pupdr().modify(|_, w| w.pupdr10().floating());
                PC10 { _mode: PhantomData }
            }
            #[doc = " Configures the pin to operate as a pulled down input pin"]
            pub fn into_pull_down_input(
                self,
                moder: &mut MODER,
                pupdr: &mut PUPDR,
            ) -> PC10<Input<PullDown>> {
                moder.moder().modify(|_, w| w.moder10().input());
                pupdr.pupdr().modify(|_, w| w.pupdr10().pull_down());
                PC10 { _mode: PhantomData }
            }
            #[doc = " Configures the pin to operate as a pulled up input pin"]
            pub fn into_pull_up_input(
                self,
                moder: &mut MODER,
                pupdr: &mut PUPDR,
            ) -> PC10<Input<PullUp>> {
                moder.moder().modify(|_, w| w.moder10().input());
                pupdr.pupdr().modify(|_, w| w.pupdr10().pull_up());
                PC10 { _mode: PhantomData }
            }
            #[doc = " Configures the pin to operate as an open drain output pin"]
            pub fn into_open_drain_output(
                self,
                moder: &mut MODER,
                otyper: &mut OTYPER,
            ) -> PC10<Output<OpenDrain>> {
                moder.moder().modify(|_, w| w.moder10().output());
                otyper.otyper().modify(|_, w| w.ot10().open_drain());
                PC10 { _mode: PhantomData }
            }
            #[doc = " Configures the pin to operate as an push pull output pin"]
            pub fn into_push_pull_output(
                self,
                moder: &mut MODER,
                otyper: &mut OTYPER,
            ) -> PC10<Output<PushPull>> {
                moder.moder().modify(|_, w| w.moder10().output());
                otyper.otyper().modify(|_, w| w.ot10().push_pull());
                PC10 { _mode: PhantomData }
            }
            #[doc = " Configures the pin to operate as analog, with disabled schmitt trigger."]
            #[doc = " This mode is suitable when the pin is connected to the DAC or ADC."]
            pub fn into_analog(self, moder: &mut MODER, pupdr: &mut PUPDR) -> PC10<Analog> {
                moder.moder().modify(|_, w| w.moder10().analog());
                pupdr.pupdr().modify(|_, w| w.pupdr10().floating());
                PC10 { _mode: PhantomData }
            }
        }
        impl PC10<Output<OpenDrain>> {
            #[doc = " Enables / disables the internal pull up"]
            pub fn internal_pull_up(&mut self, pupdr: &mut PUPDR, on: bool) {
                pupdr.pupdr().modify(|_, w| {
                    if on {
                        w.pupdr10().pull_up()
                    } else {
                        w.pupdr10().floating()
                    }
                });
            }
        }
        impl<MODE> PC10<Output<MODE>> {
            #[doc = " Erases the pin number from the type"]
            #[doc = ""]
            #[doc = " This is useful when you want to collect the pins into an array where you"]
            #[doc = " need all the elements to have the same type"]
            pub fn downgrade(self) -> PCx<Output<MODE>> {
                PCx {
                    i: 10,
                    _mode: self._mode,
                }
            }
        }
        impl<MODE> PC10<Input<MODE>> {
            #[doc = " Erases the pin number from the type"]
            #[doc = ""]
            #[doc = " This is useful when you want to collect the pins into an array where you"]
            #[doc = " need all the elements to have the same type"]
            pub fn downgrade(self) -> PCx<Input<MODE>> {
                PCx {
                    i: 10,
                    _mode: self._mode,
                }
            }
        }
        impl<MODE> OutputPin for PC10<Output<MODE>> {
            type Error = Infallible;
            fn set_high(&mut self) -> Result<(), Self::Error> {
                unsafe { (*GPIOC::ptr()).bsrr.write(|w| w.bs10().set()) }
                Ok(())
            }
            fn set_low(&mut self) -> Result<(), Self::Error> {
                unsafe { (*GPIOC::ptr()).bsrr.write(|w| w.br10().reset()) }
                Ok(())
            }
        }
        #[cfg(feature = "unproven")]
        impl<MODE> InputPin for PC10<Input<MODE>> {
            type Error = Infallible;
            fn is_high(&self) -> Result<bool, Self::Error> {
                Ok(!self.is_low()?)
            }
            fn is_low(&self) -> Result<bool, Self::Error> {
                Ok(unsafe { (*GPIOC::ptr()).idr.read().idr10().is_low() })
            }
        }
        #[cfg(feature = "unproven")]
        impl InputPin for PC10<Output<OpenDrain>> {
            type Error = Infallible;
            fn is_high(&self) -> Result<bool, Self::Error> {
                Ok(!self.is_low()?)
            }
            fn is_low(&self) -> Result<bool, Self::Error> {
                Ok(unsafe { (*GPIOC::ptr()).idr.read().idr10().is_low() })
            }
        }
        #[cfg(feature = "unproven")]
        impl<MODE> StatefulOutputPin for PC10<Output<MODE>> {
            fn is_set_high(&self) -> Result<bool, Self::Error> {
                self.is_set_low().map(|b| !b)
            }
            fn is_set_low(&self) -> Result<bool, Self::Error> {
                Ok(unsafe { (*GPIOC::ptr()).odr.read().odr10().is_low() })
            }
        }
        #[cfg(feature = "unproven")]
        impl<MODE> toggleable::Default for PC10<Output<MODE>> {}
        #[doc = "Pin `PC11`"]
        pub struct PC11<MODE> {
            _mode: PhantomData<MODE>,
        }
        impl<MODE> PC11<MODE> {
            #[doc = "Configures `PC11` to serve as alternate function: `AF1`"]
            pub fn into_af1(self, moder: &mut MODER, afr: &mut AFRH) -> PC11<AF1> {
                moder.moder().modify(|_, w| w.moder11().alternate());
                afr.afr().modify(|_, w| w.afrh11().af1());
                PC11 { _mode: PhantomData }
            }
            #[doc = "Configures `PC11` to serve as alternate function: `AF4`"]
            pub fn into_af4(self, moder: &mut MODER, afr: &mut AFRH) -> PC11<AF4> {
                moder.moder().modify(|_, w| w.moder11().alternate());
                afr.afr().modify(|_, w| w.afrh11().af4());
                PC11 { _mode: PhantomData }
            }
            #[doc = "Configures `PC11` to serve as alternate function: `AF5`"]
            pub fn into_af5(self, moder: &mut MODER, afr: &mut AFRH) -> PC11<AF5> {
                moder.moder().modify(|_, w| w.moder11().alternate());
                afr.afr().modify(|_, w| w.afrh11().af5());
                PC11 { _mode: PhantomData }
            }
            #[doc = "Configures `PC11` to serve as alternate function: `AF6`"]
            pub fn into_af6(self, moder: &mut MODER, afr: &mut AFRH) -> PC11<AF6> {
                moder.moder().modify(|_, w| w.moder11().alternate());
                afr.afr().modify(|_, w| w.afrh11().af6());
                PC11 { _mode: PhantomData }
            }
            #[doc = "Configures `PC11` to serve as alternate function: `AF7`"]
            pub fn into_af7(self, moder: &mut MODER, afr: &mut AFRH) -> PC11<AF7> {
                moder.moder().modify(|_, w| w.moder11().alternate());
                afr.afr().modify(|_, w| w.afrh11().af7());
                PC11 { _mode: PhantomData }
            }
            #[doc = " Configures the pin to operate as a floating input pin"]
            pub fn into_floating_input(
                self,
                moder: &mut MODER,
                pupdr: &mut PUPDR,
            ) -> PC11<Input<Floating>> {
                moder.moder().modify(|_, w| w.moder11().input());
                pupdr.pupdr().modify(|_, w| w.pupdr11().floating());
                PC11 { _mode: PhantomData }
            }
            #[doc = " Configures the pin to operate as a pulled down input pin"]
            pub fn into_pull_down_input(
                self,
                moder: &mut MODER,
                pupdr: &mut PUPDR,
            ) -> PC11<Input<PullDown>> {
                moder.moder().modify(|_, w| w.moder11().input());
                pupdr.pupdr().modify(|_, w| w.pupdr11().pull_down());
                PC11 { _mode: PhantomData }
            }
            #[doc = " Configures the pin to operate as a pulled up input pin"]
            pub fn into_pull_up_input(
                self,
                moder: &mut MODER,
                pupdr: &mut PUPDR,
            ) -> PC11<Input<PullUp>> {
                moder.moder().modify(|_, w| w.moder11().input());
                pupdr.pupdr().modify(|_, w| w.pupdr11().pull_up());
                PC11 { _mode: PhantomData }
            }
            #[doc = " Configures the pin to operate as an open drain output pin"]
            pub fn into_open_drain_output(
                self,
                moder: &mut MODER,
                otyper: &mut OTYPER,
            ) -> PC11<Output<OpenDrain>> {
                moder.moder().modify(|_, w| w.moder11().output());
                otyper.otyper().modify(|_, w| w.ot11().open_drain());
                PC11 { _mode: PhantomData }
            }
            #[doc = " Configures the pin to operate as an push pull output pin"]
            pub fn into_push_pull_output(
                self,
                moder: &mut MODER,
                otyper: &mut OTYPER,
            ) -> PC11<Output<PushPull>> {
                moder.moder().modify(|_, w| w.moder11().output());
                otyper.otyper().modify(|_, w| w.ot11().push_pull());
                PC11 { _mode: PhantomData }
            }
            #[doc = " Configures the pin to operate as analog, with disabled schmitt trigger."]
            #[doc = " This mode is suitable when the pin is connected to the DAC or ADC."]
            pub fn into_analog(self, moder: &mut MODER, pupdr: &mut PUPDR) -> PC11<Analog> {
                moder.moder().modify(|_, w| w.moder11().analog());
                pupdr.pupdr().modify(|_, w| w.pupdr11().floating());
                PC11 { _mode: PhantomData }
            }
        }
        impl PC11<Output<OpenDrain>> {
            #[doc = " Enables / disables the internal pull up"]
            pub fn internal_pull_up(&mut self, pupdr: &mut PUPDR, on: bool) {
                pupdr.pupdr().modify(|_, w| {
                    if on {
                        w.pupdr11().pull_up()
                    } else {
                        w.pupdr11().floating()
                    }
                });
            }
        }
        impl<MODE> PC11<Output<MODE>> {
            #[doc = " Erases the pin number from the type"]
            #[doc = ""]
            #[doc = " This is useful when you want to collect the pins into an array where you"]
            #[doc = " need all the elements to have the same type"]
            pub fn downgrade(self) -> PCx<Output<MODE>> {
                PCx {
                    i: 11,
                    _mode: self._mode,
                }
            }
        }
        impl<MODE> PC11<Input<MODE>> {
            #[doc = " Erases the pin number from the type"]
            #[doc = ""]
            #[doc = " This is useful when you want to collect the pins into an array where you"]
            #[doc = " need all the elements to have the same type"]
            pub fn downgrade(self) -> PCx<Input<MODE>> {
                PCx {
                    i: 11,
                    _mode: self._mode,
                }
            }
        }
        impl<MODE> OutputPin for PC11<Output<MODE>> {
            type Error = Infallible;
            fn set_high(&mut self) -> Result<(), Self::Error> {
                unsafe { (*GPIOC::ptr()).bsrr.write(|w| w.bs11().set()) }
                Ok(())
            }
            fn set_low(&mut self) -> Result<(), Self::Error> {
                unsafe { (*GPIOC::ptr()).bsrr.write(|w| w.br11().reset()) }
                Ok(())
            }
        }
        #[cfg(feature = "unproven")]
        impl<MODE> InputPin for PC11<Input<MODE>> {
            type Error = Infallible;
            fn is_high(&self) -> Result<bool, Self::Error> {
                Ok(!self.is_low()?)
            }
            fn is_low(&self) -> Result<bool, Self::Error> {
                Ok(unsafe { (*GPIOC::ptr()).idr.read().idr11().is_low() })
            }
        }
        #[cfg(feature = "unproven")]
        impl InputPin for PC11<Output<OpenDrain>> {
            type Error = Infallible;
            fn is_high(&self) -> Result<bool, Self::Error> {
                Ok(!self.is_low()?)
            }
            fn is_low(&self) -> Result<bool, Self::Error> {
                Ok(unsafe { (*GPIOC::ptr()).idr.read().idr11().is_low() })
            }
        }
        #[cfg(feature = "unproven")]
        impl<MODE> StatefulOutputPin for PC11<Output<MODE>> {
            fn is_set_high(&self) -> Result<bool, Self::Error> {
                self.is_set_low().map(|b| !b)
            }
            fn is_set_low(&self) -> Result<bool, Self::Error> {
                Ok(unsafe { (*GPIOC::ptr()).odr.read().odr11().is_low() })
            }
        }
        #[cfg(feature = "unproven")]
        impl<MODE> toggleable::Default for PC11<Output<MODE>> {}
        #[doc = "Pin `PC12`"]
        pub struct PC12<MODE> {
            _mode: PhantomData<MODE>,
        }
        impl<MODE> PC12<MODE> {
            #[doc = "Configures `PC12` to serve as alternate function: `AF1`"]
            pub fn into_af1(self, moder: &mut MODER, afr: &mut AFRH) -> PC12<AF1> {
                moder.moder().modify(|_, w| w.moder12().alternate());
                afr.afr().modify(|_, w| w.afrh12().af1());
                PC12 { _mode: PhantomData }
            }
            #[doc = "Configures `PC12` to serve as alternate function: `AF4`"]
            pub fn into_af4(self, moder: &mut MODER, afr: &mut AFRH) -> PC12<AF4> {
                moder.moder().modify(|_, w| w.moder12().alternate());
                afr.afr().modify(|_, w| w.afrh12().af4());
                PC12 { _mode: PhantomData }
            }
            #[doc = "Configures `PC12` to serve as alternate function: `AF5`"]
            pub fn into_af5(self, moder: &mut MODER, afr: &mut AFRH) -> PC12<AF5> {
                moder.moder().modify(|_, w| w.moder12().alternate());
                afr.afr().modify(|_, w| w.afrh12().af5());
                PC12 { _mode: PhantomData }
            }
            #[doc = "Configures `PC12` to serve as alternate function: `AF6`"]
            pub fn into_af6(self, moder: &mut MODER, afr: &mut AFRH) -> PC12<AF6> {
                moder.moder().modify(|_, w| w.moder12().alternate());
                afr.afr().modify(|_, w| w.afrh12().af6());
                PC12 { _mode: PhantomData }
            }
            #[doc = "Configures `PC12` to serve as alternate function: `AF7`"]
            pub fn into_af7(self, moder: &mut MODER, afr: &mut AFRH) -> PC12<AF7> {
                moder.moder().modify(|_, w| w.moder12().alternate());
                afr.afr().modify(|_, w| w.afrh12().af7());
                PC12 { _mode: PhantomData }
            }
            #[doc = " Configures the pin to operate as a floating input pin"]
            pub fn into_floating_input(
                self,
                moder: &mut MODER,
                pupdr: &mut PUPDR,
            ) -> PC12<Input<Floating>> {
                moder.moder().modify(|_, w| w.moder12().input());
                pupdr.pupdr().modify(|_, w| w.pupdr12().floating());
                PC12 { _mode: PhantomData }
            }
            #[doc = " Configures the pin to operate as a pulled down input pin"]
            pub fn into_pull_down_input(
                self,
                moder: &mut MODER,
                pupdr: &mut PUPDR,
            ) -> PC12<Input<PullDown>> {
                moder.moder().modify(|_, w| w.moder12().input());
                pupdr.pupdr().modify(|_, w| w.pupdr12().pull_down());
                PC12 { _mode: PhantomData }
            }
            #[doc = " Configures the pin to operate as a pulled up input pin"]
            pub fn into_pull_up_input(
                self,
                moder: &mut MODER,
                pupdr: &mut PUPDR,
            ) -> PC12<Input<PullUp>> {
                moder.moder().modify(|_, w| w.moder12().input());
                pupdr.pupdr().modify(|_, w| w.pupdr12().pull_up());
                PC12 { _mode: PhantomData }
            }
            #[doc = " Configures the pin to operate as an open drain output pin"]
            pub fn into_open_drain_output(
                self,
                moder: &mut MODER,
                otyper: &mut OTYPER,
            ) -> PC12<Output<OpenDrain>> {
                moder.moder().modify(|_, w| w.moder12().output());
                otyper.otyper().modify(|_, w| w.ot12().open_drain());
                PC12 { _mode: PhantomData }
            }
            #[doc = " Configures the pin to operate as an push pull output pin"]
            pub fn into_push_pull_output(
                self,
                moder: &mut MODER,
                otyper: &mut OTYPER,
            ) -> PC12<Output<PushPull>> {
                moder.moder().modify(|_, w| w.moder12().output());
                otyper.otyper().modify(|_, w| w.ot12().push_pull());
                PC12 { _mode: PhantomData }
            }
            #[doc = " Configures the pin to operate as analog, with disabled schmitt trigger."]
            #[doc = " This mode is suitable when the pin is connected to the DAC or ADC."]
            pub fn into_analog(self, moder: &mut MODER, pupdr: &mut PUPDR) -> PC12<Analog> {
                moder.moder().modify(|_, w| w.moder12().analog());
                pupdr.pupdr().modify(|_, w| w.pupdr12().floating());
                PC12 { _mode: PhantomData }
            }
        }
        impl PC12<Output<OpenDrain>> {
            #[doc = " Enables / disables the internal pull up"]
            pub fn internal_pull_up(&mut self, pupdr: &mut PUPDR, on: bool) {
                pupdr.pupdr().modify(|_, w| {
                    if on {
                        w.pupdr12().pull_up()
                    } else {
                        w.pupdr12().floating()
                    }
                });
            }
        }
        impl<MODE> PC12<Output<MODE>> {
            #[doc = " Erases the pin number from the type"]
            #[doc = ""]
            #[doc = " This is useful when you want to collect the pins into an array where you"]
            #[doc = " need all the elements to have the same type"]
            pub fn downgrade(self) -> PCx<Output<MODE>> {
                PCx {
                    i: 12,
                    _mode: self._mode,
                }
            }
        }
        impl<MODE> PC12<Input<MODE>> {
            #[doc = " Erases the pin number from the type"]
            #[doc = ""]
            #[doc = " This is useful when you want to collect the pins into an array where you"]
            #[doc = " need all the elements to have the same type"]
            pub fn downgrade(self) -> PCx<Input<MODE>> {
                PCx {
                    i: 12,
                    _mode: self._mode,
                }
            }
        }
        impl<MODE> OutputPin for PC12<Output<MODE>> {
            type Error = Infallible;
            fn set_high(&mut self) -> Result<(), Self::Error> {
                unsafe { (*GPIOC::ptr()).bsrr.write(|w| w.bs12().set()) }
                Ok(())
            }
            fn set_low(&mut self) -> Result<(), Self::Error> {
                unsafe { (*GPIOC::ptr()).bsrr.write(|w| w.br12().reset()) }
                Ok(())
            }
        }
        #[cfg(feature = "unproven")]
        impl<MODE> InputPin for PC12<Input<MODE>> {
            type Error = Infallible;
            fn is_high(&self) -> Result<bool, Self::Error> {
                Ok(!self.is_low()?)
            }
            fn is_low(&self) -> Result<bool, Self::Error> {
                Ok(unsafe { (*GPIOC::ptr()).idr.read().idr12().is_low() })
            }
        }
        #[cfg(feature = "unproven")]
        impl InputPin for PC12<Output<OpenDrain>> {
            type Error = Infallible;
            fn is_high(&self) -> Result<bool, Self::Error> {
                Ok(!self.is_low()?)
            }
            fn is_low(&self) -> Result<bool, Self::Error> {
                Ok(unsafe { (*GPIOC::ptr()).idr.read().idr12().is_low() })
            }
        }
        #[cfg(feature = "unproven")]
        impl<MODE> StatefulOutputPin for PC12<Output<MODE>> {
            fn is_set_high(&self) -> Result<bool, Self::Error> {
                self.is_set_low().map(|b| !b)
            }
            fn is_set_low(&self) -> Result<bool, Self::Error> {
                Ok(unsafe { (*GPIOC::ptr()).odr.read().odr12().is_low() })
            }
        }
        #[cfg(feature = "unproven")]
        impl<MODE> toggleable::Default for PC12<Output<MODE>> {}
        #[doc = "Pin `PC13`"]
        pub struct PC13<MODE> {
            _mode: PhantomData<MODE>,
        }
        impl<MODE> PC13<MODE> {
            #[doc = "Configures `PC13` to serve as alternate function: `AF4`"]
            pub fn into_af4(self, moder: &mut MODER, afr: &mut AFRH) -> PC13<AF4> {
                moder.moder().modify(|_, w| w.moder13().alternate());
                afr.afr().modify(|_, w| w.afrh13().af4());
                PC13 { _mode: PhantomData }
            }
            #[doc = " Configures the pin to operate as a floating input pin"]
            pub fn into_floating_input(
                self,
                moder: &mut MODER,
                pupdr: &mut PUPDR,
            ) -> PC13<Input<Floating>> {
                moder.moder().modify(|_, w| w.moder13().input());
                pupdr.pupdr().modify(|_, w| w.pupdr13().floating());
                PC13 { _mode: PhantomData }
            }
            #[doc = " Configures the pin to operate as a pulled down input pin"]
            pub fn into_pull_down_input(
                self,
                moder: &mut MODER,
                pupdr: &mut PUPDR,
            ) -> PC13<Input<PullDown>> {
                moder.moder().modify(|_, w| w.moder13().input());
                pupdr.pupdr().modify(|_, w| w.pupdr13().pull_down());
                PC13 { _mode: PhantomData }
            }
            #[doc = " Configures the pin to operate as a pulled up input pin"]
            pub fn into_pull_up_input(
                self,
                moder: &mut MODER,
                pupdr: &mut PUPDR,
            ) -> PC13<Input<PullUp>> {
                moder.moder().modify(|_, w| w.moder13().input());
                pupdr.pupdr().modify(|_, w| w.pupdr13().pull_up());
                PC13 { _mode: PhantomData }
            }
            #[doc = " Configures the pin to operate as an open drain output pin"]
            pub fn into_open_drain_output(
                self,
                moder: &mut MODER,
                otyper: &mut OTYPER,
            ) -> PC13<Output<OpenDrain>> {
                moder.moder().modify(|_, w| w.moder13().output());
                otyper.otyper().modify(|_, w| w.ot13().open_drain());
                PC13 { _mode: PhantomData }
            }
            #[doc = " Configures the pin to operate as an push pull output pin"]
            pub fn into_push_pull_output(
                self,
                moder: &mut MODER,
                otyper: &mut OTYPER,
            ) -> PC13<Output<PushPull>> {
                moder.moder().modify(|_, w| w.moder13().output());
                otyper.otyper().modify(|_, w| w.ot13().push_pull());
                PC13 { _mode: PhantomData }
            }
            #[doc = " Configures the pin to operate as analog, with disabled schmitt trigger."]
            #[doc = " This mode is suitable when the pin is connected to the DAC or ADC."]
            pub fn into_analog(self, moder: &mut MODER, pupdr: &mut PUPDR) -> PC13<Analog> {
                moder.moder().modify(|_, w| w.moder13().analog());
                pupdr.pupdr().modify(|_, w| w.pupdr13().floating());
                PC13 { _mode: PhantomData }
            }
        }
        impl PC13<Output<OpenDrain>> {
            #[doc = " Enables / disables the internal pull up"]
            pub fn internal_pull_up(&mut self, pupdr: &mut PUPDR, on: bool) {
                pupdr.pupdr().modify(|_, w| {
                    if on {
                        w.pupdr13().pull_up()
                    } else {
                        w.pupdr13().floating()
                    }
                });
            }
        }
        impl<MODE> PC13<Output<MODE>> {
            #[doc = " Erases the pin number from the type"]
            #[doc = ""]
            #[doc = " This is useful when you want to collect the pins into an array where you"]
            #[doc = " need all the elements to have the same type"]
            pub fn downgrade(self) -> PCx<Output<MODE>> {
                PCx {
                    i: 13,
                    _mode: self._mode,
                }
            }
        }
        impl<MODE> PC13<Input<MODE>> {
            #[doc = " Erases the pin number from the type"]
            #[doc = ""]
            #[doc = " This is useful when you want to collect the pins into an array where you"]
            #[doc = " need all the elements to have the same type"]
            pub fn downgrade(self) -> PCx<Input<MODE>> {
                PCx {
                    i: 13,
                    _mode: self._mode,
                }
            }
        }
        impl<MODE> OutputPin for PC13<Output<MODE>> {
            type Error = Infallible;
            fn set_high(&mut self) -> Result<(), Self::Error> {
                unsafe { (*GPIOC::ptr()).bsrr.write(|w| w.bs13().set()) }
                Ok(())
            }
            fn set_low(&mut self) -> Result<(), Self::Error> {
                unsafe { (*GPIOC::ptr()).bsrr.write(|w| w.br13().reset()) }
                Ok(())
            }
        }
        #[cfg(feature = "unproven")]
        impl<MODE> InputPin for PC13<Input<MODE>> {
            type Error = Infallible;
            fn is_high(&self) -> Result<bool, Self::Error> {
                Ok(!self.is_low()?)
            }
            fn is_low(&self) -> Result<bool, Self::Error> {
                Ok(unsafe { (*GPIOC::ptr()).idr.read().idr13().is_low() })
            }
        }
        #[cfg(feature = "unproven")]
        impl InputPin for PC13<Output<OpenDrain>> {
            type Error = Infallible;
            fn is_high(&self) -> Result<bool, Self::Error> {
                Ok(!self.is_low()?)
            }
            fn is_low(&self) -> Result<bool, Self::Error> {
                Ok(unsafe { (*GPIOC::ptr()).idr.read().idr13().is_low() })
            }
        }
        #[cfg(feature = "unproven")]
        impl<MODE> StatefulOutputPin for PC13<Output<MODE>> {
            fn is_set_high(&self) -> Result<bool, Self::Error> {
                self.is_set_low().map(|b| !b)
            }
            fn is_set_low(&self) -> Result<bool, Self::Error> {
                Ok(unsafe { (*GPIOC::ptr()).odr.read().odr13().is_low() })
            }
        }
        #[cfg(feature = "unproven")]
        impl<MODE> toggleable::Default for PC13<Output<MODE>> {}
        #[doc = "Pin `PC14`"]
        pub struct PC14<MODE> {
            _mode: PhantomData<MODE>,
        }
        impl<MODE> PC14<MODE> {
            #[doc = " Configures the pin to operate as a floating input pin"]
            pub fn into_floating_input(
                self,
                moder: &mut MODER,
                pupdr: &mut PUPDR,
            ) -> PC14<Input<Floating>> {
                moder.moder().modify(|_, w| w.moder14().input());
                pupdr.pupdr().modify(|_, w| w.pupdr14().floating());
                PC14 { _mode: PhantomData }
            }
            #[doc = " Configures the pin to operate as a pulled down input pin"]
            pub fn into_pull_down_input(
                self,
                moder: &mut MODER,
                pupdr: &mut PUPDR,
            ) -> PC14<Input<PullDown>> {
                moder.moder().modify(|_, w| w.moder14().input());
                pupdr.pupdr().modify(|_, w| w.pupdr14().pull_down());
                PC14 { _mode: PhantomData }
            }
            #[doc = " Configures the pin to operate as a pulled up input pin"]
            pub fn into_pull_up_input(
                self,
                moder: &mut MODER,
                pupdr: &mut PUPDR,
            ) -> PC14<Input<PullUp>> {
                moder.moder().modify(|_, w| w.moder14().input());
                pupdr.pupdr().modify(|_, w| w.pupdr14().pull_up());
                PC14 { _mode: PhantomData }
            }
            #[doc = " Configures the pin to operate as an open drain output pin"]
            pub fn into_open_drain_output(
                self,
                moder: &mut MODER,
                otyper: &mut OTYPER,
            ) -> PC14<Output<OpenDrain>> {
                moder.moder().modify(|_, w| w.moder14().output());
                otyper.otyper().modify(|_, w| w.ot14().open_drain());
                PC14 { _mode: PhantomData }
            }
            #[doc = " Configures the pin to operate as an push pull output pin"]
            pub fn into_push_pull_output(
                self,
                moder: &mut MODER,
                otyper: &mut OTYPER,
            ) -> PC14<Output<PushPull>> {
                moder.moder().modify(|_, w| w.moder14().output());
                otyper.otyper().modify(|_, w| w.ot14().push_pull());
                PC14 { _mode: PhantomData }
            }
            #[doc = " Configures the pin to operate as analog, with disabled schmitt trigger."]
            #[doc = " This mode is suitable when the pin is connected to the DAC or ADC."]
            pub fn into_analog(self, moder: &mut MODER, pupdr: &mut PUPDR) -> PC14<Analog> {
                moder.moder().modify(|_, w| w.moder14().analog());
                pupdr.pupdr().modify(|_, w| w.pupdr14().floating());
                PC14 { _mode: PhantomData }
            }
        }
        impl PC14<Output<OpenDrain>> {
            #[doc = " Enables / disables the internal pull up"]
            pub fn internal_pull_up(&mut self, pupdr: &mut PUPDR, on: bool) {
                pupdr.pupdr().modify(|_, w| {
                    if on {
                        w.pupdr14().pull_up()
                    } else {
                        w.pupdr14().floating()
                    }
                });
            }
        }
        impl<MODE> PC14<Output<MODE>> {
            #[doc = " Erases the pin number from the type"]
            #[doc = ""]
            #[doc = " This is useful when you want to collect the pins into an array where you"]
            #[doc = " need all the elements to have the same type"]
            pub fn downgrade(self) -> PCx<Output<MODE>> {
                PCx {
                    i: 14,
                    _mode: self._mode,
                }
            }
        }
        impl<MODE> PC14<Input<MODE>> {
            #[doc = " Erases the pin number from the type"]
            #[doc = ""]
            #[doc = " This is useful when you want to collect the pins into an array where you"]
            #[doc = " need all the elements to have the same type"]
            pub fn downgrade(self) -> PCx<Input<MODE>> {
                PCx {
                    i: 14,
                    _mode: self._mode,
                }
            }
        }
        impl<MODE> OutputPin for PC14<Output<MODE>> {
            type Error = Infallible;
            fn set_high(&mut self) -> Result<(), Self::Error> {
                unsafe { (*GPIOC::ptr()).bsrr.write(|w| w.bs14().set()) }
                Ok(())
            }
            fn set_low(&mut self) -> Result<(), Self::Error> {
                unsafe { (*GPIOC::ptr()).bsrr.write(|w| w.br14().reset()) }
                Ok(())
            }
        }
        #[cfg(feature = "unproven")]
        impl<MODE> InputPin for PC14<Input<MODE>> {
            type Error = Infallible;
            fn is_high(&self) -> Result<bool, Self::Error> {
                Ok(!self.is_low()?)
            }
            fn is_low(&self) -> Result<bool, Self::Error> {
                Ok(unsafe { (*GPIOC::ptr()).idr.read().idr14().is_low() })
            }
        }
        #[cfg(feature = "unproven")]
        impl InputPin for PC14<Output<OpenDrain>> {
            type Error = Infallible;
            fn is_high(&self) -> Result<bool, Self::Error> {
                Ok(!self.is_low()?)
            }
            fn is_low(&self) -> Result<bool, Self::Error> {
                Ok(unsafe { (*GPIOC::ptr()).idr.read().idr14().is_low() })
            }
        }
        #[cfg(feature = "unproven")]
        impl<MODE> StatefulOutputPin for PC14<Output<MODE>> {
            fn is_set_high(&self) -> Result<bool, Self::Error> {
                self.is_set_low().map(|b| !b)
            }
            fn is_set_low(&self) -> Result<bool, Self::Error> {
                Ok(unsafe { (*GPIOC::ptr()).odr.read().odr14().is_low() })
            }
        }
        #[cfg(feature = "unproven")]
        impl<MODE> toggleable::Default for PC14<Output<MODE>> {}
        #[doc = "Pin `PC15`"]
        pub struct PC15<MODE> {
            _mode: PhantomData<MODE>,
        }
        impl<MODE> PC15<MODE> {
            #[doc = " Configures the pin to operate as a floating input pin"]
            pub fn into_floating_input(
                self,
                moder: &mut MODER,
                pupdr: &mut PUPDR,
            ) -> PC15<Input<Floating>> {
                moder.moder().modify(|_, w| w.moder15().input());
                pupdr.pupdr().modify(|_, w| w.pupdr15().floating());
                PC15 { _mode: PhantomData }
            }
            #[doc = " Configures the pin to operate as a pulled down input pin"]
            pub fn into_pull_down_input(
                self,
                moder: &mut MODER,
                pupdr: &mut PUPDR,
            ) -> PC15<Input<PullDown>> {
                moder.moder().modify(|_, w| w.moder15().input());
                pupdr.pupdr().modify(|_, w| w.pupdr15().pull_down());
                PC15 { _mode: PhantomData }
            }
            #[doc = " Configures the pin to operate as a pulled up input pin"]
            pub fn into_pull_up_input(
                self,
                moder: &mut MODER,
                pupdr: &mut PUPDR,
            ) -> PC15<Input<PullUp>> {
                moder.moder().modify(|_, w| w.moder15().input());
                pupdr.pupdr().modify(|_, w| w.pupdr15().pull_up());
                PC15 { _mode: PhantomData }
            }
            #[doc = " Configures the pin to operate as an open drain output pin"]
            pub fn into_open_drain_output(
                self,
                moder: &mut MODER,
                otyper: &mut OTYPER,
            ) -> PC15<Output<OpenDrain>> {
                moder.moder().modify(|_, w| w.moder15().output());
                otyper.otyper().modify(|_, w| w.ot15().open_drain());
                PC15 { _mode: PhantomData }
            }
            #[doc = " Configures the pin to operate as an push pull output pin"]
            pub fn into_push_pull_output(
                self,
                moder: &mut MODER,
                otyper: &mut OTYPER,
            ) -> PC15<Output<PushPull>> {
                moder.moder().modify(|_, w| w.moder15().output());
                otyper.otyper().modify(|_, w| w.ot15().push_pull());
                PC15 { _mode: PhantomData }
            }
            #[doc = " Configures the pin to operate as analog, with disabled schmitt trigger."]
            #[doc = " This mode is suitable when the pin is connected to the DAC or ADC."]
            pub fn into_analog(self, moder: &mut MODER, pupdr: &mut PUPDR) -> PC15<Analog> {
                moder.moder().modify(|_, w| w.moder15().analog());
                pupdr.pupdr().modify(|_, w| w.pupdr15().floating());
                PC15 { _mode: PhantomData }
            }
        }
        impl PC15<Output<OpenDrain>> {
            #[doc = " Enables / disables the internal pull up"]
            pub fn internal_pull_up(&mut self, pupdr: &mut PUPDR, on: bool) {
                pupdr.pupdr().modify(|_, w| {
                    if on {
                        w.pupdr15().pull_up()
                    } else {
                        w.pupdr15().floating()
                    }
                });
            }
        }
        impl<MODE> PC15<Output<MODE>> {
            #[doc = " Erases the pin number from the type"]
            #[doc = ""]
            #[doc = " This is useful when you want to collect the pins into an array where you"]
            #[doc = " need all the elements to have the same type"]
            pub fn downgrade(self) -> PCx<Output<MODE>> {
                PCx {
                    i: 15,
                    _mode: self._mode,
                }
            }
        }
        impl<MODE> PC15<Input<MODE>> {
            #[doc = " Erases the pin number from the type"]
            #[doc = ""]
            #[doc = " This is useful when you want to collect the pins into an array where you"]
            #[doc = " need all the elements to have the same type"]
            pub fn downgrade(self) -> PCx<Input<MODE>> {
                PCx {
                    i: 15,
                    _mode: self._mode,
                }
            }
        }
        impl<MODE> OutputPin for PC15<Output<MODE>> {
            type Error = Infallible;
            fn set_high(&mut self) -> Result<(), Self::Error> {
                unsafe { (*GPIOC::ptr()).bsrr.write(|w| w.bs15().set()) }
                Ok(())
            }
            fn set_low(&mut self) -> Result<(), Self::Error> {
                unsafe { (*GPIOC::ptr()).bsrr.write(|w| w.br15().reset()) }
                Ok(())
            }
        }
        #[cfg(feature = "unproven")]
        impl<MODE> InputPin for PC15<Input<MODE>> {
            type Error = Infallible;
            fn is_high(&self) -> Result<bool, Self::Error> {
                Ok(!self.is_low()?)
            }
            fn is_low(&self) -> Result<bool, Self::Error> {
                Ok(unsafe { (*GPIOC::ptr()).idr.read().idr15().is_low() })
            }
        }
        #[cfg(feature = "unproven")]
        impl InputPin for PC15<Output<OpenDrain>> {
            type Error = Infallible;
            fn is_high(&self) -> Result<bool, Self::Error> {
                Ok(!self.is_low()?)
            }
            fn is_low(&self) -> Result<bool, Self::Error> {
                Ok(unsafe { (*GPIOC::ptr()).idr.read().idr15().is_low() })
            }
        }
        #[cfg(feature = "unproven")]
        impl<MODE> StatefulOutputPin for PC15<Output<MODE>> {
            fn is_set_high(&self) -> Result<bool, Self::Error> {
                self.is_set_low().map(|b| !b)
            }
            fn is_set_low(&self) -> Result<bool, Self::Error> {
                Ok(unsafe { (*GPIOC::ptr()).odr.read().odr15().is_low() })
            }
        }
        #[cfg(feature = "unproven")]
        impl<MODE> toggleable::Default for PC15<Output<MODE>> {}
    }
    #[doc = "All Pins and associated functions for GPIO Bank: `GPIOD`"]
    pub mod gpiod {
        use core::marker::PhantomData;
        use core::convert::Infallible;
        use crate::hal::digital::v2::OutputPin;
        #[cfg(feature = "unproven")]
        use crate::hal::digital::v2::InputPin;
        #[cfg(feature = "unproven")]
        use crate::hal::digital::v2::StatefulOutputPin;
        #[cfg(feature = "unproven")]
        use crate::hal::digital::v2::toggleable;
        use crate::pac::{gpioc, GPIOD};
        use crate::rcc::AHB;
        #[allow(unused_imports)]
        use super::{
            AF0, AF1, AF2, AF3, AF4, AF5, AF6, AF7, AF8, AF9, AF10, AF11, AF12, AF13, AF14, AF15,
        };
        use super::{
            Floating, GpioExt, Input, OpenDrain, Output, Analog, PullDown, PullUp, PushPull, PXx,
            Gpio,
        };
        #[doc = " GPIO parts"]
        pub struct Parts {
            #[doc = " Opaque AFRH register"]
            pub afrh: AFRH,
            #[doc = " Opaque AFRL register"]
            pub afrl: AFRL,
            #[doc = " Opaque MODER register"]
            pub moder: MODER,
            #[doc = " Opaque OTYPER register"]
            pub otyper: OTYPER,
            #[doc = " Opaque PUPDR register"]
            pub pupdr: PUPDR,
            #[doc = " Pin"]
            pub pd0: PD0<Input<Floating>>,
            #[doc = " Pin"]
            pub pd1: PD1<Input<Floating>>,
            #[doc = " Pin"]
            pub pd2: PD2<Input<Floating>>,
            #[doc = " Pin"]
            pub pd3: PD3<Input<Floating>>,
            #[doc = " Pin"]
            pub pd4: PD4<Input<Floating>>,
            #[doc = " Pin"]
            pub pd5: PD5<Input<Floating>>,
            #[doc = " Pin"]
            pub pd6: PD6<Input<Floating>>,
            #[doc = " Pin"]
            pub pd7: PD7<Input<Floating>>,
            #[doc = " Pin"]
            pub pd8: PD8<Input<Floating>>,
            #[doc = " Pin"]
            pub pd9: PD9<Input<Floating>>,
            #[doc = " Pin"]
            pub pd10: PD10<Input<Floating>>,
            #[doc = " Pin"]
            pub pd11: PD11<Input<Floating>>,
            #[doc = " Pin"]
            pub pd12: PD12<Input<Floating>>,
            #[doc = " Pin"]
            pub pd13: PD13<Input<Floating>>,
            #[doc = " Pin"]
            pub pd14: PD14<Input<Floating>>,
            #[doc = " Pin"]
            pub pd15: PD15<Input<Floating>>,
        }
        impl GpioExt for GPIOD {
            type Parts = Parts;
            fn split(self, ahb: &mut AHB) -> Parts {
                ahb.enr().modify(|_, w| w.iopden().set_bit());
                ahb.rstr().modify(|_, w| w.iopdrst().set_bit());
                ahb.rstr().modify(|_, w| w.iopdrst().clear_bit());
                Parts {
                    afrh: AFRH { _0: () },
                    afrl: AFRL { _0: () },
                    moder: MODER { _0: () },
                    otyper: OTYPER { _0: () },
                    pupdr: PUPDR { _0: () },
                    pd0: PD0 { _mode: PhantomData },
                    pd1: PD1 { _mode: PhantomData },
                    pd2: PD2 { _mode: PhantomData },
                    pd3: PD3 { _mode: PhantomData },
                    pd4: PD4 { _mode: PhantomData },
                    pd5: PD5 { _mode: PhantomData },
                    pd6: PD6 { _mode: PhantomData },
                    pd7: PD7 { _mode: PhantomData },
                    pd8: PD8 { _mode: PhantomData },
                    pd9: PD9 { _mode: PhantomData },
                    pd10: PD10 { _mode: PhantomData },
                    pd11: PD11 { _mode: PhantomData },
                    pd12: PD12 { _mode: PhantomData },
                    pd13: PD13 { _mode: PhantomData },
                    pd14: PD14 { _mode: PhantomData },
                    pd15: PD15 { _mode: PhantomData },
                }
            }
        }
        #[doc = " Opaque AFRL register"]
        pub struct AFRL {
            _0: (),
        }
        impl AFRL {
            #[allow(dead_code)]
            pub(crate) fn afr(&mut self) -> &gpioc::AFRL {
                unsafe { &(*GPIOD::ptr()).afrl }
            }
        }
        #[doc = " Opaque AFRH register"]
        pub struct AFRH {
            _0: (),
        }
        impl AFRH {
            #[allow(dead_code)]
            pub(crate) fn afr(&mut self) -> &gpioc::AFRH {
                unsafe { &(*GPIOD::ptr()).afrh }
            }
        }
        #[doc = " Opaque MODER register"]
        pub struct MODER {
            _0: (),
        }
        impl MODER {
            pub(crate) fn moder(&mut self) -> &gpioc::MODER {
                unsafe { &(*GPIOD::ptr()).moder }
            }
        }
        #[doc = " Opaque OTYPER register"]
        pub struct OTYPER {
            _0: (),
        }
        impl OTYPER {
            pub(crate) fn otyper(&mut self) -> &gpioc::OTYPER {
                unsafe { &(*GPIOD::ptr()).otyper }
            }
        }
        #[doc = " Opaque PUPDR register"]
        pub struct PUPDR {
            _0: (),
        }
        impl PUPDR {
            pub(crate) fn pupdr(&mut self) -> &gpioc::PUPDR {
                unsafe { &(*GPIOD::ptr()).pupdr }
            }
        }
        #[doc = " Partially erased pin"]
        pub struct PDx<MODE> {
            i: u8,
            _mode: PhantomData<MODE>,
        }
        impl<MODE> PDx<MODE> {
            #[doc = " Erases the port letter from the type"]
            #[doc = ""]
            #[doc = " This is useful when you want to collect the pins into an array where you"]
            #[doc = " need all the elements to have the same type"]
            pub fn downgrade(self) -> PXx<MODE> {
                PXx {
                    i: self.i,
                    gpio: Gpio::GPIOD,
                    _mode: self._mode,
                }
            }
        }
        impl<MODE> OutputPin for PDx<Output<MODE>> {
            type Error = Infallible;
            fn set_high(&mut self) -> Result<(), Self::Error> {
                unsafe { (*GPIOD::ptr()).bsrr.write(|w| w.bits(1 << self.i)) }
                Ok(())
            }
            fn set_low(&mut self) -> Result<(), Self::Error> {
                unsafe { (*GPIOD::ptr()).bsrr.write(|w| w.bits(1 << (16 + self.i))) }
                Ok(())
            }
        }
        #[cfg(feature = "unproven")]
        impl<MODE> InputPin for PDx<Input<MODE>> {
            type Error = Infallible;
            fn is_high(&self) -> Result<bool, Self::Error> {
                Ok(!self.is_low()?)
            }
            fn is_low(&self) -> Result<bool, Self::Error> {
                Ok(unsafe { (*GPIOD::ptr()).idr.read().bits() & (1 << self.i) == 0 })
            }
        }
        #[cfg(feature = "unproven")]
        impl InputPin for PDx<Output<OpenDrain>> {
            type Error = Infallible;
            fn is_high(&self) -> Result<bool, Self::Error> {
                Ok(!self.is_low()?)
            }
            fn is_low(&self) -> Result<bool, Self::Error> {
                Ok(unsafe { (*GPIOD::ptr()).idr.read().bits() & (1 << self.i) == 0 })
            }
        }
        #[cfg(feature = "unproven")]
        impl<MODE> StatefulOutputPin for PDx<Output<MODE>> {
            fn is_set_high(&self) -> Result<bool, Self::Error> {
                self.is_set_low().map(|b| !b)
            }
            fn is_set_low(&self) -> Result<bool, Self::Error> {
                Ok(unsafe { (*GPIOD::ptr()).odr.read().bits() & (1 << self.i) == 0 })
            }
        }
        #[cfg(feature = "unproven")]
        impl<MODE> toggleable::Default for PDx<Output<MODE>> {}
        #[doc = "Pin `PD0`"]
        pub struct PD0<MODE> {
            _mode: PhantomData<MODE>,
        }
        impl<MODE> PD0<MODE> {
            #[doc = "Configures `PD0` to serve as alternate function: `AF1`"]
            pub fn into_af1(self, moder: &mut MODER, afr: &mut AFRL) -> PD0<AF1> {
                moder.moder().modify(|_, w| w.moder0().alternate());
                afr.afr().modify(|_, w| w.afrl0().af1());
                PD0 { _mode: PhantomData }
            }
            #[doc = "Configures `PD0` to serve as alternate function: `AF7`"]
            pub fn into_af7(self, moder: &mut MODER, afr: &mut AFRL) -> PD0<AF7> {
                moder.moder().modify(|_, w| w.moder0().alternate());
                afr.afr().modify(|_, w| w.afrl0().af7());
                PD0 { _mode: PhantomData }
            }
            #[doc = " Configures the pin to operate as a floating input pin"]
            pub fn into_floating_input(
                self,
                moder: &mut MODER,
                pupdr: &mut PUPDR,
            ) -> PD0<Input<Floating>> {
                moder.moder().modify(|_, w| w.moder0().input());
                pupdr.pupdr().modify(|_, w| w.pupdr0().floating());
                PD0 { _mode: PhantomData }
            }
            #[doc = " Configures the pin to operate as a pulled down input pin"]
            pub fn into_pull_down_input(
                self,
                moder: &mut MODER,
                pupdr: &mut PUPDR,
            ) -> PD0<Input<PullDown>> {
                moder.moder().modify(|_, w| w.moder0().input());
                pupdr.pupdr().modify(|_, w| w.pupdr0().pull_down());
                PD0 { _mode: PhantomData }
            }
            #[doc = " Configures the pin to operate as a pulled up input pin"]
            pub fn into_pull_up_input(
                self,
                moder: &mut MODER,
                pupdr: &mut PUPDR,
            ) -> PD0<Input<PullUp>> {
                moder.moder().modify(|_, w| w.moder0().input());
                pupdr.pupdr().modify(|_, w| w.pupdr0().pull_up());
                PD0 { _mode: PhantomData }
            }
            #[doc = " Configures the pin to operate as an open drain output pin"]
            pub fn into_open_drain_output(
                self,
                moder: &mut MODER,
                otyper: &mut OTYPER,
            ) -> PD0<Output<OpenDrain>> {
                moder.moder().modify(|_, w| w.moder0().output());
                otyper.otyper().modify(|_, w| w.ot0().open_drain());
                PD0 { _mode: PhantomData }
            }
            #[doc = " Configures the pin to operate as an push pull output pin"]
            pub fn into_push_pull_output(
                self,
                moder: &mut MODER,
                otyper: &mut OTYPER,
            ) -> PD0<Output<PushPull>> {
                moder.moder().modify(|_, w| w.moder0().output());
                otyper.otyper().modify(|_, w| w.ot0().push_pull());
                PD0 { _mode: PhantomData }
            }
            #[doc = " Configures the pin to operate as analog, with disabled schmitt trigger."]
            #[doc = " This mode is suitable when the pin is connected to the DAC or ADC."]
            pub fn into_analog(self, moder: &mut MODER, pupdr: &mut PUPDR) -> PD0<Analog> {
                moder.moder().modify(|_, w| w.moder0().analog());
                pupdr.pupdr().modify(|_, w| w.pupdr0().floating());
                PD0 { _mode: PhantomData }
            }
        }
        impl PD0<Output<OpenDrain>> {
            #[doc = " Enables / disables the internal pull up"]
            pub fn internal_pull_up(&mut self, pupdr: &mut PUPDR, on: bool) {
                pupdr.pupdr().modify(|_, w| {
                    if on {
                        w.pupdr0().pull_up()
                    } else {
                        w.pupdr0().floating()
                    }
                });
            }
        }
        impl<MODE> PD0<Output<MODE>> {
            #[doc = " Erases the pin number from the type"]
            #[doc = ""]
            #[doc = " This is useful when you want to collect the pins into an array where you"]
            #[doc = " need all the elements to have the same type"]
            pub fn downgrade(self) -> PDx<Output<MODE>> {
                PDx {
                    i: 0,
                    _mode: self._mode,
                }
            }
        }
        impl<MODE> PD0<Input<MODE>> {
            #[doc = " Erases the pin number from the type"]
            #[doc = ""]
            #[doc = " This is useful when you want to collect the pins into an array where you"]
            #[doc = " need all the elements to have the same type"]
            pub fn downgrade(self) -> PDx<Input<MODE>> {
                PDx {
                    i: 0,
                    _mode: self._mode,
                }
            }
        }
        impl<MODE> OutputPin for PD0<Output<MODE>> {
            type Error = Infallible;
            fn set_high(&mut self) -> Result<(), Self::Error> {
                unsafe { (*GPIOD::ptr()).bsrr.write(|w| w.bs0().set()) }
                Ok(())
            }
            fn set_low(&mut self) -> Result<(), Self::Error> {
                unsafe { (*GPIOD::ptr()).bsrr.write(|w| w.br0().reset()) }
                Ok(())
            }
        }
        #[cfg(feature = "unproven")]
        impl<MODE> InputPin for PD0<Input<MODE>> {
            type Error = Infallible;
            fn is_high(&self) -> Result<bool, Self::Error> {
                Ok(!self.is_low()?)
            }
            fn is_low(&self) -> Result<bool, Self::Error> {
                Ok(unsafe { (*GPIOD::ptr()).idr.read().idr0().is_low() })
            }
        }
        #[cfg(feature = "unproven")]
        impl InputPin for PD0<Output<OpenDrain>> {
            type Error = Infallible;
            fn is_high(&self) -> Result<bool, Self::Error> {
                Ok(!self.is_low()?)
            }
            fn is_low(&self) -> Result<bool, Self::Error> {
                Ok(unsafe { (*GPIOD::ptr()).idr.read().idr0().is_low() })
            }
        }
        #[cfg(feature = "unproven")]
        impl<MODE> StatefulOutputPin for PD0<Output<MODE>> {
            fn is_set_high(&self) -> Result<bool, Self::Error> {
                self.is_set_low().map(|b| !b)
            }
            fn is_set_low(&self) -> Result<bool, Self::Error> {
                Ok(unsafe { (*GPIOD::ptr()).odr.read().odr0().is_low() })
            }
        }
        #[cfg(feature = "unproven")]
        impl<MODE> toggleable::Default for PD0<Output<MODE>> {}
        #[doc = "Pin `PD1`"]
        pub struct PD1<MODE> {
            _mode: PhantomData<MODE>,
        }
        impl<MODE> PD1<MODE> {
            #[doc = "Configures `PD1` to serve as alternate function: `AF1`"]
            pub fn into_af1(self, moder: &mut MODER, afr: &mut AFRL) -> PD1<AF1> {
                moder.moder().modify(|_, w| w.moder1().alternate());
                afr.afr().modify(|_, w| w.afrl1().af1());
                PD1 { _mode: PhantomData }
            }
            #[doc = "Configures `PD1` to serve as alternate function: `AF4`"]
            pub fn into_af4(self, moder: &mut MODER, afr: &mut AFRL) -> PD1<AF4> {
                moder.moder().modify(|_, w| w.moder1().alternate());
                afr.afr().modify(|_, w| w.afrl1().af4());
                PD1 { _mode: PhantomData }
            }
            #[doc = "Configures `PD1` to serve as alternate function: `AF6`"]
            pub fn into_af6(self, moder: &mut MODER, afr: &mut AFRL) -> PD1<AF6> {
                moder.moder().modify(|_, w| w.moder1().alternate());
                afr.afr().modify(|_, w| w.afrl1().af6());
                PD1 { _mode: PhantomData }
            }
            #[doc = "Configures `PD1` to serve as alternate function: `AF7`"]
            pub fn into_af7(self, moder: &mut MODER, afr: &mut AFRL) -> PD1<AF7> {
                moder.moder().modify(|_, w| w.moder1().alternate());
                afr.afr().modify(|_, w| w.afrl1().af7());
                PD1 { _mode: PhantomData }
            }
            #[doc = " Configures the pin to operate as a floating input pin"]
            pub fn into_floating_input(
                self,
                moder: &mut MODER,
                pupdr: &mut PUPDR,
            ) -> PD1<Input<Floating>> {
                moder.moder().modify(|_, w| w.moder1().input());
                pupdr.pupdr().modify(|_, w| w.pupdr1().floating());
                PD1 { _mode: PhantomData }
            }
            #[doc = " Configures the pin to operate as a pulled down input pin"]
            pub fn into_pull_down_input(
                self,
                moder: &mut MODER,
                pupdr: &mut PUPDR,
            ) -> PD1<Input<PullDown>> {
                moder.moder().modify(|_, w| w.moder1().input());
                pupdr.pupdr().modify(|_, w| w.pupdr1().pull_down());
                PD1 { _mode: PhantomData }
            }
            #[doc = " Configures the pin to operate as a pulled up input pin"]
            pub fn into_pull_up_input(
                self,
                moder: &mut MODER,
                pupdr: &mut PUPDR,
            ) -> PD1<Input<PullUp>> {
                moder.moder().modify(|_, w| w.moder1().input());
                pupdr.pupdr().modify(|_, w| w.pupdr1().pull_up());
                PD1 { _mode: PhantomData }
            }
            #[doc = " Configures the pin to operate as an open drain output pin"]
            pub fn into_open_drain_output(
                self,
                moder: &mut MODER,
                otyper: &mut OTYPER,
            ) -> PD1<Output<OpenDrain>> {
                moder.moder().modify(|_, w| w.moder1().output());
                otyper.otyper().modify(|_, w| w.ot1().open_drain());
                PD1 { _mode: PhantomData }
            }
            #[doc = " Configures the pin to operate as an push pull output pin"]
            pub fn into_push_pull_output(
                self,
                moder: &mut MODER,
                otyper: &mut OTYPER,
            ) -> PD1<Output<PushPull>> {
                moder.moder().modify(|_, w| w.moder1().output());
                otyper.otyper().modify(|_, w| w.ot1().push_pull());
                PD1 { _mode: PhantomData }
            }
            #[doc = " Configures the pin to operate as analog, with disabled schmitt trigger."]
            #[doc = " This mode is suitable when the pin is connected to the DAC or ADC."]
            pub fn into_analog(self, moder: &mut MODER, pupdr: &mut PUPDR) -> PD1<Analog> {
                moder.moder().modify(|_, w| w.moder1().analog());
                pupdr.pupdr().modify(|_, w| w.pupdr1().floating());
                PD1 { _mode: PhantomData }
            }
        }
        impl PD1<Output<OpenDrain>> {
            #[doc = " Enables / disables the internal pull up"]
            pub fn internal_pull_up(&mut self, pupdr: &mut PUPDR, on: bool) {
                pupdr.pupdr().modify(|_, w| {
                    if on {
                        w.pupdr1().pull_up()
                    } else {
                        w.pupdr1().floating()
                    }
                });
            }
        }
        impl<MODE> PD1<Output<MODE>> {
            #[doc = " Erases the pin number from the type"]
            #[doc = ""]
            #[doc = " This is useful when you want to collect the pins into an array where you"]
            #[doc = " need all the elements to have the same type"]
            pub fn downgrade(self) -> PDx<Output<MODE>> {
                PDx {
                    i: 1,
                    _mode: self._mode,
                }
            }
        }
        impl<MODE> PD1<Input<MODE>> {
            #[doc = " Erases the pin number from the type"]
            #[doc = ""]
            #[doc = " This is useful when you want to collect the pins into an array where you"]
            #[doc = " need all the elements to have the same type"]
            pub fn downgrade(self) -> PDx<Input<MODE>> {
                PDx {
                    i: 1,
                    _mode: self._mode,
                }
            }
        }
        impl<MODE> OutputPin for PD1<Output<MODE>> {
            type Error = Infallible;
            fn set_high(&mut self) -> Result<(), Self::Error> {
                unsafe { (*GPIOD::ptr()).bsrr.write(|w| w.bs1().set()) }
                Ok(())
            }
            fn set_low(&mut self) -> Result<(), Self::Error> {
                unsafe { (*GPIOD::ptr()).bsrr.write(|w| w.br1().reset()) }
                Ok(())
            }
        }
        #[cfg(feature = "unproven")]
        impl<MODE> InputPin for PD1<Input<MODE>> {
            type Error = Infallible;
            fn is_high(&self) -> Result<bool, Self::Error> {
                Ok(!self.is_low()?)
            }
            fn is_low(&self) -> Result<bool, Self::Error> {
                Ok(unsafe { (*GPIOD::ptr()).idr.read().idr1().is_low() })
            }
        }
        #[cfg(feature = "unproven")]
        impl InputPin for PD1<Output<OpenDrain>> {
            type Error = Infallible;
            fn is_high(&self) -> Result<bool, Self::Error> {
                Ok(!self.is_low()?)
            }
            fn is_low(&self) -> Result<bool, Self::Error> {
                Ok(unsafe { (*GPIOD::ptr()).idr.read().idr1().is_low() })
            }
        }
        #[cfg(feature = "unproven")]
        impl<MODE> StatefulOutputPin for PD1<Output<MODE>> {
            fn is_set_high(&self) -> Result<bool, Self::Error> {
                self.is_set_low().map(|b| !b)
            }
            fn is_set_low(&self) -> Result<bool, Self::Error> {
                Ok(unsafe { (*GPIOD::ptr()).odr.read().odr1().is_low() })
            }
        }
        #[cfg(feature = "unproven")]
        impl<MODE> toggleable::Default for PD1<Output<MODE>> {}
        #[doc = "Pin `PD2`"]
        pub struct PD2<MODE> {
            _mode: PhantomData<MODE>,
        }
        impl<MODE> PD2<MODE> {
            #[doc = "Configures `PD2` to serve as alternate function: `AF1`"]
            pub fn into_af1(self, moder: &mut MODER, afr: &mut AFRL) -> PD2<AF1> {
                moder.moder().modify(|_, w| w.moder2().alternate());
                afr.afr().modify(|_, w| w.afrl2().af1());
                PD2 { _mode: PhantomData }
            }
            #[doc = "Configures `PD2` to serve as alternate function: `AF2`"]
            pub fn into_af2(self, moder: &mut MODER, afr: &mut AFRL) -> PD2<AF2> {
                moder.moder().modify(|_, w| w.moder2().alternate());
                afr.afr().modify(|_, w| w.afrl2().af2());
                PD2 { _mode: PhantomData }
            }
            #[doc = "Configures `PD2` to serve as alternate function: `AF4`"]
            pub fn into_af4(self, moder: &mut MODER, afr: &mut AFRL) -> PD2<AF4> {
                moder.moder().modify(|_, w| w.moder2().alternate());
                afr.afr().modify(|_, w| w.afrl2().af4());
                PD2 { _mode: PhantomData }
            }
            #[doc = "Configures `PD2` to serve as alternate function: `AF5`"]
            pub fn into_af5(self, moder: &mut MODER, afr: &mut AFRL) -> PD2<AF5> {
                moder.moder().modify(|_, w| w.moder2().alternate());
                afr.afr().modify(|_, w| w.afrl2().af5());
                PD2 { _mode: PhantomData }
            }
            #[doc = " Configures the pin to operate as a floating input pin"]
            pub fn into_floating_input(
                self,
                moder: &mut MODER,
                pupdr: &mut PUPDR,
            ) -> PD2<Input<Floating>> {
                moder.moder().modify(|_, w| w.moder2().input());
                pupdr.pupdr().modify(|_, w| w.pupdr2().floating());
                PD2 { _mode: PhantomData }
            }
            #[doc = " Configures the pin to operate as a pulled down input pin"]
            pub fn into_pull_down_input(
                self,
                moder: &mut MODER,
                pupdr: &mut PUPDR,
            ) -> PD2<Input<PullDown>> {
                moder.moder().modify(|_, w| w.moder2().input());
                pupdr.pupdr().modify(|_, w| w.pupdr2().pull_down());
                PD2 { _mode: PhantomData }
            }
            #[doc = " Configures the pin to operate as a pulled up input pin"]
            pub fn into_pull_up_input(
                self,
                moder: &mut MODER,
                pupdr: &mut PUPDR,
            ) -> PD2<Input<PullUp>> {
                moder.moder().modify(|_, w| w.moder2().input());
                pupdr.pupdr().modify(|_, w| w.pupdr2().pull_up());
                PD2 { _mode: PhantomData }
            }
            #[doc = " Configures the pin to operate as an open drain output pin"]
            pub fn into_open_drain_output(
                self,
                moder: &mut MODER,
                otyper: &mut OTYPER,
            ) -> PD2<Output<OpenDrain>> {
                moder.moder().modify(|_, w| w.moder2().output());
                otyper.otyper().modify(|_, w| w.ot2().open_drain());
                PD2 { _mode: PhantomData }
            }
            #[doc = " Configures the pin to operate as an push pull output pin"]
            pub fn into_push_pull_output(
                self,
                moder: &mut MODER,
                otyper: &mut OTYPER,
            ) -> PD2<Output<PushPull>> {
                moder.moder().modify(|_, w| w.moder2().output());
                otyper.otyper().modify(|_, w| w.ot2().push_pull());
                PD2 { _mode: PhantomData }
            }
            #[doc = " Configures the pin to operate as analog, with disabled schmitt trigger."]
            #[doc = " This mode is suitable when the pin is connected to the DAC or ADC."]
            pub fn into_analog(self, moder: &mut MODER, pupdr: &mut PUPDR) -> PD2<Analog> {
                moder.moder().modify(|_, w| w.moder2().analog());
                pupdr.pupdr().modify(|_, w| w.pupdr2().floating());
                PD2 { _mode: PhantomData }
            }
        }
        impl PD2<Output<OpenDrain>> {
            #[doc = " Enables / disables the internal pull up"]
            pub fn internal_pull_up(&mut self, pupdr: &mut PUPDR, on: bool) {
                pupdr.pupdr().modify(|_, w| {
                    if on {
                        w.pupdr2().pull_up()
                    } else {
                        w.pupdr2().floating()
                    }
                });
            }
        }
        impl<MODE> PD2<Output<MODE>> {
            #[doc = " Erases the pin number from the type"]
            #[doc = ""]
            #[doc = " This is useful when you want to collect the pins into an array where you"]
            #[doc = " need all the elements to have the same type"]
            pub fn downgrade(self) -> PDx<Output<MODE>> {
                PDx {
                    i: 2,
                    _mode: self._mode,
                }
            }
        }
        impl<MODE> PD2<Input<MODE>> {
            #[doc = " Erases the pin number from the type"]
            #[doc = ""]
            #[doc = " This is useful when you want to collect the pins into an array where you"]
            #[doc = " need all the elements to have the same type"]
            pub fn downgrade(self) -> PDx<Input<MODE>> {
                PDx {
                    i: 2,
                    _mode: self._mode,
                }
            }
        }
        impl<MODE> OutputPin for PD2<Output<MODE>> {
            type Error = Infallible;
            fn set_high(&mut self) -> Result<(), Self::Error> {
                unsafe { (*GPIOD::ptr()).bsrr.write(|w| w.bs2().set()) }
                Ok(())
            }
            fn set_low(&mut self) -> Result<(), Self::Error> {
                unsafe { (*GPIOD::ptr()).bsrr.write(|w| w.br2().reset()) }
                Ok(())
            }
        }
        #[cfg(feature = "unproven")]
        impl<MODE> InputPin for PD2<Input<MODE>> {
            type Error = Infallible;
            fn is_high(&self) -> Result<bool, Self::Error> {
                Ok(!self.is_low()?)
            }
            fn is_low(&self) -> Result<bool, Self::Error> {
                Ok(unsafe { (*GPIOD::ptr()).idr.read().idr2().is_low() })
            }
        }
        #[cfg(feature = "unproven")]
        impl InputPin for PD2<Output<OpenDrain>> {
            type Error = Infallible;
            fn is_high(&self) -> Result<bool, Self::Error> {
                Ok(!self.is_low()?)
            }
            fn is_low(&self) -> Result<bool, Self::Error> {
                Ok(unsafe { (*GPIOD::ptr()).idr.read().idr2().is_low() })
            }
        }
        #[cfg(feature = "unproven")]
        impl<MODE> StatefulOutputPin for PD2<Output<MODE>> {
            fn is_set_high(&self) -> Result<bool, Self::Error> {
                self.is_set_low().map(|b| !b)
            }
            fn is_set_low(&self) -> Result<bool, Self::Error> {
                Ok(unsafe { (*GPIOD::ptr()).odr.read().odr2().is_low() })
            }
        }
        #[cfg(feature = "unproven")]
        impl<MODE> toggleable::Default for PD2<Output<MODE>> {}
        #[doc = "Pin `PD3`"]
        pub struct PD3<MODE> {
            _mode: PhantomData<MODE>,
        }
        impl<MODE> PD3<MODE> {
            #[doc = "Configures `PD3` to serve as alternate function: `AF1`"]
            pub fn into_af1(self, moder: &mut MODER, afr: &mut AFRL) -> PD3<AF1> {
                moder.moder().modify(|_, w| w.moder3().alternate());
                afr.afr().modify(|_, w| w.afrl3().af1());
                PD3 { _mode: PhantomData }
            }
            #[doc = "Configures `PD3` to serve as alternate function: `AF2`"]
            pub fn into_af2(self, moder: &mut MODER, afr: &mut AFRL) -> PD3<AF2> {
                moder.moder().modify(|_, w| w.moder3().alternate());
                afr.afr().modify(|_, w| w.afrl3().af2());
                PD3 { _mode: PhantomData }
            }
            #[doc = "Configures `PD3` to serve as alternate function: `AF7`"]
            pub fn into_af7(self, moder: &mut MODER, afr: &mut AFRL) -> PD3<AF7> {
                moder.moder().modify(|_, w| w.moder3().alternate());
                afr.afr().modify(|_, w| w.afrl3().af7());
                PD3 { _mode: PhantomData }
            }
            #[doc = " Configures the pin to operate as a floating input pin"]
            pub fn into_floating_input(
                self,
                moder: &mut MODER,
                pupdr: &mut PUPDR,
            ) -> PD3<Input<Floating>> {
                moder.moder().modify(|_, w| w.moder3().input());
                pupdr.pupdr().modify(|_, w| w.pupdr3().floating());
                PD3 { _mode: PhantomData }
            }
            #[doc = " Configures the pin to operate as a pulled down input pin"]
            pub fn into_pull_down_input(
                self,
                moder: &mut MODER,
                pupdr: &mut PUPDR,
            ) -> PD3<Input<PullDown>> {
                moder.moder().modify(|_, w| w.moder3().input());
                pupdr.pupdr().modify(|_, w| w.pupdr3().pull_down());
                PD3 { _mode: PhantomData }
            }
            #[doc = " Configures the pin to operate as a pulled up input pin"]
            pub fn into_pull_up_input(
                self,
                moder: &mut MODER,
                pupdr: &mut PUPDR,
            ) -> PD3<Input<PullUp>> {
                moder.moder().modify(|_, w| w.moder3().input());
                pupdr.pupdr().modify(|_, w| w.pupdr3().pull_up());
                PD3 { _mode: PhantomData }
            }
            #[doc = " Configures the pin to operate as an open drain output pin"]
            pub fn into_open_drain_output(
                self,
                moder: &mut MODER,
                otyper: &mut OTYPER,
            ) -> PD3<Output<OpenDrain>> {
                moder.moder().modify(|_, w| w.moder3().output());
                otyper.otyper().modify(|_, w| w.ot3().open_drain());
                PD3 { _mode: PhantomData }
            }
            #[doc = " Configures the pin to operate as an push pull output pin"]
            pub fn into_push_pull_output(
                self,
                moder: &mut MODER,
                otyper: &mut OTYPER,
            ) -> PD3<Output<PushPull>> {
                moder.moder().modify(|_, w| w.moder3().output());
                otyper.otyper().modify(|_, w| w.ot3().push_pull());
                PD3 { _mode: PhantomData }
            }
            #[doc = " Configures the pin to operate as analog, with disabled schmitt trigger."]
            #[doc = " This mode is suitable when the pin is connected to the DAC or ADC."]
            pub fn into_analog(self, moder: &mut MODER, pupdr: &mut PUPDR) -> PD3<Analog> {
                moder.moder().modify(|_, w| w.moder3().analog());
                pupdr.pupdr().modify(|_, w| w.pupdr3().floating());
                PD3 { _mode: PhantomData }
            }
        }
        impl PD3<Output<OpenDrain>> {
            #[doc = " Enables / disables the internal pull up"]
            pub fn internal_pull_up(&mut self, pupdr: &mut PUPDR, on: bool) {
                pupdr.pupdr().modify(|_, w| {
                    if on {
                        w.pupdr3().pull_up()
                    } else {
                        w.pupdr3().floating()
                    }
                });
            }
        }
        impl<MODE> PD3<Output<MODE>> {
            #[doc = " Erases the pin number from the type"]
            #[doc = ""]
            #[doc = " This is useful when you want to collect the pins into an array where you"]
            #[doc = " need all the elements to have the same type"]
            pub fn downgrade(self) -> PDx<Output<MODE>> {
                PDx {
                    i: 3,
                    _mode: self._mode,
                }
            }
        }
        impl<MODE> PD3<Input<MODE>> {
            #[doc = " Erases the pin number from the type"]
            #[doc = ""]
            #[doc = " This is useful when you want to collect the pins into an array where you"]
            #[doc = " need all the elements to have the same type"]
            pub fn downgrade(self) -> PDx<Input<MODE>> {
                PDx {
                    i: 3,
                    _mode: self._mode,
                }
            }
        }
        impl<MODE> OutputPin for PD3<Output<MODE>> {
            type Error = Infallible;
            fn set_high(&mut self) -> Result<(), Self::Error> {
                unsafe { (*GPIOD::ptr()).bsrr.write(|w| w.bs3().set()) }
                Ok(())
            }
            fn set_low(&mut self) -> Result<(), Self::Error> {
                unsafe { (*GPIOD::ptr()).bsrr.write(|w| w.br3().reset()) }
                Ok(())
            }
        }
        #[cfg(feature = "unproven")]
        impl<MODE> InputPin for PD3<Input<MODE>> {
            type Error = Infallible;
            fn is_high(&self) -> Result<bool, Self::Error> {
                Ok(!self.is_low()?)
            }
            fn is_low(&self) -> Result<bool, Self::Error> {
                Ok(unsafe { (*GPIOD::ptr()).idr.read().idr3().is_low() })
            }
        }
        #[cfg(feature = "unproven")]
        impl InputPin for PD3<Output<OpenDrain>> {
            type Error = Infallible;
            fn is_high(&self) -> Result<bool, Self::Error> {
                Ok(!self.is_low()?)
            }
            fn is_low(&self) -> Result<bool, Self::Error> {
                Ok(unsafe { (*GPIOD::ptr()).idr.read().idr3().is_low() })
            }
        }
        #[cfg(feature = "unproven")]
        impl<MODE> StatefulOutputPin for PD3<Output<MODE>> {
            fn is_set_high(&self) -> Result<bool, Self::Error> {
                self.is_set_low().map(|b| !b)
            }
            fn is_set_low(&self) -> Result<bool, Self::Error> {
                Ok(unsafe { (*GPIOD::ptr()).odr.read().odr3().is_low() })
            }
        }
        #[cfg(feature = "unproven")]
        impl<MODE> toggleable::Default for PD3<Output<MODE>> {}
        #[doc = "Pin `PD4`"]
        pub struct PD4<MODE> {
            _mode: PhantomData<MODE>,
        }
        impl<MODE> PD4<MODE> {
            #[doc = "Configures `PD4` to serve as alternate function: `AF1`"]
            pub fn into_af1(self, moder: &mut MODER, afr: &mut AFRL) -> PD4<AF1> {
                moder.moder().modify(|_, w| w.moder4().alternate());
                afr.afr().modify(|_, w| w.afrl4().af1());
                PD4 { _mode: PhantomData }
            }
            #[doc = "Configures `PD4` to serve as alternate function: `AF2`"]
            pub fn into_af2(self, moder: &mut MODER, afr: &mut AFRL) -> PD4<AF2> {
                moder.moder().modify(|_, w| w.moder4().alternate());
                afr.afr().modify(|_, w| w.afrl4().af2());
                PD4 { _mode: PhantomData }
            }
            #[doc = "Configures `PD4` to serve as alternate function: `AF7`"]
            pub fn into_af7(self, moder: &mut MODER, afr: &mut AFRL) -> PD4<AF7> {
                moder.moder().modify(|_, w| w.moder4().alternate());
                afr.afr().modify(|_, w| w.afrl4().af7());
                PD4 { _mode: PhantomData }
            }
            #[doc = " Configures the pin to operate as a floating input pin"]
            pub fn into_floating_input(
                self,
                moder: &mut MODER,
                pupdr: &mut PUPDR,
            ) -> PD4<Input<Floating>> {
                moder.moder().modify(|_, w| w.moder4().input());
                pupdr.pupdr().modify(|_, w| w.pupdr4().floating());
                PD4 { _mode: PhantomData }
            }
            #[doc = " Configures the pin to operate as a pulled down input pin"]
            pub fn into_pull_down_input(
                self,
                moder: &mut MODER,
                pupdr: &mut PUPDR,
            ) -> PD4<Input<PullDown>> {
                moder.moder().modify(|_, w| w.moder4().input());
                pupdr.pupdr().modify(|_, w| w.pupdr4().pull_down());
                PD4 { _mode: PhantomData }
            }
            #[doc = " Configures the pin to operate as a pulled up input pin"]
            pub fn into_pull_up_input(
                self,
                moder: &mut MODER,
                pupdr: &mut PUPDR,
            ) -> PD4<Input<PullUp>> {
                moder.moder().modify(|_, w| w.moder4().input());
                pupdr.pupdr().modify(|_, w| w.pupdr4().pull_up());
                PD4 { _mode: PhantomData }
            }
            #[doc = " Configures the pin to operate as an open drain output pin"]
            pub fn into_open_drain_output(
                self,
                moder: &mut MODER,
                otyper: &mut OTYPER,
            ) -> PD4<Output<OpenDrain>> {
                moder.moder().modify(|_, w| w.moder4().output());
                otyper.otyper().modify(|_, w| w.ot4().open_drain());
                PD4 { _mode: PhantomData }
            }
            #[doc = " Configures the pin to operate as an push pull output pin"]
            pub fn into_push_pull_output(
                self,
                moder: &mut MODER,
                otyper: &mut OTYPER,
            ) -> PD4<Output<PushPull>> {
                moder.moder().modify(|_, w| w.moder4().output());
                otyper.otyper().modify(|_, w| w.ot4().push_pull());
                PD4 { _mode: PhantomData }
            }
            #[doc = " Configures the pin to operate as analog, with disabled schmitt trigger."]
            #[doc = " This mode is suitable when the pin is connected to the DAC or ADC."]
            pub fn into_analog(self, moder: &mut MODER, pupdr: &mut PUPDR) -> PD4<Analog> {
                moder.moder().modify(|_, w| w.moder4().analog());
                pupdr.pupdr().modify(|_, w| w.pupdr4().floating());
                PD4 { _mode: PhantomData }
            }
        }
        impl PD4<Output<OpenDrain>> {
            #[doc = " Enables / disables the internal pull up"]
            pub fn internal_pull_up(&mut self, pupdr: &mut PUPDR, on: bool) {
                pupdr.pupdr().modify(|_, w| {
                    if on {
                        w.pupdr4().pull_up()
                    } else {
                        w.pupdr4().floating()
                    }
                });
            }
        }
        impl<MODE> PD4<Output<MODE>> {
            #[doc = " Erases the pin number from the type"]
            #[doc = ""]
            #[doc = " This is useful when you want to collect the pins into an array where you"]
            #[doc = " need all the elements to have the same type"]
            pub fn downgrade(self) -> PDx<Output<MODE>> {
                PDx {
                    i: 4,
                    _mode: self._mode,
                }
            }
        }
        impl<MODE> PD4<Input<MODE>> {
            #[doc = " Erases the pin number from the type"]
            #[doc = ""]
            #[doc = " This is useful when you want to collect the pins into an array where you"]
            #[doc = " need all the elements to have the same type"]
            pub fn downgrade(self) -> PDx<Input<MODE>> {
                PDx {
                    i: 4,
                    _mode: self._mode,
                }
            }
        }
        impl<MODE> OutputPin for PD4<Output<MODE>> {
            type Error = Infallible;
            fn set_high(&mut self) -> Result<(), Self::Error> {
                unsafe { (*GPIOD::ptr()).bsrr.write(|w| w.bs4().set()) }
                Ok(())
            }
            fn set_low(&mut self) -> Result<(), Self::Error> {
                unsafe { (*GPIOD::ptr()).bsrr.write(|w| w.br4().reset()) }
                Ok(())
            }
        }
        #[cfg(feature = "unproven")]
        impl<MODE> InputPin for PD4<Input<MODE>> {
            type Error = Infallible;
            fn is_high(&self) -> Result<bool, Self::Error> {
                Ok(!self.is_low()?)
            }
            fn is_low(&self) -> Result<bool, Self::Error> {
                Ok(unsafe { (*GPIOD::ptr()).idr.read().idr4().is_low() })
            }
        }
        #[cfg(feature = "unproven")]
        impl InputPin for PD4<Output<OpenDrain>> {
            type Error = Infallible;
            fn is_high(&self) -> Result<bool, Self::Error> {
                Ok(!self.is_low()?)
            }
            fn is_low(&self) -> Result<bool, Self::Error> {
                Ok(unsafe { (*GPIOD::ptr()).idr.read().idr4().is_low() })
            }
        }
        #[cfg(feature = "unproven")]
        impl<MODE> StatefulOutputPin for PD4<Output<MODE>> {
            fn is_set_high(&self) -> Result<bool, Self::Error> {
                self.is_set_low().map(|b| !b)
            }
            fn is_set_low(&self) -> Result<bool, Self::Error> {
                Ok(unsafe { (*GPIOD::ptr()).odr.read().odr4().is_low() })
            }
        }
        #[cfg(feature = "unproven")]
        impl<MODE> toggleable::Default for PD4<Output<MODE>> {}
        #[doc = "Pin `PD5`"]
        pub struct PD5<MODE> {
            _mode: PhantomData<MODE>,
        }
        impl<MODE> PD5<MODE> {
            #[doc = "Configures `PD5` to serve as alternate function: `AF1`"]
            pub fn into_af1(self, moder: &mut MODER, afr: &mut AFRL) -> PD5<AF1> {
                moder.moder().modify(|_, w| w.moder5().alternate());
                afr.afr().modify(|_, w| w.afrl5().af1());
                PD5 { _mode: PhantomData }
            }
            #[doc = "Configures `PD5` to serve as alternate function: `AF7`"]
            pub fn into_af7(self, moder: &mut MODER, afr: &mut AFRL) -> PD5<AF7> {
                moder.moder().modify(|_, w| w.moder5().alternate());
                afr.afr().modify(|_, w| w.afrl5().af7());
                PD5 { _mode: PhantomData }
            }
            #[doc = " Configures the pin to operate as a floating input pin"]
            pub fn into_floating_input(
                self,
                moder: &mut MODER,
                pupdr: &mut PUPDR,
            ) -> PD5<Input<Floating>> {
                moder.moder().modify(|_, w| w.moder5().input());
                pupdr.pupdr().modify(|_, w| w.pupdr5().floating());
                PD5 { _mode: PhantomData }
            }
            #[doc = " Configures the pin to operate as a pulled down input pin"]
            pub fn into_pull_down_input(
                self,
                moder: &mut MODER,
                pupdr: &mut PUPDR,
            ) -> PD5<Input<PullDown>> {
                moder.moder().modify(|_, w| w.moder5().input());
                pupdr.pupdr().modify(|_, w| w.pupdr5().pull_down());
                PD5 { _mode: PhantomData }
            }
            #[doc = " Configures the pin to operate as a pulled up input pin"]
            pub fn into_pull_up_input(
                self,
                moder: &mut MODER,
                pupdr: &mut PUPDR,
            ) -> PD5<Input<PullUp>> {
                moder.moder().modify(|_, w| w.moder5().input());
                pupdr.pupdr().modify(|_, w| w.pupdr5().pull_up());
                PD5 { _mode: PhantomData }
            }
            #[doc = " Configures the pin to operate as an open drain output pin"]
            pub fn into_open_drain_output(
                self,
                moder: &mut MODER,
                otyper: &mut OTYPER,
            ) -> PD5<Output<OpenDrain>> {
                moder.moder().modify(|_, w| w.moder5().output());
                otyper.otyper().modify(|_, w| w.ot5().open_drain());
                PD5 { _mode: PhantomData }
            }
            #[doc = " Configures the pin to operate as an push pull output pin"]
            pub fn into_push_pull_output(
                self,
                moder: &mut MODER,
                otyper: &mut OTYPER,
            ) -> PD5<Output<PushPull>> {
                moder.moder().modify(|_, w| w.moder5().output());
                otyper.otyper().modify(|_, w| w.ot5().push_pull());
                PD5 { _mode: PhantomData }
            }
            #[doc = " Configures the pin to operate as analog, with disabled schmitt trigger."]
            #[doc = " This mode is suitable when the pin is connected to the DAC or ADC."]
            pub fn into_analog(self, moder: &mut MODER, pupdr: &mut PUPDR) -> PD5<Analog> {
                moder.moder().modify(|_, w| w.moder5().analog());
                pupdr.pupdr().modify(|_, w| w.pupdr5().floating());
                PD5 { _mode: PhantomData }
            }
        }
        impl PD5<Output<OpenDrain>> {
            #[doc = " Enables / disables the internal pull up"]
            pub fn internal_pull_up(&mut self, pupdr: &mut PUPDR, on: bool) {
                pupdr.pupdr().modify(|_, w| {
                    if on {
                        w.pupdr5().pull_up()
                    } else {
                        w.pupdr5().floating()
                    }
                });
            }
        }
        impl<MODE> PD5<Output<MODE>> {
            #[doc = " Erases the pin number from the type"]
            #[doc = ""]
            #[doc = " This is useful when you want to collect the pins into an array where you"]
            #[doc = " need all the elements to have the same type"]
            pub fn downgrade(self) -> PDx<Output<MODE>> {
                PDx {
                    i: 5,
                    _mode: self._mode,
                }
            }
        }
        impl<MODE> PD5<Input<MODE>> {
            #[doc = " Erases the pin number from the type"]
            #[doc = ""]
            #[doc = " This is useful when you want to collect the pins into an array where you"]
            #[doc = " need all the elements to have the same type"]
            pub fn downgrade(self) -> PDx<Input<MODE>> {
                PDx {
                    i: 5,
                    _mode: self._mode,
                }
            }
        }
        impl<MODE> OutputPin for PD5<Output<MODE>> {
            type Error = Infallible;
            fn set_high(&mut self) -> Result<(), Self::Error> {
                unsafe { (*GPIOD::ptr()).bsrr.write(|w| w.bs5().set()) }
                Ok(())
            }
            fn set_low(&mut self) -> Result<(), Self::Error> {
                unsafe { (*GPIOD::ptr()).bsrr.write(|w| w.br5().reset()) }
                Ok(())
            }
        }
        #[cfg(feature = "unproven")]
        impl<MODE> InputPin for PD5<Input<MODE>> {
            type Error = Infallible;
            fn is_high(&self) -> Result<bool, Self::Error> {
                Ok(!self.is_low()?)
            }
            fn is_low(&self) -> Result<bool, Self::Error> {
                Ok(unsafe { (*GPIOD::ptr()).idr.read().idr5().is_low() })
            }
        }
        #[cfg(feature = "unproven")]
        impl InputPin for PD5<Output<OpenDrain>> {
            type Error = Infallible;
            fn is_high(&self) -> Result<bool, Self::Error> {
                Ok(!self.is_low()?)
            }
            fn is_low(&self) -> Result<bool, Self::Error> {
                Ok(unsafe { (*GPIOD::ptr()).idr.read().idr5().is_low() })
            }
        }
        #[cfg(feature = "unproven")]
        impl<MODE> StatefulOutputPin for PD5<Output<MODE>> {
            fn is_set_high(&self) -> Result<bool, Self::Error> {
                self.is_set_low().map(|b| !b)
            }
            fn is_set_low(&self) -> Result<bool, Self::Error> {
                Ok(unsafe { (*GPIOD::ptr()).odr.read().odr5().is_low() })
            }
        }
        #[cfg(feature = "unproven")]
        impl<MODE> toggleable::Default for PD5<Output<MODE>> {}
        #[doc = "Pin `PD6`"]
        pub struct PD6<MODE> {
            _mode: PhantomData<MODE>,
        }
        impl<MODE> PD6<MODE> {
            #[doc = "Configures `PD6` to serve as alternate function: `AF1`"]
            pub fn into_af1(self, moder: &mut MODER, afr: &mut AFRL) -> PD6<AF1> {
                moder.moder().modify(|_, w| w.moder6().alternate());
                afr.afr().modify(|_, w| w.afrl6().af1());
                PD6 { _mode: PhantomData }
            }
            #[doc = "Configures `PD6` to serve as alternate function: `AF2`"]
            pub fn into_af2(self, moder: &mut MODER, afr: &mut AFRL) -> PD6<AF2> {
                moder.moder().modify(|_, w| w.moder6().alternate());
                afr.afr().modify(|_, w| w.afrl6().af2());
                PD6 { _mode: PhantomData }
            }
            #[doc = "Configures `PD6` to serve as alternate function: `AF7`"]
            pub fn into_af7(self, moder: &mut MODER, afr: &mut AFRL) -> PD6<AF7> {
                moder.moder().modify(|_, w| w.moder6().alternate());
                afr.afr().modify(|_, w| w.afrl6().af7());
                PD6 { _mode: PhantomData }
            }
            #[doc = " Configures the pin to operate as a floating input pin"]
            pub fn into_floating_input(
                self,
                moder: &mut MODER,
                pupdr: &mut PUPDR,
            ) -> PD6<Input<Floating>> {
                moder.moder().modify(|_, w| w.moder6().input());
                pupdr.pupdr().modify(|_, w| w.pupdr6().floating());
                PD6 { _mode: PhantomData }
            }
            #[doc = " Configures the pin to operate as a pulled down input pin"]
            pub fn into_pull_down_input(
                self,
                moder: &mut MODER,
                pupdr: &mut PUPDR,
            ) -> PD6<Input<PullDown>> {
                moder.moder().modify(|_, w| w.moder6().input());
                pupdr.pupdr().modify(|_, w| w.pupdr6().pull_down());
                PD6 { _mode: PhantomData }
            }
            #[doc = " Configures the pin to operate as a pulled up input pin"]
            pub fn into_pull_up_input(
                self,
                moder: &mut MODER,
                pupdr: &mut PUPDR,
            ) -> PD6<Input<PullUp>> {
                moder.moder().modify(|_, w| w.moder6().input());
                pupdr.pupdr().modify(|_, w| w.pupdr6().pull_up());
                PD6 { _mode: PhantomData }
            }
            #[doc = " Configures the pin to operate as an open drain output pin"]
            pub fn into_open_drain_output(
                self,
                moder: &mut MODER,
                otyper: &mut OTYPER,
            ) -> PD6<Output<OpenDrain>> {
                moder.moder().modify(|_, w| w.moder6().output());
                otyper.otyper().modify(|_, w| w.ot6().open_drain());
                PD6 { _mode: PhantomData }
            }
            #[doc = " Configures the pin to operate as an push pull output pin"]
            pub fn into_push_pull_output(
                self,
                moder: &mut MODER,
                otyper: &mut OTYPER,
            ) -> PD6<Output<PushPull>> {
                moder.moder().modify(|_, w| w.moder6().output());
                otyper.otyper().modify(|_, w| w.ot6().push_pull());
                PD6 { _mode: PhantomData }
            }
            #[doc = " Configures the pin to operate as analog, with disabled schmitt trigger."]
            #[doc = " This mode is suitable when the pin is connected to the DAC or ADC."]
            pub fn into_analog(self, moder: &mut MODER, pupdr: &mut PUPDR) -> PD6<Analog> {
                moder.moder().modify(|_, w| w.moder6().analog());
                pupdr.pupdr().modify(|_, w| w.pupdr6().floating());
                PD6 { _mode: PhantomData }
            }
        }
        impl PD6<Output<OpenDrain>> {
            #[doc = " Enables / disables the internal pull up"]
            pub fn internal_pull_up(&mut self, pupdr: &mut PUPDR, on: bool) {
                pupdr.pupdr().modify(|_, w| {
                    if on {
                        w.pupdr6().pull_up()
                    } else {
                        w.pupdr6().floating()
                    }
                });
            }
        }
        impl<MODE> PD6<Output<MODE>> {
            #[doc = " Erases the pin number from the type"]
            #[doc = ""]
            #[doc = " This is useful when you want to collect the pins into an array where you"]
            #[doc = " need all the elements to have the same type"]
            pub fn downgrade(self) -> PDx<Output<MODE>> {
                PDx {
                    i: 6,
                    _mode: self._mode,
                }
            }
        }
        impl<MODE> PD6<Input<MODE>> {
            #[doc = " Erases the pin number from the type"]
            #[doc = ""]
            #[doc = " This is useful when you want to collect the pins into an array where you"]
            #[doc = " need all the elements to have the same type"]
            pub fn downgrade(self) -> PDx<Input<MODE>> {
                PDx {
                    i: 6,
                    _mode: self._mode,
                }
            }
        }
        impl<MODE> OutputPin for PD6<Output<MODE>> {
            type Error = Infallible;
            fn set_high(&mut self) -> Result<(), Self::Error> {
                unsafe { (*GPIOD::ptr()).bsrr.write(|w| w.bs6().set()) }
                Ok(())
            }
            fn set_low(&mut self) -> Result<(), Self::Error> {
                unsafe { (*GPIOD::ptr()).bsrr.write(|w| w.br6().reset()) }
                Ok(())
            }
        }
        #[cfg(feature = "unproven")]
        impl<MODE> InputPin for PD6<Input<MODE>> {
            type Error = Infallible;
            fn is_high(&self) -> Result<bool, Self::Error> {
                Ok(!self.is_low()?)
            }
            fn is_low(&self) -> Result<bool, Self::Error> {
                Ok(unsafe { (*GPIOD::ptr()).idr.read().idr6().is_low() })
            }
        }
        #[cfg(feature = "unproven")]
        impl InputPin for PD6<Output<OpenDrain>> {
            type Error = Infallible;
            fn is_high(&self) -> Result<bool, Self::Error> {
                Ok(!self.is_low()?)
            }
            fn is_low(&self) -> Result<bool, Self::Error> {
                Ok(unsafe { (*GPIOD::ptr()).idr.read().idr6().is_low() })
            }
        }
        #[cfg(feature = "unproven")]
        impl<MODE> StatefulOutputPin for PD6<Output<MODE>> {
            fn is_set_high(&self) -> Result<bool, Self::Error> {
                self.is_set_low().map(|b| !b)
            }
            fn is_set_low(&self) -> Result<bool, Self::Error> {
                Ok(unsafe { (*GPIOD::ptr()).odr.read().odr6().is_low() })
            }
        }
        #[cfg(feature = "unproven")]
        impl<MODE> toggleable::Default for PD6<Output<MODE>> {}
        #[doc = "Pin `PD7`"]
        pub struct PD7<MODE> {
            _mode: PhantomData<MODE>,
        }
        impl<MODE> PD7<MODE> {
            #[doc = "Configures `PD7` to serve as alternate function: `AF1`"]
            pub fn into_af1(self, moder: &mut MODER, afr: &mut AFRL) -> PD7<AF1> {
                moder.moder().modify(|_, w| w.moder7().alternate());
                afr.afr().modify(|_, w| w.afrl7().af1());
                PD7 { _mode: PhantomData }
            }
            #[doc = "Configures `PD7` to serve as alternate function: `AF2`"]
            pub fn into_af2(self, moder: &mut MODER, afr: &mut AFRL) -> PD7<AF2> {
                moder.moder().modify(|_, w| w.moder7().alternate());
                afr.afr().modify(|_, w| w.afrl7().af2());
                PD7 { _mode: PhantomData }
            }
            #[doc = "Configures `PD7` to serve as alternate function: `AF7`"]
            pub fn into_af7(self, moder: &mut MODER, afr: &mut AFRL) -> PD7<AF7> {
                moder.moder().modify(|_, w| w.moder7().alternate());
                afr.afr().modify(|_, w| w.afrl7().af7());
                PD7 { _mode: PhantomData }
            }
            #[doc = " Configures the pin to operate as a floating input pin"]
            pub fn into_floating_input(
                self,
                moder: &mut MODER,
                pupdr: &mut PUPDR,
            ) -> PD7<Input<Floating>> {
                moder.moder().modify(|_, w| w.moder7().input());
                pupdr.pupdr().modify(|_, w| w.pupdr7().floating());
                PD7 { _mode: PhantomData }
            }
            #[doc = " Configures the pin to operate as a pulled down input pin"]
            pub fn into_pull_down_input(
                self,
                moder: &mut MODER,
                pupdr: &mut PUPDR,
            ) -> PD7<Input<PullDown>> {
                moder.moder().modify(|_, w| w.moder7().input());
                pupdr.pupdr().modify(|_, w| w.pupdr7().pull_down());
                PD7 { _mode: PhantomData }
            }
            #[doc = " Configures the pin to operate as a pulled up input pin"]
            pub fn into_pull_up_input(
                self,
                moder: &mut MODER,
                pupdr: &mut PUPDR,
            ) -> PD7<Input<PullUp>> {
                moder.moder().modify(|_, w| w.moder7().input());
                pupdr.pupdr().modify(|_, w| w.pupdr7().pull_up());
                PD7 { _mode: PhantomData }
            }
            #[doc = " Configures the pin to operate as an open drain output pin"]
            pub fn into_open_drain_output(
                self,
                moder: &mut MODER,
                otyper: &mut OTYPER,
            ) -> PD7<Output<OpenDrain>> {
                moder.moder().modify(|_, w| w.moder7().output());
                otyper.otyper().modify(|_, w| w.ot7().open_drain());
                PD7 { _mode: PhantomData }
            }
            #[doc = " Configures the pin to operate as an push pull output pin"]
            pub fn into_push_pull_output(
                self,
                moder: &mut MODER,
                otyper: &mut OTYPER,
            ) -> PD7<Output<PushPull>> {
                moder.moder().modify(|_, w| w.moder7().output());
                otyper.otyper().modify(|_, w| w.ot7().push_pull());
                PD7 { _mode: PhantomData }
            }
            #[doc = " Configures the pin to operate as analog, with disabled schmitt trigger."]
            #[doc = " This mode is suitable when the pin is connected to the DAC or ADC."]
            pub fn into_analog(self, moder: &mut MODER, pupdr: &mut PUPDR) -> PD7<Analog> {
                moder.moder().modify(|_, w| w.moder7().analog());
                pupdr.pupdr().modify(|_, w| w.pupdr7().floating());
                PD7 { _mode: PhantomData }
            }
        }
        impl PD7<Output<OpenDrain>> {
            #[doc = " Enables / disables the internal pull up"]
            pub fn internal_pull_up(&mut self, pupdr: &mut PUPDR, on: bool) {
                pupdr.pupdr().modify(|_, w| {
                    if on {
                        w.pupdr7().pull_up()
                    } else {
                        w.pupdr7().floating()
                    }
                });
            }
        }
        impl<MODE> PD7<Output<MODE>> {
            #[doc = " Erases the pin number from the type"]
            #[doc = ""]
            #[doc = " This is useful when you want to collect the pins into an array where you"]
            #[doc = " need all the elements to have the same type"]
            pub fn downgrade(self) -> PDx<Output<MODE>> {
                PDx {
                    i: 7,
                    _mode: self._mode,
                }
            }
        }
        impl<MODE> PD7<Input<MODE>> {
            #[doc = " Erases the pin number from the type"]
            #[doc = ""]
            #[doc = " This is useful when you want to collect the pins into an array where you"]
            #[doc = " need all the elements to have the same type"]
            pub fn downgrade(self) -> PDx<Input<MODE>> {
                PDx {
                    i: 7,
                    _mode: self._mode,
                }
            }
        }
        impl<MODE> OutputPin for PD7<Output<MODE>> {
            type Error = Infallible;
            fn set_high(&mut self) -> Result<(), Self::Error> {
                unsafe { (*GPIOD::ptr()).bsrr.write(|w| w.bs7().set()) }
                Ok(())
            }
            fn set_low(&mut self) -> Result<(), Self::Error> {
                unsafe { (*GPIOD::ptr()).bsrr.write(|w| w.br7().reset()) }
                Ok(())
            }
        }
        #[cfg(feature = "unproven")]
        impl<MODE> InputPin for PD7<Input<MODE>> {
            type Error = Infallible;
            fn is_high(&self) -> Result<bool, Self::Error> {
                Ok(!self.is_low()?)
            }
            fn is_low(&self) -> Result<bool, Self::Error> {
                Ok(unsafe { (*GPIOD::ptr()).idr.read().idr7().is_low() })
            }
        }
        #[cfg(feature = "unproven")]
        impl InputPin for PD7<Output<OpenDrain>> {
            type Error = Infallible;
            fn is_high(&self) -> Result<bool, Self::Error> {
                Ok(!self.is_low()?)
            }
            fn is_low(&self) -> Result<bool, Self::Error> {
                Ok(unsafe { (*GPIOD::ptr()).idr.read().idr7().is_low() })
            }
        }
        #[cfg(feature = "unproven")]
        impl<MODE> StatefulOutputPin for PD7<Output<MODE>> {
            fn is_set_high(&self) -> Result<bool, Self::Error> {
                self.is_set_low().map(|b| !b)
            }
            fn is_set_low(&self) -> Result<bool, Self::Error> {
                Ok(unsafe { (*GPIOD::ptr()).odr.read().odr7().is_low() })
            }
        }
        #[cfg(feature = "unproven")]
        impl<MODE> toggleable::Default for PD7<Output<MODE>> {}
        #[doc = "Pin `PD8`"]
        pub struct PD8<MODE> {
            _mode: PhantomData<MODE>,
        }
        impl<MODE> PD8<MODE> {
            #[doc = "Configures `PD8` to serve as alternate function: `AF1`"]
            pub fn into_af1(self, moder: &mut MODER, afr: &mut AFRH) -> PD8<AF1> {
                moder.moder().modify(|_, w| w.moder8().alternate());
                afr.afr().modify(|_, w| w.afrh8().af1());
                PD8 { _mode: PhantomData }
            }
            #[doc = "Configures `PD8` to serve as alternate function: `AF7`"]
            pub fn into_af7(self, moder: &mut MODER, afr: &mut AFRH) -> PD8<AF7> {
                moder.moder().modify(|_, w| w.moder8().alternate());
                afr.afr().modify(|_, w| w.afrh8().af7());
                PD8 { _mode: PhantomData }
            }
            #[doc = " Configures the pin to operate as a floating input pin"]
            pub fn into_floating_input(
                self,
                moder: &mut MODER,
                pupdr: &mut PUPDR,
            ) -> PD8<Input<Floating>> {
                moder.moder().modify(|_, w| w.moder8().input());
                pupdr.pupdr().modify(|_, w| w.pupdr8().floating());
                PD8 { _mode: PhantomData }
            }
            #[doc = " Configures the pin to operate as a pulled down input pin"]
            pub fn into_pull_down_input(
                self,
                moder: &mut MODER,
                pupdr: &mut PUPDR,
            ) -> PD8<Input<PullDown>> {
                moder.moder().modify(|_, w| w.moder8().input());
                pupdr.pupdr().modify(|_, w| w.pupdr8().pull_down());
                PD8 { _mode: PhantomData }
            }
            #[doc = " Configures the pin to operate as a pulled up input pin"]
            pub fn into_pull_up_input(
                self,
                moder: &mut MODER,
                pupdr: &mut PUPDR,
            ) -> PD8<Input<PullUp>> {
                moder.moder().modify(|_, w| w.moder8().input());
                pupdr.pupdr().modify(|_, w| w.pupdr8().pull_up());
                PD8 { _mode: PhantomData }
            }
            #[doc = " Configures the pin to operate as an open drain output pin"]
            pub fn into_open_drain_output(
                self,
                moder: &mut MODER,
                otyper: &mut OTYPER,
            ) -> PD8<Output<OpenDrain>> {
                moder.moder().modify(|_, w| w.moder8().output());
                otyper.otyper().modify(|_, w| w.ot8().open_drain());
                PD8 { _mode: PhantomData }
            }
            #[doc = " Configures the pin to operate as an push pull output pin"]
            pub fn into_push_pull_output(
                self,
                moder: &mut MODER,
                otyper: &mut OTYPER,
            ) -> PD8<Output<PushPull>> {
                moder.moder().modify(|_, w| w.moder8().output());
                otyper.otyper().modify(|_, w| w.ot8().push_pull());
                PD8 { _mode: PhantomData }
            }
            #[doc = " Configures the pin to operate as analog, with disabled schmitt trigger."]
            #[doc = " This mode is suitable when the pin is connected to the DAC or ADC."]
            pub fn into_analog(self, moder: &mut MODER, pupdr: &mut PUPDR) -> PD8<Analog> {
                moder.moder().modify(|_, w| w.moder8().analog());
                pupdr.pupdr().modify(|_, w| w.pupdr8().floating());
                PD8 { _mode: PhantomData }
            }
        }
        impl PD8<Output<OpenDrain>> {
            #[doc = " Enables / disables the internal pull up"]
            pub fn internal_pull_up(&mut self, pupdr: &mut PUPDR, on: bool) {
                pupdr.pupdr().modify(|_, w| {
                    if on {
                        w.pupdr8().pull_up()
                    } else {
                        w.pupdr8().floating()
                    }
                });
            }
        }
        impl<MODE> PD8<Output<MODE>> {
            #[doc = " Erases the pin number from the type"]
            #[doc = ""]
            #[doc = " This is useful when you want to collect the pins into an array where you"]
            #[doc = " need all the elements to have the same type"]
            pub fn downgrade(self) -> PDx<Output<MODE>> {
                PDx {
                    i: 8,
                    _mode: self._mode,
                }
            }
        }
        impl<MODE> PD8<Input<MODE>> {
            #[doc = " Erases the pin number from the type"]
            #[doc = ""]
            #[doc = " This is useful when you want to collect the pins into an array where you"]
            #[doc = " need all the elements to have the same type"]
            pub fn downgrade(self) -> PDx<Input<MODE>> {
                PDx {
                    i: 8,
                    _mode: self._mode,
                }
            }
        }
        impl<MODE> OutputPin for PD8<Output<MODE>> {
            type Error = Infallible;
            fn set_high(&mut self) -> Result<(), Self::Error> {
                unsafe { (*GPIOD::ptr()).bsrr.write(|w| w.bs8().set()) }
                Ok(())
            }
            fn set_low(&mut self) -> Result<(), Self::Error> {
                unsafe { (*GPIOD::ptr()).bsrr.write(|w| w.br8().reset()) }
                Ok(())
            }
        }
        #[cfg(feature = "unproven")]
        impl<MODE> InputPin for PD8<Input<MODE>> {
            type Error = Infallible;
            fn is_high(&self) -> Result<bool, Self::Error> {
                Ok(!self.is_low()?)
            }
            fn is_low(&self) -> Result<bool, Self::Error> {
                Ok(unsafe { (*GPIOD::ptr()).idr.read().idr8().is_low() })
            }
        }
        #[cfg(feature = "unproven")]
        impl InputPin for PD8<Output<OpenDrain>> {
            type Error = Infallible;
            fn is_high(&self) -> Result<bool, Self::Error> {
                Ok(!self.is_low()?)
            }
            fn is_low(&self) -> Result<bool, Self::Error> {
                Ok(unsafe { (*GPIOD::ptr()).idr.read().idr8().is_low() })
            }
        }
        #[cfg(feature = "unproven")]
        impl<MODE> StatefulOutputPin for PD8<Output<MODE>> {
            fn is_set_high(&self) -> Result<bool, Self::Error> {
                self.is_set_low().map(|b| !b)
            }
            fn is_set_low(&self) -> Result<bool, Self::Error> {
                Ok(unsafe { (*GPIOD::ptr()).odr.read().odr8().is_low() })
            }
        }
        #[cfg(feature = "unproven")]
        impl<MODE> toggleable::Default for PD8<Output<MODE>> {}
        #[doc = "Pin `PD9`"]
        pub struct PD9<MODE> {
            _mode: PhantomData<MODE>,
        }
        impl<MODE> PD9<MODE> {
            #[doc = "Configures `PD9` to serve as alternate function: `AF1`"]
            pub fn into_af1(self, moder: &mut MODER, afr: &mut AFRH) -> PD9<AF1> {
                moder.moder().modify(|_, w| w.moder9().alternate());
                afr.afr().modify(|_, w| w.afrh9().af1());
                PD9 { _mode: PhantomData }
            }
            #[doc = "Configures `PD9` to serve as alternate function: `AF7`"]
            pub fn into_af7(self, moder: &mut MODER, afr: &mut AFRH) -> PD9<AF7> {
                moder.moder().modify(|_, w| w.moder9().alternate());
                afr.afr().modify(|_, w| w.afrh9().af7());
                PD9 { _mode: PhantomData }
            }
            #[doc = " Configures the pin to operate as a floating input pin"]
            pub fn into_floating_input(
                self,
                moder: &mut MODER,
                pupdr: &mut PUPDR,
            ) -> PD9<Input<Floating>> {
                moder.moder().modify(|_, w| w.moder9().input());
                pupdr.pupdr().modify(|_, w| w.pupdr9().floating());
                PD9 { _mode: PhantomData }
            }
            #[doc = " Configures the pin to operate as a pulled down input pin"]
            pub fn into_pull_down_input(
                self,
                moder: &mut MODER,
                pupdr: &mut PUPDR,
            ) -> PD9<Input<PullDown>> {
                moder.moder().modify(|_, w| w.moder9().input());
                pupdr.pupdr().modify(|_, w| w.pupdr9().pull_down());
                PD9 { _mode: PhantomData }
            }
            #[doc = " Configures the pin to operate as a pulled up input pin"]
            pub fn into_pull_up_input(
                self,
                moder: &mut MODER,
                pupdr: &mut PUPDR,
            ) -> PD9<Input<PullUp>> {
                moder.moder().modify(|_, w| w.moder9().input());
                pupdr.pupdr().modify(|_, w| w.pupdr9().pull_up());
                PD9 { _mode: PhantomData }
            }
            #[doc = " Configures the pin to operate as an open drain output pin"]
            pub fn into_open_drain_output(
                self,
                moder: &mut MODER,
                otyper: &mut OTYPER,
            ) -> PD9<Output<OpenDrain>> {
                moder.moder().modify(|_, w| w.moder9().output());
                otyper.otyper().modify(|_, w| w.ot9().open_drain());
                PD9 { _mode: PhantomData }
            }
            #[doc = " Configures the pin to operate as an push pull output pin"]
            pub fn into_push_pull_output(
                self,
                moder: &mut MODER,
                otyper: &mut OTYPER,
            ) -> PD9<Output<PushPull>> {
                moder.moder().modify(|_, w| w.moder9().output());
                otyper.otyper().modify(|_, w| w.ot9().push_pull());
                PD9 { _mode: PhantomData }
            }
            #[doc = " Configures the pin to operate as analog, with disabled schmitt trigger."]
            #[doc = " This mode is suitable when the pin is connected to the DAC or ADC."]
            pub fn into_analog(self, moder: &mut MODER, pupdr: &mut PUPDR) -> PD9<Analog> {
                moder.moder().modify(|_, w| w.moder9().analog());
                pupdr.pupdr().modify(|_, w| w.pupdr9().floating());
                PD9 { _mode: PhantomData }
            }
        }
        impl PD9<Output<OpenDrain>> {
            #[doc = " Enables / disables the internal pull up"]
            pub fn internal_pull_up(&mut self, pupdr: &mut PUPDR, on: bool) {
                pupdr.pupdr().modify(|_, w| {
                    if on {
                        w.pupdr9().pull_up()
                    } else {
                        w.pupdr9().floating()
                    }
                });
            }
        }
        impl<MODE> PD9<Output<MODE>> {
            #[doc = " Erases the pin number from the type"]
            #[doc = ""]
            #[doc = " This is useful when you want to collect the pins into an array where you"]
            #[doc = " need all the elements to have the same type"]
            pub fn downgrade(self) -> PDx<Output<MODE>> {
                PDx {
                    i: 9,
                    _mode: self._mode,
                }
            }
        }
        impl<MODE> PD9<Input<MODE>> {
            #[doc = " Erases the pin number from the type"]
            #[doc = ""]
            #[doc = " This is useful when you want to collect the pins into an array where you"]
            #[doc = " need all the elements to have the same type"]
            pub fn downgrade(self) -> PDx<Input<MODE>> {
                PDx {
                    i: 9,
                    _mode: self._mode,
                }
            }
        }
        impl<MODE> OutputPin for PD9<Output<MODE>> {
            type Error = Infallible;
            fn set_high(&mut self) -> Result<(), Self::Error> {
                unsafe { (*GPIOD::ptr()).bsrr.write(|w| w.bs9().set()) }
                Ok(())
            }
            fn set_low(&mut self) -> Result<(), Self::Error> {
                unsafe { (*GPIOD::ptr()).bsrr.write(|w| w.br9().reset()) }
                Ok(())
            }
        }
        #[cfg(feature = "unproven")]
        impl<MODE> InputPin for PD9<Input<MODE>> {
            type Error = Infallible;
            fn is_high(&self) -> Result<bool, Self::Error> {
                Ok(!self.is_low()?)
            }
            fn is_low(&self) -> Result<bool, Self::Error> {
                Ok(unsafe { (*GPIOD::ptr()).idr.read().idr9().is_low() })
            }
        }
        #[cfg(feature = "unproven")]
        impl InputPin for PD9<Output<OpenDrain>> {
            type Error = Infallible;
            fn is_high(&self) -> Result<bool, Self::Error> {
                Ok(!self.is_low()?)
            }
            fn is_low(&self) -> Result<bool, Self::Error> {
                Ok(unsafe { (*GPIOD::ptr()).idr.read().idr9().is_low() })
            }
        }
        #[cfg(feature = "unproven")]
        impl<MODE> StatefulOutputPin for PD9<Output<MODE>> {
            fn is_set_high(&self) -> Result<bool, Self::Error> {
                self.is_set_low().map(|b| !b)
            }
            fn is_set_low(&self) -> Result<bool, Self::Error> {
                Ok(unsafe { (*GPIOD::ptr()).odr.read().odr9().is_low() })
            }
        }
        #[cfg(feature = "unproven")]
        impl<MODE> toggleable::Default for PD9<Output<MODE>> {}
        #[doc = "Pin `PD10`"]
        pub struct PD10<MODE> {
            _mode: PhantomData<MODE>,
        }
        impl<MODE> PD10<MODE> {
            #[doc = "Configures `PD10` to serve as alternate function: `AF1`"]
            pub fn into_af1(self, moder: &mut MODER, afr: &mut AFRH) -> PD10<AF1> {
                moder.moder().modify(|_, w| w.moder10().alternate());
                afr.afr().modify(|_, w| w.afrh10().af1());
                PD10 { _mode: PhantomData }
            }
            #[doc = "Configures `PD10` to serve as alternate function: `AF7`"]
            pub fn into_af7(self, moder: &mut MODER, afr: &mut AFRH) -> PD10<AF7> {
                moder.moder().modify(|_, w| w.moder10().alternate());
                afr.afr().modify(|_, w| w.afrh10().af7());
                PD10 { _mode: PhantomData }
            }
            #[doc = " Configures the pin to operate as a floating input pin"]
            pub fn into_floating_input(
                self,
                moder: &mut MODER,
                pupdr: &mut PUPDR,
            ) -> PD10<Input<Floating>> {
                moder.moder().modify(|_, w| w.moder10().input());
                pupdr.pupdr().modify(|_, w| w.pupdr10().floating());
                PD10 { _mode: PhantomData }
            }
            #[doc = " Configures the pin to operate as a pulled down input pin"]
            pub fn into_pull_down_input(
                self,
                moder: &mut MODER,
                pupdr: &mut PUPDR,
            ) -> PD10<Input<PullDown>> {
                moder.moder().modify(|_, w| w.moder10().input());
                pupdr.pupdr().modify(|_, w| w.pupdr10().pull_down());
                PD10 { _mode: PhantomData }
            }
            #[doc = " Configures the pin to operate as a pulled up input pin"]
            pub fn into_pull_up_input(
                self,
                moder: &mut MODER,
                pupdr: &mut PUPDR,
            ) -> PD10<Input<PullUp>> {
                moder.moder().modify(|_, w| w.moder10().input());
                pupdr.pupdr().modify(|_, w| w.pupdr10().pull_up());
                PD10 { _mode: PhantomData }
            }
            #[doc = " Configures the pin to operate as an open drain output pin"]
            pub fn into_open_drain_output(
                self,
                moder: &mut MODER,
                otyper: &mut OTYPER,
            ) -> PD10<Output<OpenDrain>> {
                moder.moder().modify(|_, w| w.moder10().output());
                otyper.otyper().modify(|_, w| w.ot10().open_drain());
                PD10 { _mode: PhantomData }
            }
            #[doc = " Configures the pin to operate as an push pull output pin"]
            pub fn into_push_pull_output(
                self,
                moder: &mut MODER,
                otyper: &mut OTYPER,
            ) -> PD10<Output<PushPull>> {
                moder.moder().modify(|_, w| w.moder10().output());
                otyper.otyper().modify(|_, w| w.ot10().push_pull());
                PD10 { _mode: PhantomData }
            }
            #[doc = " Configures the pin to operate as analog, with disabled schmitt trigger."]
            #[doc = " This mode is suitable when the pin is connected to the DAC or ADC."]
            pub fn into_analog(self, moder: &mut MODER, pupdr: &mut PUPDR) -> PD10<Analog> {
                moder.moder().modify(|_, w| w.moder10().analog());
                pupdr.pupdr().modify(|_, w| w.pupdr10().floating());
                PD10 { _mode: PhantomData }
            }
        }
        impl PD10<Output<OpenDrain>> {
            #[doc = " Enables / disables the internal pull up"]
            pub fn internal_pull_up(&mut self, pupdr: &mut PUPDR, on: bool) {
                pupdr.pupdr().modify(|_, w| {
                    if on {
                        w.pupdr10().pull_up()
                    } else {
                        w.pupdr10().floating()
                    }
                });
            }
        }
        impl<MODE> PD10<Output<MODE>> {
            #[doc = " Erases the pin number from the type"]
            #[doc = ""]
            #[doc = " This is useful when you want to collect the pins into an array where you"]
            #[doc = " need all the elements to have the same type"]
            pub fn downgrade(self) -> PDx<Output<MODE>> {
                PDx {
                    i: 10,
                    _mode: self._mode,
                }
            }
        }
        impl<MODE> PD10<Input<MODE>> {
            #[doc = " Erases the pin number from the type"]
            #[doc = ""]
            #[doc = " This is useful when you want to collect the pins into an array where you"]
            #[doc = " need all the elements to have the same type"]
            pub fn downgrade(self) -> PDx<Input<MODE>> {
                PDx {
                    i: 10,
                    _mode: self._mode,
                }
            }
        }
        impl<MODE> OutputPin for PD10<Output<MODE>> {
            type Error = Infallible;
            fn set_high(&mut self) -> Result<(), Self::Error> {
                unsafe { (*GPIOD::ptr()).bsrr.write(|w| w.bs10().set()) }
                Ok(())
            }
            fn set_low(&mut self) -> Result<(), Self::Error> {
                unsafe { (*GPIOD::ptr()).bsrr.write(|w| w.br10().reset()) }
                Ok(())
            }
        }
        #[cfg(feature = "unproven")]
        impl<MODE> InputPin for PD10<Input<MODE>> {
            type Error = Infallible;
            fn is_high(&self) -> Result<bool, Self::Error> {
                Ok(!self.is_low()?)
            }
            fn is_low(&self) -> Result<bool, Self::Error> {
                Ok(unsafe { (*GPIOD::ptr()).idr.read().idr10().is_low() })
            }
        }
        #[cfg(feature = "unproven")]
        impl InputPin for PD10<Output<OpenDrain>> {
            type Error = Infallible;
            fn is_high(&self) -> Result<bool, Self::Error> {
                Ok(!self.is_low()?)
            }
            fn is_low(&self) -> Result<bool, Self::Error> {
                Ok(unsafe { (*GPIOD::ptr()).idr.read().idr10().is_low() })
            }
        }
        #[cfg(feature = "unproven")]
        impl<MODE> StatefulOutputPin for PD10<Output<MODE>> {
            fn is_set_high(&self) -> Result<bool, Self::Error> {
                self.is_set_low().map(|b| !b)
            }
            fn is_set_low(&self) -> Result<bool, Self::Error> {
                Ok(unsafe { (*GPIOD::ptr()).odr.read().odr10().is_low() })
            }
        }
        #[cfg(feature = "unproven")]
        impl<MODE> toggleable::Default for PD10<Output<MODE>> {}
        #[doc = "Pin `PD11`"]
        pub struct PD11<MODE> {
            _mode: PhantomData<MODE>,
        }
        impl<MODE> PD11<MODE> {
            #[doc = "Configures `PD11` to serve as alternate function: `AF1`"]
            pub fn into_af1(self, moder: &mut MODER, afr: &mut AFRH) -> PD11<AF1> {
                moder.moder().modify(|_, w| w.moder11().alternate());
                afr.afr().modify(|_, w| w.afrh11().af1());
                PD11 { _mode: PhantomData }
            }
            #[doc = "Configures `PD11` to serve as alternate function: `AF7`"]
            pub fn into_af7(self, moder: &mut MODER, afr: &mut AFRH) -> PD11<AF7> {
                moder.moder().modify(|_, w| w.moder11().alternate());
                afr.afr().modify(|_, w| w.afrh11().af7());
                PD11 { _mode: PhantomData }
            }
            #[doc = " Configures the pin to operate as a floating input pin"]
            pub fn into_floating_input(
                self,
                moder: &mut MODER,
                pupdr: &mut PUPDR,
            ) -> PD11<Input<Floating>> {
                moder.moder().modify(|_, w| w.moder11().input());
                pupdr.pupdr().modify(|_, w| w.pupdr11().floating());
                PD11 { _mode: PhantomData }
            }
            #[doc = " Configures the pin to operate as a pulled down input pin"]
            pub fn into_pull_down_input(
                self,
                moder: &mut MODER,
                pupdr: &mut PUPDR,
            ) -> PD11<Input<PullDown>> {
                moder.moder().modify(|_, w| w.moder11().input());
                pupdr.pupdr().modify(|_, w| w.pupdr11().pull_down());
                PD11 { _mode: PhantomData }
            }
            #[doc = " Configures the pin to operate as a pulled up input pin"]
            pub fn into_pull_up_input(
                self,
                moder: &mut MODER,
                pupdr: &mut PUPDR,
            ) -> PD11<Input<PullUp>> {
                moder.moder().modify(|_, w| w.moder11().input());
                pupdr.pupdr().modify(|_, w| w.pupdr11().pull_up());
                PD11 { _mode: PhantomData }
            }
            #[doc = " Configures the pin to operate as an open drain output pin"]
            pub fn into_open_drain_output(
                self,
                moder: &mut MODER,
                otyper: &mut OTYPER,
            ) -> PD11<Output<OpenDrain>> {
                moder.moder().modify(|_, w| w.moder11().output());
                otyper.otyper().modify(|_, w| w.ot11().open_drain());
                PD11 { _mode: PhantomData }
            }
            #[doc = " Configures the pin to operate as an push pull output pin"]
            pub fn into_push_pull_output(
                self,
                moder: &mut MODER,
                otyper: &mut OTYPER,
            ) -> PD11<Output<PushPull>> {
                moder.moder().modify(|_, w| w.moder11().output());
                otyper.otyper().modify(|_, w| w.ot11().push_pull());
                PD11 { _mode: PhantomData }
            }
            #[doc = " Configures the pin to operate as analog, with disabled schmitt trigger."]
            #[doc = " This mode is suitable when the pin is connected to the DAC or ADC."]
            pub fn into_analog(self, moder: &mut MODER, pupdr: &mut PUPDR) -> PD11<Analog> {
                moder.moder().modify(|_, w| w.moder11().analog());
                pupdr.pupdr().modify(|_, w| w.pupdr11().floating());
                PD11 { _mode: PhantomData }
            }
        }
        impl PD11<Output<OpenDrain>> {
            #[doc = " Enables / disables the internal pull up"]
            pub fn internal_pull_up(&mut self, pupdr: &mut PUPDR, on: bool) {
                pupdr.pupdr().modify(|_, w| {
                    if on {
                        w.pupdr11().pull_up()
                    } else {
                        w.pupdr11().floating()
                    }
                });
            }
        }
        impl<MODE> PD11<Output<MODE>> {
            #[doc = " Erases the pin number from the type"]
            #[doc = ""]
            #[doc = " This is useful when you want to collect the pins into an array where you"]
            #[doc = " need all the elements to have the same type"]
            pub fn downgrade(self) -> PDx<Output<MODE>> {
                PDx {
                    i: 11,
                    _mode: self._mode,
                }
            }
        }
        impl<MODE> PD11<Input<MODE>> {
            #[doc = " Erases the pin number from the type"]
            #[doc = ""]
            #[doc = " This is useful when you want to collect the pins into an array where you"]
            #[doc = " need all the elements to have the same type"]
            pub fn downgrade(self) -> PDx<Input<MODE>> {
                PDx {
                    i: 11,
                    _mode: self._mode,
                }
            }
        }
        impl<MODE> OutputPin for PD11<Output<MODE>> {
            type Error = Infallible;
            fn set_high(&mut self) -> Result<(), Self::Error> {
                unsafe { (*GPIOD::ptr()).bsrr.write(|w| w.bs11().set()) }
                Ok(())
            }
            fn set_low(&mut self) -> Result<(), Self::Error> {
                unsafe { (*GPIOD::ptr()).bsrr.write(|w| w.br11().reset()) }
                Ok(())
            }
        }
        #[cfg(feature = "unproven")]
        impl<MODE> InputPin for PD11<Input<MODE>> {
            type Error = Infallible;
            fn is_high(&self) -> Result<bool, Self::Error> {
                Ok(!self.is_low()?)
            }
            fn is_low(&self) -> Result<bool, Self::Error> {
                Ok(unsafe { (*GPIOD::ptr()).idr.read().idr11().is_low() })
            }
        }
        #[cfg(feature = "unproven")]
        impl InputPin for PD11<Output<OpenDrain>> {
            type Error = Infallible;
            fn is_high(&self) -> Result<bool, Self::Error> {
                Ok(!self.is_low()?)
            }
            fn is_low(&self) -> Result<bool, Self::Error> {
                Ok(unsafe { (*GPIOD::ptr()).idr.read().idr11().is_low() })
            }
        }
        #[cfg(feature = "unproven")]
        impl<MODE> StatefulOutputPin for PD11<Output<MODE>> {
            fn is_set_high(&self) -> Result<bool, Self::Error> {
                self.is_set_low().map(|b| !b)
            }
            fn is_set_low(&self) -> Result<bool, Self::Error> {
                Ok(unsafe { (*GPIOD::ptr()).odr.read().odr11().is_low() })
            }
        }
        #[cfg(feature = "unproven")]
        impl<MODE> toggleable::Default for PD11<Output<MODE>> {}
        #[doc = "Pin `PD12`"]
        pub struct PD12<MODE> {
            _mode: PhantomData<MODE>,
        }
        impl<MODE> PD12<MODE> {
            #[doc = "Configures `PD12` to serve as alternate function: `AF1`"]
            pub fn into_af1(self, moder: &mut MODER, afr: &mut AFRH) -> PD12<AF1> {
                moder.moder().modify(|_, w| w.moder12().alternate());
                afr.afr().modify(|_, w| w.afrh12().af1());
                PD12 { _mode: PhantomData }
            }
            #[doc = "Configures `PD12` to serve as alternate function: `AF2`"]
            pub fn into_af2(self, moder: &mut MODER, afr: &mut AFRH) -> PD12<AF2> {
                moder.moder().modify(|_, w| w.moder12().alternate());
                afr.afr().modify(|_, w| w.afrh12().af2());
                PD12 { _mode: PhantomData }
            }
            #[doc = "Configures `PD12` to serve as alternate function: `AF3`"]
            pub fn into_af3(self, moder: &mut MODER, afr: &mut AFRH) -> PD12<AF3> {
                moder.moder().modify(|_, w| w.moder12().alternate());
                afr.afr().modify(|_, w| w.afrh12().af3());
                PD12 { _mode: PhantomData }
            }
            #[doc = "Configures `PD12` to serve as alternate function: `AF7`"]
            pub fn into_af7(self, moder: &mut MODER, afr: &mut AFRH) -> PD12<AF7> {
                moder.moder().modify(|_, w| w.moder12().alternate());
                afr.afr().modify(|_, w| w.afrh12().af7());
                PD12 { _mode: PhantomData }
            }
            #[doc = " Configures the pin to operate as a floating input pin"]
            pub fn into_floating_input(
                self,
                moder: &mut MODER,
                pupdr: &mut PUPDR,
            ) -> PD12<Input<Floating>> {
                moder.moder().modify(|_, w| w.moder12().input());
                pupdr.pupdr().modify(|_, w| w.pupdr12().floating());
                PD12 { _mode: PhantomData }
            }
            #[doc = " Configures the pin to operate as a pulled down input pin"]
            pub fn into_pull_down_input(
                self,
                moder: &mut MODER,
                pupdr: &mut PUPDR,
            ) -> PD12<Input<PullDown>> {
                moder.moder().modify(|_, w| w.moder12().input());
                pupdr.pupdr().modify(|_, w| w.pupdr12().pull_down());
                PD12 { _mode: PhantomData }
            }
            #[doc = " Configures the pin to operate as a pulled up input pin"]
            pub fn into_pull_up_input(
                self,
                moder: &mut MODER,
                pupdr: &mut PUPDR,
            ) -> PD12<Input<PullUp>> {
                moder.moder().modify(|_, w| w.moder12().input());
                pupdr.pupdr().modify(|_, w| w.pupdr12().pull_up());
                PD12 { _mode: PhantomData }
            }
            #[doc = " Configures the pin to operate as an open drain output pin"]
            pub fn into_open_drain_output(
                self,
                moder: &mut MODER,
                otyper: &mut OTYPER,
            ) -> PD12<Output<OpenDrain>> {
                moder.moder().modify(|_, w| w.moder12().output());
                otyper.otyper().modify(|_, w| w.ot12().open_drain());
                PD12 { _mode: PhantomData }
            }
            #[doc = " Configures the pin to operate as an push pull output pin"]
            pub fn into_push_pull_output(
                self,
                moder: &mut MODER,
                otyper: &mut OTYPER,
            ) -> PD12<Output<PushPull>> {
                moder.moder().modify(|_, w| w.moder12().output());
                otyper.otyper().modify(|_, w| w.ot12().push_pull());
                PD12 { _mode: PhantomData }
            }
            #[doc = " Configures the pin to operate as analog, with disabled schmitt trigger."]
            #[doc = " This mode is suitable when the pin is connected to the DAC or ADC."]
            pub fn into_analog(self, moder: &mut MODER, pupdr: &mut PUPDR) -> PD12<Analog> {
                moder.moder().modify(|_, w| w.moder12().analog());
                pupdr.pupdr().modify(|_, w| w.pupdr12().floating());
                PD12 { _mode: PhantomData }
            }
        }
        impl PD12<Output<OpenDrain>> {
            #[doc = " Enables / disables the internal pull up"]
            pub fn internal_pull_up(&mut self, pupdr: &mut PUPDR, on: bool) {
                pupdr.pupdr().modify(|_, w| {
                    if on {
                        w.pupdr12().pull_up()
                    } else {
                        w.pupdr12().floating()
                    }
                });
            }
        }
        impl<MODE> PD12<Output<MODE>> {
            #[doc = " Erases the pin number from the type"]
            #[doc = ""]
            #[doc = " This is useful when you want to collect the pins into an array where you"]
            #[doc = " need all the elements to have the same type"]
            pub fn downgrade(self) -> PDx<Output<MODE>> {
                PDx {
                    i: 12,
                    _mode: self._mode,
                }
            }
        }
        impl<MODE> PD12<Input<MODE>> {
            #[doc = " Erases the pin number from the type"]
            #[doc = ""]
            #[doc = " This is useful when you want to collect the pins into an array where you"]
            #[doc = " need all the elements to have the same type"]
            pub fn downgrade(self) -> PDx<Input<MODE>> {
                PDx {
                    i: 12,
                    _mode: self._mode,
                }
            }
        }
        impl<MODE> OutputPin for PD12<Output<MODE>> {
            type Error = Infallible;
            fn set_high(&mut self) -> Result<(), Self::Error> {
                unsafe { (*GPIOD::ptr()).bsrr.write(|w| w.bs12().set()) }
                Ok(())
            }
            fn set_low(&mut self) -> Result<(), Self::Error> {
                unsafe { (*GPIOD::ptr()).bsrr.write(|w| w.br12().reset()) }
                Ok(())
            }
        }
        #[cfg(feature = "unproven")]
        impl<MODE> InputPin for PD12<Input<MODE>> {
            type Error = Infallible;
            fn is_high(&self) -> Result<bool, Self::Error> {
                Ok(!self.is_low()?)
            }
            fn is_low(&self) -> Result<bool, Self::Error> {
                Ok(unsafe { (*GPIOD::ptr()).idr.read().idr12().is_low() })
            }
        }
        #[cfg(feature = "unproven")]
        impl InputPin for PD12<Output<OpenDrain>> {
            type Error = Infallible;
            fn is_high(&self) -> Result<bool, Self::Error> {
                Ok(!self.is_low()?)
            }
            fn is_low(&self) -> Result<bool, Self::Error> {
                Ok(unsafe { (*GPIOD::ptr()).idr.read().idr12().is_low() })
            }
        }
        #[cfg(feature = "unproven")]
        impl<MODE> StatefulOutputPin for PD12<Output<MODE>> {
            fn is_set_high(&self) -> Result<bool, Self::Error> {
                self.is_set_low().map(|b| !b)
            }
            fn is_set_low(&self) -> Result<bool, Self::Error> {
                Ok(unsafe { (*GPIOD::ptr()).odr.read().odr12().is_low() })
            }
        }
        #[cfg(feature = "unproven")]
        impl<MODE> toggleable::Default for PD12<Output<MODE>> {}
        #[doc = "Pin `PD13`"]
        pub struct PD13<MODE> {
            _mode: PhantomData<MODE>,
        }
        impl<MODE> PD13<MODE> {
            #[doc = "Configures `PD13` to serve as alternate function: `AF1`"]
            pub fn into_af1(self, moder: &mut MODER, afr: &mut AFRH) -> PD13<AF1> {
                moder.moder().modify(|_, w| w.moder13().alternate());
                afr.afr().modify(|_, w| w.afrh13().af1());
                PD13 { _mode: PhantomData }
            }
            #[doc = "Configures `PD13` to serve as alternate function: `AF2`"]
            pub fn into_af2(self, moder: &mut MODER, afr: &mut AFRH) -> PD13<AF2> {
                moder.moder().modify(|_, w| w.moder13().alternate());
                afr.afr().modify(|_, w| w.afrh13().af2());
                PD13 { _mode: PhantomData }
            }
            #[doc = "Configures `PD13` to serve as alternate function: `AF3`"]
            pub fn into_af3(self, moder: &mut MODER, afr: &mut AFRH) -> PD13<AF3> {
                moder.moder().modify(|_, w| w.moder13().alternate());
                afr.afr().modify(|_, w| w.afrh13().af3());
                PD13 { _mode: PhantomData }
            }
            #[doc = " Configures the pin to operate as a floating input pin"]
            pub fn into_floating_input(
                self,
                moder: &mut MODER,
                pupdr: &mut PUPDR,
            ) -> PD13<Input<Floating>> {
                moder.moder().modify(|_, w| w.moder13().input());
                pupdr.pupdr().modify(|_, w| w.pupdr13().floating());
                PD13 { _mode: PhantomData }
            }
            #[doc = " Configures the pin to operate as a pulled down input pin"]
            pub fn into_pull_down_input(
                self,
                moder: &mut MODER,
                pupdr: &mut PUPDR,
            ) -> PD13<Input<PullDown>> {
                moder.moder().modify(|_, w| w.moder13().input());
                pupdr.pupdr().modify(|_, w| w.pupdr13().pull_down());
                PD13 { _mode: PhantomData }
            }
            #[doc = " Configures the pin to operate as a pulled up input pin"]
            pub fn into_pull_up_input(
                self,
                moder: &mut MODER,
                pupdr: &mut PUPDR,
            ) -> PD13<Input<PullUp>> {
                moder.moder().modify(|_, w| w.moder13().input());
                pupdr.pupdr().modify(|_, w| w.pupdr13().pull_up());
                PD13 { _mode: PhantomData }
            }
            #[doc = " Configures the pin to operate as an open drain output pin"]
            pub fn into_open_drain_output(
                self,
                moder: &mut MODER,
                otyper: &mut OTYPER,
            ) -> PD13<Output<OpenDrain>> {
                moder.moder().modify(|_, w| w.moder13().output());
                otyper.otyper().modify(|_, w| w.ot13().open_drain());
                PD13 { _mode: PhantomData }
            }
            #[doc = " Configures the pin to operate as an push pull output pin"]
            pub fn into_push_pull_output(
                self,
                moder: &mut MODER,
                otyper: &mut OTYPER,
            ) -> PD13<Output<PushPull>> {
                moder.moder().modify(|_, w| w.moder13().output());
                otyper.otyper().modify(|_, w| w.ot13().push_pull());
                PD13 { _mode: PhantomData }
            }
            #[doc = " Configures the pin to operate as analog, with disabled schmitt trigger."]
            #[doc = " This mode is suitable when the pin is connected to the DAC or ADC."]
            pub fn into_analog(self, moder: &mut MODER, pupdr: &mut PUPDR) -> PD13<Analog> {
                moder.moder().modify(|_, w| w.moder13().analog());
                pupdr.pupdr().modify(|_, w| w.pupdr13().floating());
                PD13 { _mode: PhantomData }
            }
        }
        impl PD13<Output<OpenDrain>> {
            #[doc = " Enables / disables the internal pull up"]
            pub fn internal_pull_up(&mut self, pupdr: &mut PUPDR, on: bool) {
                pupdr.pupdr().modify(|_, w| {
                    if on {
                        w.pupdr13().pull_up()
                    } else {
                        w.pupdr13().floating()
                    }
                });
            }
        }
        impl<MODE> PD13<Output<MODE>> {
            #[doc = " Erases the pin number from the type"]
            #[doc = ""]
            #[doc = " This is useful when you want to collect the pins into an array where you"]
            #[doc = " need all the elements to have the same type"]
            pub fn downgrade(self) -> PDx<Output<MODE>> {
                PDx {
                    i: 13,
                    _mode: self._mode,
                }
            }
        }
        impl<MODE> PD13<Input<MODE>> {
            #[doc = " Erases the pin number from the type"]
            #[doc = ""]
            #[doc = " This is useful when you want to collect the pins into an array where you"]
            #[doc = " need all the elements to have the same type"]
            pub fn downgrade(self) -> PDx<Input<MODE>> {
                PDx {
                    i: 13,
                    _mode: self._mode,
                }
            }
        }
        impl<MODE> OutputPin for PD13<Output<MODE>> {
            type Error = Infallible;
            fn set_high(&mut self) -> Result<(), Self::Error> {
                unsafe { (*GPIOD::ptr()).bsrr.write(|w| w.bs13().set()) }
                Ok(())
            }
            fn set_low(&mut self) -> Result<(), Self::Error> {
                unsafe { (*GPIOD::ptr()).bsrr.write(|w| w.br13().reset()) }
                Ok(())
            }
        }
        #[cfg(feature = "unproven")]
        impl<MODE> InputPin for PD13<Input<MODE>> {
            type Error = Infallible;
            fn is_high(&self) -> Result<bool, Self::Error> {
                Ok(!self.is_low()?)
            }
            fn is_low(&self) -> Result<bool, Self::Error> {
                Ok(unsafe { (*GPIOD::ptr()).idr.read().idr13().is_low() })
            }
        }
        #[cfg(feature = "unproven")]
        impl InputPin for PD13<Output<OpenDrain>> {
            type Error = Infallible;
            fn is_high(&self) -> Result<bool, Self::Error> {
                Ok(!self.is_low()?)
            }
            fn is_low(&self) -> Result<bool, Self::Error> {
                Ok(unsafe { (*GPIOD::ptr()).idr.read().idr13().is_low() })
            }
        }
        #[cfg(feature = "unproven")]
        impl<MODE> StatefulOutputPin for PD13<Output<MODE>> {
            fn is_set_high(&self) -> Result<bool, Self::Error> {
                self.is_set_low().map(|b| !b)
            }
            fn is_set_low(&self) -> Result<bool, Self::Error> {
                Ok(unsafe { (*GPIOD::ptr()).odr.read().odr13().is_low() })
            }
        }
        #[cfg(feature = "unproven")]
        impl<MODE> toggleable::Default for PD13<Output<MODE>> {}
        #[doc = "Pin `PD14`"]
        pub struct PD14<MODE> {
            _mode: PhantomData<MODE>,
        }
        impl<MODE> PD14<MODE> {
            #[doc = "Configures `PD14` to serve as alternate function: `AF1`"]
            pub fn into_af1(self, moder: &mut MODER, afr: &mut AFRH) -> PD14<AF1> {
                moder.moder().modify(|_, w| w.moder14().alternate());
                afr.afr().modify(|_, w| w.afrh14().af1());
                PD14 { _mode: PhantomData }
            }
            #[doc = "Configures `PD14` to serve as alternate function: `AF2`"]
            pub fn into_af2(self, moder: &mut MODER, afr: &mut AFRH) -> PD14<AF2> {
                moder.moder().modify(|_, w| w.moder14().alternate());
                afr.afr().modify(|_, w| w.afrh14().af2());
                PD14 { _mode: PhantomData }
            }
            #[doc = "Configures `PD14` to serve as alternate function: `AF3`"]
            pub fn into_af3(self, moder: &mut MODER, afr: &mut AFRH) -> PD14<AF3> {
                moder.moder().modify(|_, w| w.moder14().alternate());
                afr.afr().modify(|_, w| w.afrh14().af3());
                PD14 { _mode: PhantomData }
            }
            #[doc = " Configures the pin to operate as a floating input pin"]
            pub fn into_floating_input(
                self,
                moder: &mut MODER,
                pupdr: &mut PUPDR,
            ) -> PD14<Input<Floating>> {
                moder.moder().modify(|_, w| w.moder14().input());
                pupdr.pupdr().modify(|_, w| w.pupdr14().floating());
                PD14 { _mode: PhantomData }
            }
            #[doc = " Configures the pin to operate as a pulled down input pin"]
            pub fn into_pull_down_input(
                self,
                moder: &mut MODER,
                pupdr: &mut PUPDR,
            ) -> PD14<Input<PullDown>> {
                moder.moder().modify(|_, w| w.moder14().input());
                pupdr.pupdr().modify(|_, w| w.pupdr14().pull_down());
                PD14 { _mode: PhantomData }
            }
            #[doc = " Configures the pin to operate as a pulled up input pin"]
            pub fn into_pull_up_input(
                self,
                moder: &mut MODER,
                pupdr: &mut PUPDR,
            ) -> PD14<Input<PullUp>> {
                moder.moder().modify(|_, w| w.moder14().input());
                pupdr.pupdr().modify(|_, w| w.pupdr14().pull_up());
                PD14 { _mode: PhantomData }
            }
            #[doc = " Configures the pin to operate as an open drain output pin"]
            pub fn into_open_drain_output(
                self,
                moder: &mut MODER,
                otyper: &mut OTYPER,
            ) -> PD14<Output<OpenDrain>> {
                moder.moder().modify(|_, w| w.moder14().output());
                otyper.otyper().modify(|_, w| w.ot14().open_drain());
                PD14 { _mode: PhantomData }
            }
            #[doc = " Configures the pin to operate as an push pull output pin"]
            pub fn into_push_pull_output(
                self,
                moder: &mut MODER,
                otyper: &mut OTYPER,
            ) -> PD14<Output<PushPull>> {
                moder.moder().modify(|_, w| w.moder14().output());
                otyper.otyper().modify(|_, w| w.ot14().push_pull());
                PD14 { _mode: PhantomData }
            }
            #[doc = " Configures the pin to operate as analog, with disabled schmitt trigger."]
            #[doc = " This mode is suitable when the pin is connected to the DAC or ADC."]
            pub fn into_analog(self, moder: &mut MODER, pupdr: &mut PUPDR) -> PD14<Analog> {
                moder.moder().modify(|_, w| w.moder14().analog());
                pupdr.pupdr().modify(|_, w| w.pupdr14().floating());
                PD14 { _mode: PhantomData }
            }
        }
        impl PD14<Output<OpenDrain>> {
            #[doc = " Enables / disables the internal pull up"]
            pub fn internal_pull_up(&mut self, pupdr: &mut PUPDR, on: bool) {
                pupdr.pupdr().modify(|_, w| {
                    if on {
                        w.pupdr14().pull_up()
                    } else {
                        w.pupdr14().floating()
                    }
                });
            }
        }
        impl<MODE> PD14<Output<MODE>> {
            #[doc = " Erases the pin number from the type"]
            #[doc = ""]
            #[doc = " This is useful when you want to collect the pins into an array where you"]
            #[doc = " need all the elements to have the same type"]
            pub fn downgrade(self) -> PDx<Output<MODE>> {
                PDx {
                    i: 14,
                    _mode: self._mode,
                }
            }
        }
        impl<MODE> PD14<Input<MODE>> {
            #[doc = " Erases the pin number from the type"]
            #[doc = ""]
            #[doc = " This is useful when you want to collect the pins into an array where you"]
            #[doc = " need all the elements to have the same type"]
            pub fn downgrade(self) -> PDx<Input<MODE>> {
                PDx {
                    i: 14,
                    _mode: self._mode,
                }
            }
        }
        impl<MODE> OutputPin for PD14<Output<MODE>> {
            type Error = Infallible;
            fn set_high(&mut self) -> Result<(), Self::Error> {
                unsafe { (*GPIOD::ptr()).bsrr.write(|w| w.bs14().set()) }
                Ok(())
            }
            fn set_low(&mut self) -> Result<(), Self::Error> {
                unsafe { (*GPIOD::ptr()).bsrr.write(|w| w.br14().reset()) }
                Ok(())
            }
        }
        #[cfg(feature = "unproven")]
        impl<MODE> InputPin for PD14<Input<MODE>> {
            type Error = Infallible;
            fn is_high(&self) -> Result<bool, Self::Error> {
                Ok(!self.is_low()?)
            }
            fn is_low(&self) -> Result<bool, Self::Error> {
                Ok(unsafe { (*GPIOD::ptr()).idr.read().idr14().is_low() })
            }
        }
        #[cfg(feature = "unproven")]
        impl InputPin for PD14<Output<OpenDrain>> {
            type Error = Infallible;
            fn is_high(&self) -> Result<bool, Self::Error> {
                Ok(!self.is_low()?)
            }
            fn is_low(&self) -> Result<bool, Self::Error> {
                Ok(unsafe { (*GPIOD::ptr()).idr.read().idr14().is_low() })
            }
        }
        #[cfg(feature = "unproven")]
        impl<MODE> StatefulOutputPin for PD14<Output<MODE>> {
            fn is_set_high(&self) -> Result<bool, Self::Error> {
                self.is_set_low().map(|b| !b)
            }
            fn is_set_low(&self) -> Result<bool, Self::Error> {
                Ok(unsafe { (*GPIOD::ptr()).odr.read().odr14().is_low() })
            }
        }
        #[cfg(feature = "unproven")]
        impl<MODE> toggleable::Default for PD14<Output<MODE>> {}
        #[doc = "Pin `PD15`"]
        pub struct PD15<MODE> {
            _mode: PhantomData<MODE>,
        }
        impl<MODE> PD15<MODE> {
            #[doc = "Configures `PD15` to serve as alternate function: `AF1`"]
            pub fn into_af1(self, moder: &mut MODER, afr: &mut AFRH) -> PD15<AF1> {
                moder.moder().modify(|_, w| w.moder15().alternate());
                afr.afr().modify(|_, w| w.afrh15().af1());
                PD15 { _mode: PhantomData }
            }
            #[doc = "Configures `PD15` to serve as alternate function: `AF2`"]
            pub fn into_af2(self, moder: &mut MODER, afr: &mut AFRH) -> PD15<AF2> {
                moder.moder().modify(|_, w| w.moder15().alternate());
                afr.afr().modify(|_, w| w.afrh15().af2());
                PD15 { _mode: PhantomData }
            }
            #[doc = "Configures `PD15` to serve as alternate function: `AF3`"]
            pub fn into_af3(self, moder: &mut MODER, afr: &mut AFRH) -> PD15<AF3> {
                moder.moder().modify(|_, w| w.moder15().alternate());
                afr.afr().modify(|_, w| w.afrh15().af3());
                PD15 { _mode: PhantomData }
            }
            #[doc = "Configures `PD15` to serve as alternate function: `AF6`"]
            pub fn into_af6(self, moder: &mut MODER, afr: &mut AFRH) -> PD15<AF6> {
                moder.moder().modify(|_, w| w.moder15().alternate());
                afr.afr().modify(|_, w| w.afrh15().af6());
                PD15 { _mode: PhantomData }
            }
            #[doc = " Configures the pin to operate as a floating input pin"]
            pub fn into_floating_input(
                self,
                moder: &mut MODER,
                pupdr: &mut PUPDR,
            ) -> PD15<Input<Floating>> {
                moder.moder().modify(|_, w| w.moder15().input());
                pupdr.pupdr().modify(|_, w| w.pupdr15().floating());
                PD15 { _mode: PhantomData }
            }
            #[doc = " Configures the pin to operate as a pulled down input pin"]
            pub fn into_pull_down_input(
                self,
                moder: &mut MODER,
                pupdr: &mut PUPDR,
            ) -> PD15<Input<PullDown>> {
                moder.moder().modify(|_, w| w.moder15().input());
                pupdr.pupdr().modify(|_, w| w.pupdr15().pull_down());
                PD15 { _mode: PhantomData }
            }
            #[doc = " Configures the pin to operate as a pulled up input pin"]
            pub fn into_pull_up_input(
                self,
                moder: &mut MODER,
                pupdr: &mut PUPDR,
            ) -> PD15<Input<PullUp>> {
                moder.moder().modify(|_, w| w.moder15().input());
                pupdr.pupdr().modify(|_, w| w.pupdr15().pull_up());
                PD15 { _mode: PhantomData }
            }
            #[doc = " Configures the pin to operate as an open drain output pin"]
            pub fn into_open_drain_output(
                self,
                moder: &mut MODER,
                otyper: &mut OTYPER,
            ) -> PD15<Output<OpenDrain>> {
                moder.moder().modify(|_, w| w.moder15().output());
                otyper.otyper().modify(|_, w| w.ot15().open_drain());
                PD15 { _mode: PhantomData }
            }
            #[doc = " Configures the pin to operate as an push pull output pin"]
            pub fn into_push_pull_output(
                self,
                moder: &mut MODER,
                otyper: &mut OTYPER,
            ) -> PD15<Output<PushPull>> {
                moder.moder().modify(|_, w| w.moder15().output());
                otyper.otyper().modify(|_, w| w.ot15().push_pull());
                PD15 { _mode: PhantomData }
            }
            #[doc = " Configures the pin to operate as analog, with disabled schmitt trigger."]
            #[doc = " This mode is suitable when the pin is connected to the DAC or ADC."]
            pub fn into_analog(self, moder: &mut MODER, pupdr: &mut PUPDR) -> PD15<Analog> {
                moder.moder().modify(|_, w| w.moder15().analog());
                pupdr.pupdr().modify(|_, w| w.pupdr15().floating());
                PD15 { _mode: PhantomData }
            }
        }
        impl PD15<Output<OpenDrain>> {
            #[doc = " Enables / disables the internal pull up"]
            pub fn internal_pull_up(&mut self, pupdr: &mut PUPDR, on: bool) {
                pupdr.pupdr().modify(|_, w| {
                    if on {
                        w.pupdr15().pull_up()
                    } else {
                        w.pupdr15().floating()
                    }
                });
            }
        }
        impl<MODE> PD15<Output<MODE>> {
            #[doc = " Erases the pin number from the type"]
            #[doc = ""]
            #[doc = " This is useful when you want to collect the pins into an array where you"]
            #[doc = " need all the elements to have the same type"]
            pub fn downgrade(self) -> PDx<Output<MODE>> {
                PDx {
                    i: 15,
                    _mode: self._mode,
                }
            }
        }
        impl<MODE> PD15<Input<MODE>> {
            #[doc = " Erases the pin number from the type"]
            #[doc = ""]
            #[doc = " This is useful when you want to collect the pins into an array where you"]
            #[doc = " need all the elements to have the same type"]
            pub fn downgrade(self) -> PDx<Input<MODE>> {
                PDx {
                    i: 15,
                    _mode: self._mode,
                }
            }
        }
        impl<MODE> OutputPin for PD15<Output<MODE>> {
            type Error = Infallible;
            fn set_high(&mut self) -> Result<(), Self::Error> {
                unsafe { (*GPIOD::ptr()).bsrr.write(|w| w.bs15().set()) }
                Ok(())
            }
            fn set_low(&mut self) -> Result<(), Self::Error> {
                unsafe { (*GPIOD::ptr()).bsrr.write(|w| w.br15().reset()) }
                Ok(())
            }
        }
        #[cfg(feature = "unproven")]
        impl<MODE> InputPin for PD15<Input<MODE>> {
            type Error = Infallible;
            fn is_high(&self) -> Result<bool, Self::Error> {
                Ok(!self.is_low()?)
            }
            fn is_low(&self) -> Result<bool, Self::Error> {
                Ok(unsafe { (*GPIOD::ptr()).idr.read().idr15().is_low() })
            }
        }
        #[cfg(feature = "unproven")]
        impl InputPin for PD15<Output<OpenDrain>> {
            type Error = Infallible;
            fn is_high(&self) -> Result<bool, Self::Error> {
                Ok(!self.is_low()?)
            }
            fn is_low(&self) -> Result<bool, Self::Error> {
                Ok(unsafe { (*GPIOD::ptr()).idr.read().idr15().is_low() })
            }
        }
        #[cfg(feature = "unproven")]
        impl<MODE> StatefulOutputPin for PD15<Output<MODE>> {
            fn is_set_high(&self) -> Result<bool, Self::Error> {
                self.is_set_low().map(|b| !b)
            }
            fn is_set_low(&self) -> Result<bool, Self::Error> {
                Ok(unsafe { (*GPIOD::ptr()).odr.read().odr15().is_low() })
            }
        }
        #[cfg(feature = "unproven")]
        impl<MODE> toggleable::Default for PD15<Output<MODE>> {}
    }
    #[doc = "All Pins and associated functions for GPIO Bank: `GPIOE`"]
    pub mod gpioe {
        use core::marker::PhantomData;
        use core::convert::Infallible;
        use crate::hal::digital::v2::OutputPin;
        #[cfg(feature = "unproven")]
        use crate::hal::digital::v2::InputPin;
        #[cfg(feature = "unproven")]
        use crate::hal::digital::v2::StatefulOutputPin;
        #[cfg(feature = "unproven")]
        use crate::hal::digital::v2::toggleable;
        use crate::pac::{gpioc, GPIOE};
        use crate::rcc::AHB;
        #[allow(unused_imports)]
        use super::{
            AF0, AF1, AF2, AF3, AF4, AF5, AF6, AF7, AF8, AF9, AF10, AF11, AF12, AF13, AF14, AF15,
        };
        use super::{
            Floating, GpioExt, Input, OpenDrain, Output, Analog, PullDown, PullUp, PushPull, PXx,
            Gpio,
        };
        #[doc = " GPIO parts"]
        pub struct Parts {
            #[doc = " Opaque AFRH register"]
            pub afrh: AFRH,
            #[doc = " Opaque AFRL register"]
            pub afrl: AFRL,
            #[doc = " Opaque MODER register"]
            pub moder: MODER,
            #[doc = " Opaque OTYPER register"]
            pub otyper: OTYPER,
            #[doc = " Opaque PUPDR register"]
            pub pupdr: PUPDR,
            #[doc = " Pin"]
            pub pe0: PE0<Input<Floating>>,
            #[doc = " Pin"]
            pub pe1: PE1<Input<Floating>>,
            #[doc = " Pin"]
            pub pe2: PE2<Input<Floating>>,
            #[doc = " Pin"]
            pub pe3: PE3<Input<Floating>>,
            #[doc = " Pin"]
            pub pe4: PE4<Input<Floating>>,
            #[doc = " Pin"]
            pub pe5: PE5<Input<Floating>>,
            #[doc = " Pin"]
            pub pe6: PE6<Input<Floating>>,
            #[doc = " Pin"]
            pub pe7: PE7<Input<Floating>>,
            #[doc = " Pin"]
            pub pe8: PE8<Input<Floating>>,
            #[doc = " Pin"]
            pub pe9: PE9<Input<Floating>>,
            #[doc = " Pin"]
            pub pe10: PE10<Input<Floating>>,
            #[doc = " Pin"]
            pub pe11: PE11<Input<Floating>>,
            #[doc = " Pin"]
            pub pe12: PE12<Input<Floating>>,
            #[doc = " Pin"]
            pub pe13: PE13<Input<Floating>>,
            #[doc = " Pin"]
            pub pe14: PE14<Input<Floating>>,
            #[doc = " Pin"]
            pub pe15: PE15<Input<Floating>>,
        }
        impl GpioExt for GPIOE {
            type Parts = Parts;
            fn split(self, ahb: &mut AHB) -> Parts {
                ahb.enr().modify(|_, w| w.iopeen().set_bit());
                ahb.rstr().modify(|_, w| w.ioperst().set_bit());
                ahb.rstr().modify(|_, w| w.ioperst().clear_bit());
                Parts {
                    afrh: AFRH { _0: () },
                    afrl: AFRL { _0: () },
                    moder: MODER { _0: () },
                    otyper: OTYPER { _0: () },
                    pupdr: PUPDR { _0: () },
                    pe0: PE0 { _mode: PhantomData },
                    pe1: PE1 { _mode: PhantomData },
                    pe2: PE2 { _mode: PhantomData },
                    pe3: PE3 { _mode: PhantomData },
                    pe4: PE4 { _mode: PhantomData },
                    pe5: PE5 { _mode: PhantomData },
                    pe6: PE6 { _mode: PhantomData },
                    pe7: PE7 { _mode: PhantomData },
                    pe8: PE8 { _mode: PhantomData },
                    pe9: PE9 { _mode: PhantomData },
                    pe10: PE10 { _mode: PhantomData },
                    pe11: PE11 { _mode: PhantomData },
                    pe12: PE12 { _mode: PhantomData },
                    pe13: PE13 { _mode: PhantomData },
                    pe14: PE14 { _mode: PhantomData },
                    pe15: PE15 { _mode: PhantomData },
                }
            }
        }
        #[doc = " Opaque AFRL register"]
        pub struct AFRL {
            _0: (),
        }
        impl AFRL {
            #[allow(dead_code)]
            pub(crate) fn afr(&mut self) -> &gpioc::AFRL {
                unsafe { &(*GPIOE::ptr()).afrl }
            }
        }
        #[doc = " Opaque AFRH register"]
        pub struct AFRH {
            _0: (),
        }
        impl AFRH {
            #[allow(dead_code)]
            pub(crate) fn afr(&mut self) -> &gpioc::AFRH {
                unsafe { &(*GPIOE::ptr()).afrh }
            }
        }
        #[doc = " Opaque MODER register"]
        pub struct MODER {
            _0: (),
        }
        impl MODER {
            pub(crate) fn moder(&mut self) -> &gpioc::MODER {
                unsafe { &(*GPIOE::ptr()).moder }
            }
        }
        #[doc = " Opaque OTYPER register"]
        pub struct OTYPER {
            _0: (),
        }
        impl OTYPER {
            pub(crate) fn otyper(&mut self) -> &gpioc::OTYPER {
                unsafe { &(*GPIOE::ptr()).otyper }
            }
        }
        #[doc = " Opaque PUPDR register"]
        pub struct PUPDR {
            _0: (),
        }
        impl PUPDR {
            pub(crate) fn pupdr(&mut self) -> &gpioc::PUPDR {
                unsafe { &(*GPIOE::ptr()).pupdr }
            }
        }
        #[doc = " Partially erased pin"]
        pub struct PEx<MODE> {
            i: u8,
            _mode: PhantomData<MODE>,
        }
        impl<MODE> PEx<MODE> {
            #[doc = " Erases the port letter from the type"]
            #[doc = ""]
            #[doc = " This is useful when you want to collect the pins into an array where you"]
            #[doc = " need all the elements to have the same type"]
            pub fn downgrade(self) -> PXx<MODE> {
                PXx {
                    i: self.i,
                    gpio: Gpio::GPIOE,
                    _mode: self._mode,
                }
            }
        }
        impl<MODE> OutputPin for PEx<Output<MODE>> {
            type Error = Infallible;
            fn set_high(&mut self) -> Result<(), Self::Error> {
                unsafe { (*GPIOE::ptr()).bsrr.write(|w| w.bits(1 << self.i)) }
                Ok(())
            }
            fn set_low(&mut self) -> Result<(), Self::Error> {
                unsafe { (*GPIOE::ptr()).bsrr.write(|w| w.bits(1 << (16 + self.i))) }
                Ok(())
            }
        }
        #[cfg(feature = "unproven")]
        impl<MODE> InputPin for PEx<Input<MODE>> {
            type Error = Infallible;
            fn is_high(&self) -> Result<bool, Self::Error> {
                Ok(!self.is_low()?)
            }
            fn is_low(&self) -> Result<bool, Self::Error> {
                Ok(unsafe { (*GPIOE::ptr()).idr.read().bits() & (1 << self.i) == 0 })
            }
        }
        #[cfg(feature = "unproven")]
        impl InputPin for PEx<Output<OpenDrain>> {
            type Error = Infallible;
            fn is_high(&self) -> Result<bool, Self::Error> {
                Ok(!self.is_low()?)
            }
            fn is_low(&self) -> Result<bool, Self::Error> {
                Ok(unsafe { (*GPIOE::ptr()).idr.read().bits() & (1 << self.i) == 0 })
            }
        }
        #[cfg(feature = "unproven")]
        impl<MODE> StatefulOutputPin for PEx<Output<MODE>> {
            fn is_set_high(&self) -> Result<bool, Self::Error> {
                self.is_set_low().map(|b| !b)
            }
            fn is_set_low(&self) -> Result<bool, Self::Error> {
                Ok(unsafe { (*GPIOE::ptr()).odr.read().bits() & (1 << self.i) == 0 })
            }
        }
        #[cfg(feature = "unproven")]
        impl<MODE> toggleable::Default for PEx<Output<MODE>> {}
        #[doc = "Pin `PE0`"]
        pub struct PE0<MODE> {
            _mode: PhantomData<MODE>,
        }
        impl<MODE> PE0<MODE> {
            #[doc = "Configures `PE0` to serve as alternate function: `AF1`"]
            pub fn into_af1(self, moder: &mut MODER, afr: &mut AFRL) -> PE0<AF1> {
                moder.moder().modify(|_, w| w.moder0().alternate());
                afr.afr().modify(|_, w| w.afrl0().af1());
                PE0 { _mode: PhantomData }
            }
            #[doc = "Configures `PE0` to serve as alternate function: `AF2`"]
            pub fn into_af2(self, moder: &mut MODER, afr: &mut AFRL) -> PE0<AF2> {
                moder.moder().modify(|_, w| w.moder0().alternate());
                afr.afr().modify(|_, w| w.afrl0().af2());
                PE0 { _mode: PhantomData }
            }
            #[doc = "Configures `PE0` to serve as alternate function: `AF4`"]
            pub fn into_af4(self, moder: &mut MODER, afr: &mut AFRL) -> PE0<AF4> {
                moder.moder().modify(|_, w| w.moder0().alternate());
                afr.afr().modify(|_, w| w.afrl0().af4());
                PE0 { _mode: PhantomData }
            }
            #[doc = "Configures `PE0` to serve as alternate function: `AF7`"]
            pub fn into_af7(self, moder: &mut MODER, afr: &mut AFRL) -> PE0<AF7> {
                moder.moder().modify(|_, w| w.moder0().alternate());
                afr.afr().modify(|_, w| w.afrl0().af7());
                PE0 { _mode: PhantomData }
            }
            #[doc = " Configures the pin to operate as a floating input pin"]
            pub fn into_floating_input(
                self,
                moder: &mut MODER,
                pupdr: &mut PUPDR,
            ) -> PE0<Input<Floating>> {
                moder.moder().modify(|_, w| w.moder0().input());
                pupdr.pupdr().modify(|_, w| w.pupdr0().floating());
                PE0 { _mode: PhantomData }
            }
            #[doc = " Configures the pin to operate as a pulled down input pin"]
            pub fn into_pull_down_input(
                self,
                moder: &mut MODER,
                pupdr: &mut PUPDR,
            ) -> PE0<Input<PullDown>> {
                moder.moder().modify(|_, w| w.moder0().input());
                pupdr.pupdr().modify(|_, w| w.pupdr0().pull_down());
                PE0 { _mode: PhantomData }
            }
            #[doc = " Configures the pin to operate as a pulled up input pin"]
            pub fn into_pull_up_input(
                self,
                moder: &mut MODER,
                pupdr: &mut PUPDR,
            ) -> PE0<Input<PullUp>> {
                moder.moder().modify(|_, w| w.moder0().input());
                pupdr.pupdr().modify(|_, w| w.pupdr0().pull_up());
                PE0 { _mode: PhantomData }
            }
            #[doc = " Configures the pin to operate as an open drain output pin"]
            pub fn into_open_drain_output(
                self,
                moder: &mut MODER,
                otyper: &mut OTYPER,
            ) -> PE0<Output<OpenDrain>> {
                moder.moder().modify(|_, w| w.moder0().output());
                otyper.otyper().modify(|_, w| w.ot0().open_drain());
                PE0 { _mode: PhantomData }
            }
            #[doc = " Configures the pin to operate as an push pull output pin"]
            pub fn into_push_pull_output(
                self,
                moder: &mut MODER,
                otyper: &mut OTYPER,
            ) -> PE0<Output<PushPull>> {
                moder.moder().modify(|_, w| w.moder0().output());
                otyper.otyper().modify(|_, w| w.ot0().push_pull());
                PE0 { _mode: PhantomData }
            }
            #[doc = " Configures the pin to operate as analog, with disabled schmitt trigger."]
            #[doc = " This mode is suitable when the pin is connected to the DAC or ADC."]
            pub fn into_analog(self, moder: &mut MODER, pupdr: &mut PUPDR) -> PE0<Analog> {
                moder.moder().modify(|_, w| w.moder0().analog());
                pupdr.pupdr().modify(|_, w| w.pupdr0().floating());
                PE0 { _mode: PhantomData }
            }
        }
        impl PE0<Output<OpenDrain>> {
            #[doc = " Enables / disables the internal pull up"]
            pub fn internal_pull_up(&mut self, pupdr: &mut PUPDR, on: bool) {
                pupdr.pupdr().modify(|_, w| {
                    if on {
                        w.pupdr0().pull_up()
                    } else {
                        w.pupdr0().floating()
                    }
                });
            }
        }
        impl<MODE> PE0<Output<MODE>> {
            #[doc = " Erases the pin number from the type"]
            #[doc = ""]
            #[doc = " This is useful when you want to collect the pins into an array where you"]
            #[doc = " need all the elements to have the same type"]
            pub fn downgrade(self) -> PEx<Output<MODE>> {
                PEx {
                    i: 0,
                    _mode: self._mode,
                }
            }
        }
        impl<MODE> PE0<Input<MODE>> {
            #[doc = " Erases the pin number from the type"]
            #[doc = ""]
            #[doc = " This is useful when you want to collect the pins into an array where you"]
            #[doc = " need all the elements to have the same type"]
            pub fn downgrade(self) -> PEx<Input<MODE>> {
                PEx {
                    i: 0,
                    _mode: self._mode,
                }
            }
        }
        impl<MODE> OutputPin for PE0<Output<MODE>> {
            type Error = Infallible;
            fn set_high(&mut self) -> Result<(), Self::Error> {
                unsafe { (*GPIOE::ptr()).bsrr.write(|w| w.bs0().set()) }
                Ok(())
            }
            fn set_low(&mut self) -> Result<(), Self::Error> {
                unsafe { (*GPIOE::ptr()).bsrr.write(|w| w.br0().reset()) }
                Ok(())
            }
        }
        #[cfg(feature = "unproven")]
        impl<MODE> InputPin for PE0<Input<MODE>> {
            type Error = Infallible;
            fn is_high(&self) -> Result<bool, Self::Error> {
                Ok(!self.is_low()?)
            }
            fn is_low(&self) -> Result<bool, Self::Error> {
                Ok(unsafe { (*GPIOE::ptr()).idr.read().idr0().is_low() })
            }
        }
        #[cfg(feature = "unproven")]
        impl InputPin for PE0<Output<OpenDrain>> {
            type Error = Infallible;
            fn is_high(&self) -> Result<bool, Self::Error> {
                Ok(!self.is_low()?)
            }
            fn is_low(&self) -> Result<bool, Self::Error> {
                Ok(unsafe { (*GPIOE::ptr()).idr.read().idr0().is_low() })
            }
        }
        #[cfg(feature = "unproven")]
        impl<MODE> StatefulOutputPin for PE0<Output<MODE>> {
            fn is_set_high(&self) -> Result<bool, Self::Error> {
                self.is_set_low().map(|b| !b)
            }
            fn is_set_low(&self) -> Result<bool, Self::Error> {
                Ok(unsafe { (*GPIOE::ptr()).odr.read().odr0().is_low() })
            }
        }
        #[cfg(feature = "unproven")]
        impl<MODE> toggleable::Default for PE0<Output<MODE>> {}
        #[doc = "Pin `PE1`"]
        pub struct PE1<MODE> {
            _mode: PhantomData<MODE>,
        }
        impl<MODE> PE1<MODE> {
            #[doc = "Configures `PE1` to serve as alternate function: `AF1`"]
            pub fn into_af1(self, moder: &mut MODER, afr: &mut AFRL) -> PE1<AF1> {
                moder.moder().modify(|_, w| w.moder1().alternate());
                afr.afr().modify(|_, w| w.afrl1().af1());
                PE1 { _mode: PhantomData }
            }
            #[doc = "Configures `PE1` to serve as alternate function: `AF4`"]
            pub fn into_af4(self, moder: &mut MODER, afr: &mut AFRL) -> PE1<AF4> {
                moder.moder().modify(|_, w| w.moder1().alternate());
                afr.afr().modify(|_, w| w.afrl1().af4());
                PE1 { _mode: PhantomData }
            }
            #[doc = "Configures `PE1` to serve as alternate function: `AF7`"]
            pub fn into_af7(self, moder: &mut MODER, afr: &mut AFRL) -> PE1<AF7> {
                moder.moder().modify(|_, w| w.moder1().alternate());
                afr.afr().modify(|_, w| w.afrl1().af7());
                PE1 { _mode: PhantomData }
            }
            #[doc = " Configures the pin to operate as a floating input pin"]
            pub fn into_floating_input(
                self,
                moder: &mut MODER,
                pupdr: &mut PUPDR,
            ) -> PE1<Input<Floating>> {
                moder.moder().modify(|_, w| w.moder1().input());
                pupdr.pupdr().modify(|_, w| w.pupdr1().floating());
                PE1 { _mode: PhantomData }
            }
            #[doc = " Configures the pin to operate as a pulled down input pin"]
            pub fn into_pull_down_input(
                self,
                moder: &mut MODER,
                pupdr: &mut PUPDR,
            ) -> PE1<Input<PullDown>> {
                moder.moder().modify(|_, w| w.moder1().input());
                pupdr.pupdr().modify(|_, w| w.pupdr1().pull_down());
                PE1 { _mode: PhantomData }
            }
            #[doc = " Configures the pin to operate as a pulled up input pin"]
            pub fn into_pull_up_input(
                self,
                moder: &mut MODER,
                pupdr: &mut PUPDR,
            ) -> PE1<Input<PullUp>> {
                moder.moder().modify(|_, w| w.moder1().input());
                pupdr.pupdr().modify(|_, w| w.pupdr1().pull_up());
                PE1 { _mode: PhantomData }
            }
            #[doc = " Configures the pin to operate as an open drain output pin"]
            pub fn into_open_drain_output(
                self,
                moder: &mut MODER,
                otyper: &mut OTYPER,
            ) -> PE1<Output<OpenDrain>> {
                moder.moder().modify(|_, w| w.moder1().output());
                otyper.otyper().modify(|_, w| w.ot1().open_drain());
                PE1 { _mode: PhantomData }
            }
            #[doc = " Configures the pin to operate as an push pull output pin"]
            pub fn into_push_pull_output(
                self,
                moder: &mut MODER,
                otyper: &mut OTYPER,
            ) -> PE1<Output<PushPull>> {
                moder.moder().modify(|_, w| w.moder1().output());
                otyper.otyper().modify(|_, w| w.ot1().push_pull());
                PE1 { _mode: PhantomData }
            }
            #[doc = " Configures the pin to operate as analog, with disabled schmitt trigger."]
            #[doc = " This mode is suitable when the pin is connected to the DAC or ADC."]
            pub fn into_analog(self, moder: &mut MODER, pupdr: &mut PUPDR) -> PE1<Analog> {
                moder.moder().modify(|_, w| w.moder1().analog());
                pupdr.pupdr().modify(|_, w| w.pupdr1().floating());
                PE1 { _mode: PhantomData }
            }
        }
        impl PE1<Output<OpenDrain>> {
            #[doc = " Enables / disables the internal pull up"]
            pub fn internal_pull_up(&mut self, pupdr: &mut PUPDR, on: bool) {
                pupdr.pupdr().modify(|_, w| {
                    if on {
                        w.pupdr1().pull_up()
                    } else {
                        w.pupdr1().floating()
                    }
                });
            }
        }
        impl<MODE> PE1<Output<MODE>> {
            #[doc = " Erases the pin number from the type"]
            #[doc = ""]
            #[doc = " This is useful when you want to collect the pins into an array where you"]
            #[doc = " need all the elements to have the same type"]
            pub fn downgrade(self) -> PEx<Output<MODE>> {
                PEx {
                    i: 1,
                    _mode: self._mode,
                }
            }
        }
        impl<MODE> PE1<Input<MODE>> {
            #[doc = " Erases the pin number from the type"]
            #[doc = ""]
            #[doc = " This is useful when you want to collect the pins into an array where you"]
            #[doc = " need all the elements to have the same type"]
            pub fn downgrade(self) -> PEx<Input<MODE>> {
                PEx {
                    i: 1,
                    _mode: self._mode,
                }
            }
        }
        impl<MODE> OutputPin for PE1<Output<MODE>> {
            type Error = Infallible;
            fn set_high(&mut self) -> Result<(), Self::Error> {
                unsafe { (*GPIOE::ptr()).bsrr.write(|w| w.bs1().set()) }
                Ok(())
            }
            fn set_low(&mut self) -> Result<(), Self::Error> {
                unsafe { (*GPIOE::ptr()).bsrr.write(|w| w.br1().reset()) }
                Ok(())
            }
        }
        #[cfg(feature = "unproven")]
        impl<MODE> InputPin for PE1<Input<MODE>> {
            type Error = Infallible;
            fn is_high(&self) -> Result<bool, Self::Error> {
                Ok(!self.is_low()?)
            }
            fn is_low(&self) -> Result<bool, Self::Error> {
                Ok(unsafe { (*GPIOE::ptr()).idr.read().idr1().is_low() })
            }
        }
        #[cfg(feature = "unproven")]
        impl InputPin for PE1<Output<OpenDrain>> {
            type Error = Infallible;
            fn is_high(&self) -> Result<bool, Self::Error> {
                Ok(!self.is_low()?)
            }
            fn is_low(&self) -> Result<bool, Self::Error> {
                Ok(unsafe { (*GPIOE::ptr()).idr.read().idr1().is_low() })
            }
        }
        #[cfg(feature = "unproven")]
        impl<MODE> StatefulOutputPin for PE1<Output<MODE>> {
            fn is_set_high(&self) -> Result<bool, Self::Error> {
                self.is_set_low().map(|b| !b)
            }
            fn is_set_low(&self) -> Result<bool, Self::Error> {
                Ok(unsafe { (*GPIOE::ptr()).odr.read().odr1().is_low() })
            }
        }
        #[cfg(feature = "unproven")]
        impl<MODE> toggleable::Default for PE1<Output<MODE>> {}
        #[doc = "Pin `PE2`"]
        pub struct PE2<MODE> {
            _mode: PhantomData<MODE>,
        }
        impl<MODE> PE2<MODE> {
            #[doc = "Configures `PE2` to serve as alternate function: `AF0`"]
            pub fn into_af0(self, moder: &mut MODER, afr: &mut AFRL) -> PE2<AF0> {
                moder.moder().modify(|_, w| w.moder2().alternate());
                afr.afr().modify(|_, w| w.afrl2().af0());
                PE2 { _mode: PhantomData }
            }
            #[doc = "Configures `PE2` to serve as alternate function: `AF1`"]
            pub fn into_af1(self, moder: &mut MODER, afr: &mut AFRL) -> PE2<AF1> {
                moder.moder().modify(|_, w| w.moder2().alternate());
                afr.afr().modify(|_, w| w.afrl2().af1());
                PE2 { _mode: PhantomData }
            }
            #[doc = "Configures `PE2` to serve as alternate function: `AF2`"]
            pub fn into_af2(self, moder: &mut MODER, afr: &mut AFRL) -> PE2<AF2> {
                moder.moder().modify(|_, w| w.moder2().alternate());
                afr.afr().modify(|_, w| w.afrl2().af2());
                PE2 { _mode: PhantomData }
            }
            #[doc = "Configures `PE2` to serve as alternate function: `AF3`"]
            pub fn into_af3(self, moder: &mut MODER, afr: &mut AFRL) -> PE2<AF3> {
                moder.moder().modify(|_, w| w.moder2().alternate());
                afr.afr().modify(|_, w| w.afrl2().af3());
                PE2 { _mode: PhantomData }
            }
            #[doc = " Configures the pin to operate as a floating input pin"]
            pub fn into_floating_input(
                self,
                moder: &mut MODER,
                pupdr: &mut PUPDR,
            ) -> PE2<Input<Floating>> {
                moder.moder().modify(|_, w| w.moder2().input());
                pupdr.pupdr().modify(|_, w| w.pupdr2().floating());
                PE2 { _mode: PhantomData }
            }
            #[doc = " Configures the pin to operate as a pulled down input pin"]
            pub fn into_pull_down_input(
                self,
                moder: &mut MODER,
                pupdr: &mut PUPDR,
            ) -> PE2<Input<PullDown>> {
                moder.moder().modify(|_, w| w.moder2().input());
                pupdr.pupdr().modify(|_, w| w.pupdr2().pull_down());
                PE2 { _mode: PhantomData }
            }
            #[doc = " Configures the pin to operate as a pulled up input pin"]
            pub fn into_pull_up_input(
                self,
                moder: &mut MODER,
                pupdr: &mut PUPDR,
            ) -> PE2<Input<PullUp>> {
                moder.moder().modify(|_, w| w.moder2().input());
                pupdr.pupdr().modify(|_, w| w.pupdr2().pull_up());
                PE2 { _mode: PhantomData }
            }
            #[doc = " Configures the pin to operate as an open drain output pin"]
            pub fn into_open_drain_output(
                self,
                moder: &mut MODER,
                otyper: &mut OTYPER,
            ) -> PE2<Output<OpenDrain>> {
                moder.moder().modify(|_, w| w.moder2().output());
                otyper.otyper().modify(|_, w| w.ot2().open_drain());
                PE2 { _mode: PhantomData }
            }
            #[doc = " Configures the pin to operate as an push pull output pin"]
            pub fn into_push_pull_output(
                self,
                moder: &mut MODER,
                otyper: &mut OTYPER,
            ) -> PE2<Output<PushPull>> {
                moder.moder().modify(|_, w| w.moder2().output());
                otyper.otyper().modify(|_, w| w.ot2().push_pull());
                PE2 { _mode: PhantomData }
            }
            #[doc = " Configures the pin to operate as analog, with disabled schmitt trigger."]
            #[doc = " This mode is suitable when the pin is connected to the DAC or ADC."]
            pub fn into_analog(self, moder: &mut MODER, pupdr: &mut PUPDR) -> PE2<Analog> {
                moder.moder().modify(|_, w| w.moder2().analog());
                pupdr.pupdr().modify(|_, w| w.pupdr2().floating());
                PE2 { _mode: PhantomData }
            }
        }
        impl PE2<Output<OpenDrain>> {
            #[doc = " Enables / disables the internal pull up"]
            pub fn internal_pull_up(&mut self, pupdr: &mut PUPDR, on: bool) {
                pupdr.pupdr().modify(|_, w| {
                    if on {
                        w.pupdr2().pull_up()
                    } else {
                        w.pupdr2().floating()
                    }
                });
            }
        }
        impl<MODE> PE2<Output<MODE>> {
            #[doc = " Erases the pin number from the type"]
            #[doc = ""]
            #[doc = " This is useful when you want to collect the pins into an array where you"]
            #[doc = " need all the elements to have the same type"]
            pub fn downgrade(self) -> PEx<Output<MODE>> {
                PEx {
                    i: 2,
                    _mode: self._mode,
                }
            }
        }
        impl<MODE> PE2<Input<MODE>> {
            #[doc = " Erases the pin number from the type"]
            #[doc = ""]
            #[doc = " This is useful when you want to collect the pins into an array where you"]
            #[doc = " need all the elements to have the same type"]
            pub fn downgrade(self) -> PEx<Input<MODE>> {
                PEx {
                    i: 2,
                    _mode: self._mode,
                }
            }
        }
        impl<MODE> OutputPin for PE2<Output<MODE>> {
            type Error = Infallible;
            fn set_high(&mut self) -> Result<(), Self::Error> {
                unsafe { (*GPIOE::ptr()).bsrr.write(|w| w.bs2().set()) }
                Ok(())
            }
            fn set_low(&mut self) -> Result<(), Self::Error> {
                unsafe { (*GPIOE::ptr()).bsrr.write(|w| w.br2().reset()) }
                Ok(())
            }
        }
        #[cfg(feature = "unproven")]
        impl<MODE> InputPin for PE2<Input<MODE>> {
            type Error = Infallible;
            fn is_high(&self) -> Result<bool, Self::Error> {
                Ok(!self.is_low()?)
            }
            fn is_low(&self) -> Result<bool, Self::Error> {
                Ok(unsafe { (*GPIOE::ptr()).idr.read().idr2().is_low() })
            }
        }
        #[cfg(feature = "unproven")]
        impl InputPin for PE2<Output<OpenDrain>> {
            type Error = Infallible;
            fn is_high(&self) -> Result<bool, Self::Error> {
                Ok(!self.is_low()?)
            }
            fn is_low(&self) -> Result<bool, Self::Error> {
                Ok(unsafe { (*GPIOE::ptr()).idr.read().idr2().is_low() })
            }
        }
        #[cfg(feature = "unproven")]
        impl<MODE> StatefulOutputPin for PE2<Output<MODE>> {
            fn is_set_high(&self) -> Result<bool, Self::Error> {
                self.is_set_low().map(|b| !b)
            }
            fn is_set_low(&self) -> Result<bool, Self::Error> {
                Ok(unsafe { (*GPIOE::ptr()).odr.read().odr2().is_low() })
            }
        }
        #[cfg(feature = "unproven")]
        impl<MODE> toggleable::Default for PE2<Output<MODE>> {}
        #[doc = "Pin `PE3`"]
        pub struct PE3<MODE> {
            _mode: PhantomData<MODE>,
        }
        impl<MODE> PE3<MODE> {
            #[doc = "Configures `PE3` to serve as alternate function: `AF0`"]
            pub fn into_af0(self, moder: &mut MODER, afr: &mut AFRL) -> PE3<AF0> {
                moder.moder().modify(|_, w| w.moder3().alternate());
                afr.afr().modify(|_, w| w.afrl3().af0());
                PE3 { _mode: PhantomData }
            }
            #[doc = "Configures `PE3` to serve as alternate function: `AF1`"]
            pub fn into_af1(self, moder: &mut MODER, afr: &mut AFRL) -> PE3<AF1> {
                moder.moder().modify(|_, w| w.moder3().alternate());
                afr.afr().modify(|_, w| w.afrl3().af1());
                PE3 { _mode: PhantomData }
            }
            #[doc = "Configures `PE3` to serve as alternate function: `AF2`"]
            pub fn into_af2(self, moder: &mut MODER, afr: &mut AFRL) -> PE3<AF2> {
                moder.moder().modify(|_, w| w.moder3().alternate());
                afr.afr().modify(|_, w| w.afrl3().af2());
                PE3 { _mode: PhantomData }
            }
            #[doc = "Configures `PE3` to serve as alternate function: `AF3`"]
            pub fn into_af3(self, moder: &mut MODER, afr: &mut AFRL) -> PE3<AF3> {
                moder.moder().modify(|_, w| w.moder3().alternate());
                afr.afr().modify(|_, w| w.afrl3().af3());
                PE3 { _mode: PhantomData }
            }
            #[doc = " Configures the pin to operate as a floating input pin"]
            pub fn into_floating_input(
                self,
                moder: &mut MODER,
                pupdr: &mut PUPDR,
            ) -> PE3<Input<Floating>> {
                moder.moder().modify(|_, w| w.moder3().input());
                pupdr.pupdr().modify(|_, w| w.pupdr3().floating());
                PE3 { _mode: PhantomData }
            }
            #[doc = " Configures the pin to operate as a pulled down input pin"]
            pub fn into_pull_down_input(
                self,
                moder: &mut MODER,
                pupdr: &mut PUPDR,
            ) -> PE3<Input<PullDown>> {
                moder.moder().modify(|_, w| w.moder3().input());
                pupdr.pupdr().modify(|_, w| w.pupdr3().pull_down());
                PE3 { _mode: PhantomData }
            }
            #[doc = " Configures the pin to operate as a pulled up input pin"]
            pub fn into_pull_up_input(
                self,
                moder: &mut MODER,
                pupdr: &mut PUPDR,
            ) -> PE3<Input<PullUp>> {
                moder.moder().modify(|_, w| w.moder3().input());
                pupdr.pupdr().modify(|_, w| w.pupdr3().pull_up());
                PE3 { _mode: PhantomData }
            }
            #[doc = " Configures the pin to operate as an open drain output pin"]
            pub fn into_open_drain_output(
                self,
                moder: &mut MODER,
                otyper: &mut OTYPER,
            ) -> PE3<Output<OpenDrain>> {
                moder.moder().modify(|_, w| w.moder3().output());
                otyper.otyper().modify(|_, w| w.ot3().open_drain());
                PE3 { _mode: PhantomData }
            }
            #[doc = " Configures the pin to operate as an push pull output pin"]
            pub fn into_push_pull_output(
                self,
                moder: &mut MODER,
                otyper: &mut OTYPER,
            ) -> PE3<Output<PushPull>> {
                moder.moder().modify(|_, w| w.moder3().output());
                otyper.otyper().modify(|_, w| w.ot3().push_pull());
                PE3 { _mode: PhantomData }
            }
            #[doc = " Configures the pin to operate as analog, with disabled schmitt trigger."]
            #[doc = " This mode is suitable when the pin is connected to the DAC or ADC."]
            pub fn into_analog(self, moder: &mut MODER, pupdr: &mut PUPDR) -> PE3<Analog> {
                moder.moder().modify(|_, w| w.moder3().analog());
                pupdr.pupdr().modify(|_, w| w.pupdr3().floating());
                PE3 { _mode: PhantomData }
            }
        }
        impl PE3<Output<OpenDrain>> {
            #[doc = " Enables / disables the internal pull up"]
            pub fn internal_pull_up(&mut self, pupdr: &mut PUPDR, on: bool) {
                pupdr.pupdr().modify(|_, w| {
                    if on {
                        w.pupdr3().pull_up()
                    } else {
                        w.pupdr3().floating()
                    }
                });
            }
        }
        impl<MODE> PE3<Output<MODE>> {
            #[doc = " Erases the pin number from the type"]
            #[doc = ""]
            #[doc = " This is useful when you want to collect the pins into an array where you"]
            #[doc = " need all the elements to have the same type"]
            pub fn downgrade(self) -> PEx<Output<MODE>> {
                PEx {
                    i: 3,
                    _mode: self._mode,
                }
            }
        }
        impl<MODE> PE3<Input<MODE>> {
            #[doc = " Erases the pin number from the type"]
            #[doc = ""]
            #[doc = " This is useful when you want to collect the pins into an array where you"]
            #[doc = " need all the elements to have the same type"]
            pub fn downgrade(self) -> PEx<Input<MODE>> {
                PEx {
                    i: 3,
                    _mode: self._mode,
                }
            }
        }
        impl<MODE> OutputPin for PE3<Output<MODE>> {
            type Error = Infallible;
            fn set_high(&mut self) -> Result<(), Self::Error> {
                unsafe { (*GPIOE::ptr()).bsrr.write(|w| w.bs3().set()) }
                Ok(())
            }
            fn set_low(&mut self) -> Result<(), Self::Error> {
                unsafe { (*GPIOE::ptr()).bsrr.write(|w| w.br3().reset()) }
                Ok(())
            }
        }
        #[cfg(feature = "unproven")]
        impl<MODE> InputPin for PE3<Input<MODE>> {
            type Error = Infallible;
            fn is_high(&self) -> Result<bool, Self::Error> {
                Ok(!self.is_low()?)
            }
            fn is_low(&self) -> Result<bool, Self::Error> {
                Ok(unsafe { (*GPIOE::ptr()).idr.read().idr3().is_low() })
            }
        }
        #[cfg(feature = "unproven")]
        impl InputPin for PE3<Output<OpenDrain>> {
            type Error = Infallible;
            fn is_high(&self) -> Result<bool, Self::Error> {
                Ok(!self.is_low()?)
            }
            fn is_low(&self) -> Result<bool, Self::Error> {
                Ok(unsafe { (*GPIOE::ptr()).idr.read().idr3().is_low() })
            }
        }
        #[cfg(feature = "unproven")]
        impl<MODE> StatefulOutputPin for PE3<Output<MODE>> {
            fn is_set_high(&self) -> Result<bool, Self::Error> {
                self.is_set_low().map(|b| !b)
            }
            fn is_set_low(&self) -> Result<bool, Self::Error> {
                Ok(unsafe { (*GPIOE::ptr()).odr.read().odr3().is_low() })
            }
        }
        #[cfg(feature = "unproven")]
        impl<MODE> toggleable::Default for PE3<Output<MODE>> {}
        #[doc = "Pin `PE4`"]
        pub struct PE4<MODE> {
            _mode: PhantomData<MODE>,
        }
        impl<MODE> PE4<MODE> {
            #[doc = "Configures `PE4` to serve as alternate function: `AF0`"]
            pub fn into_af0(self, moder: &mut MODER, afr: &mut AFRL) -> PE4<AF0> {
                moder.moder().modify(|_, w| w.moder4().alternate());
                afr.afr().modify(|_, w| w.afrl4().af0());
                PE4 { _mode: PhantomData }
            }
            #[doc = "Configures `PE4` to serve as alternate function: `AF1`"]
            pub fn into_af1(self, moder: &mut MODER, afr: &mut AFRL) -> PE4<AF1> {
                moder.moder().modify(|_, w| w.moder4().alternate());
                afr.afr().modify(|_, w| w.afrl4().af1());
                PE4 { _mode: PhantomData }
            }
            #[doc = "Configures `PE4` to serve as alternate function: `AF2`"]
            pub fn into_af2(self, moder: &mut MODER, afr: &mut AFRL) -> PE4<AF2> {
                moder.moder().modify(|_, w| w.moder4().alternate());
                afr.afr().modify(|_, w| w.afrl4().af2());
                PE4 { _mode: PhantomData }
            }
            #[doc = "Configures `PE4` to serve as alternate function: `AF3`"]
            pub fn into_af3(self, moder: &mut MODER, afr: &mut AFRL) -> PE4<AF3> {
                moder.moder().modify(|_, w| w.moder4().alternate());
                afr.afr().modify(|_, w| w.afrl4().af3());
                PE4 { _mode: PhantomData }
            }
            #[doc = " Configures the pin to operate as a floating input pin"]
            pub fn into_floating_input(
                self,
                moder: &mut MODER,
                pupdr: &mut PUPDR,
            ) -> PE4<Input<Floating>> {
                moder.moder().modify(|_, w| w.moder4().input());
                pupdr.pupdr().modify(|_, w| w.pupdr4().floating());
                PE4 { _mode: PhantomData }
            }
            #[doc = " Configures the pin to operate as a pulled down input pin"]
            pub fn into_pull_down_input(
                self,
                moder: &mut MODER,
                pupdr: &mut PUPDR,
            ) -> PE4<Input<PullDown>> {
                moder.moder().modify(|_, w| w.moder4().input());
                pupdr.pupdr().modify(|_, w| w.pupdr4().pull_down());
                PE4 { _mode: PhantomData }
            }
            #[doc = " Configures the pin to operate as a pulled up input pin"]
            pub fn into_pull_up_input(
                self,
                moder: &mut MODER,
                pupdr: &mut PUPDR,
            ) -> PE4<Input<PullUp>> {
                moder.moder().modify(|_, w| w.moder4().input());
                pupdr.pupdr().modify(|_, w| w.pupdr4().pull_up());
                PE4 { _mode: PhantomData }
            }
            #[doc = " Configures the pin to operate as an open drain output pin"]
            pub fn into_open_drain_output(
                self,
                moder: &mut MODER,
                otyper: &mut OTYPER,
            ) -> PE4<Output<OpenDrain>> {
                moder.moder().modify(|_, w| w.moder4().output());
                otyper.otyper().modify(|_, w| w.ot4().open_drain());
                PE4 { _mode: PhantomData }
            }
            #[doc = " Configures the pin to operate as an push pull output pin"]
            pub fn into_push_pull_output(
                self,
                moder: &mut MODER,
                otyper: &mut OTYPER,
            ) -> PE4<Output<PushPull>> {
                moder.moder().modify(|_, w| w.moder4().output());
                otyper.otyper().modify(|_, w| w.ot4().push_pull());
                PE4 { _mode: PhantomData }
            }
            #[doc = " Configures the pin to operate as analog, with disabled schmitt trigger."]
            #[doc = " This mode is suitable when the pin is connected to the DAC or ADC."]
            pub fn into_analog(self, moder: &mut MODER, pupdr: &mut PUPDR) -> PE4<Analog> {
                moder.moder().modify(|_, w| w.moder4().analog());
                pupdr.pupdr().modify(|_, w| w.pupdr4().floating());
                PE4 { _mode: PhantomData }
            }
        }
        impl PE4<Output<OpenDrain>> {
            #[doc = " Enables / disables the internal pull up"]
            pub fn internal_pull_up(&mut self, pupdr: &mut PUPDR, on: bool) {
                pupdr.pupdr().modify(|_, w| {
                    if on {
                        w.pupdr4().pull_up()
                    } else {
                        w.pupdr4().floating()
                    }
                });
            }
        }
        impl<MODE> PE4<Output<MODE>> {
            #[doc = " Erases the pin number from the type"]
            #[doc = ""]
            #[doc = " This is useful when you want to collect the pins into an array where you"]
            #[doc = " need all the elements to have the same type"]
            pub fn downgrade(self) -> PEx<Output<MODE>> {
                PEx {
                    i: 4,
                    _mode: self._mode,
                }
            }
        }
        impl<MODE> PE4<Input<MODE>> {
            #[doc = " Erases the pin number from the type"]
            #[doc = ""]
            #[doc = " This is useful when you want to collect the pins into an array where you"]
            #[doc = " need all the elements to have the same type"]
            pub fn downgrade(self) -> PEx<Input<MODE>> {
                PEx {
                    i: 4,
                    _mode: self._mode,
                }
            }
        }
        impl<MODE> OutputPin for PE4<Output<MODE>> {
            type Error = Infallible;
            fn set_high(&mut self) -> Result<(), Self::Error> {
                unsafe { (*GPIOE::ptr()).bsrr.write(|w| w.bs4().set()) }
                Ok(())
            }
            fn set_low(&mut self) -> Result<(), Self::Error> {
                unsafe { (*GPIOE::ptr()).bsrr.write(|w| w.br4().reset()) }
                Ok(())
            }
        }
        #[cfg(feature = "unproven")]
        impl<MODE> InputPin for PE4<Input<MODE>> {
            type Error = Infallible;
            fn is_high(&self) -> Result<bool, Self::Error> {
                Ok(!self.is_low()?)
            }
            fn is_low(&self) -> Result<bool, Self::Error> {
                Ok(unsafe { (*GPIOE::ptr()).idr.read().idr4().is_low() })
            }
        }
        #[cfg(feature = "unproven")]
        impl InputPin for PE4<Output<OpenDrain>> {
            type Error = Infallible;
            fn is_high(&self) -> Result<bool, Self::Error> {
                Ok(!self.is_low()?)
            }
            fn is_low(&self) -> Result<bool, Self::Error> {
                Ok(unsafe { (*GPIOE::ptr()).idr.read().idr4().is_low() })
            }
        }
        #[cfg(feature = "unproven")]
        impl<MODE> StatefulOutputPin for PE4<Output<MODE>> {
            fn is_set_high(&self) -> Result<bool, Self::Error> {
                self.is_set_low().map(|b| !b)
            }
            fn is_set_low(&self) -> Result<bool, Self::Error> {
                Ok(unsafe { (*GPIOE::ptr()).odr.read().odr4().is_low() })
            }
        }
        #[cfg(feature = "unproven")]
        impl<MODE> toggleable::Default for PE4<Output<MODE>> {}
        #[doc = "Pin `PE5`"]
        pub struct PE5<MODE> {
            _mode: PhantomData<MODE>,
        }
        impl<MODE> PE5<MODE> {
            #[doc = "Configures `PE5` to serve as alternate function: `AF0`"]
            pub fn into_af0(self, moder: &mut MODER, afr: &mut AFRL) -> PE5<AF0> {
                moder.moder().modify(|_, w| w.moder5().alternate());
                afr.afr().modify(|_, w| w.afrl5().af0());
                PE5 { _mode: PhantomData }
            }
            #[doc = "Configures `PE5` to serve as alternate function: `AF1`"]
            pub fn into_af1(self, moder: &mut MODER, afr: &mut AFRL) -> PE5<AF1> {
                moder.moder().modify(|_, w| w.moder5().alternate());
                afr.afr().modify(|_, w| w.afrl5().af1());
                PE5 { _mode: PhantomData }
            }
            #[doc = "Configures `PE5` to serve as alternate function: `AF2`"]
            pub fn into_af2(self, moder: &mut MODER, afr: &mut AFRL) -> PE5<AF2> {
                moder.moder().modify(|_, w| w.moder5().alternate());
                afr.afr().modify(|_, w| w.afrl5().af2());
                PE5 { _mode: PhantomData }
            }
            #[doc = "Configures `PE5` to serve as alternate function: `AF3`"]
            pub fn into_af3(self, moder: &mut MODER, afr: &mut AFRL) -> PE5<AF3> {
                moder.moder().modify(|_, w| w.moder5().alternate());
                afr.afr().modify(|_, w| w.afrl5().af3());
                PE5 { _mode: PhantomData }
            }
            #[doc = " Configures the pin to operate as a floating input pin"]
            pub fn into_floating_input(
                self,
                moder: &mut MODER,
                pupdr: &mut PUPDR,
            ) -> PE5<Input<Floating>> {
                moder.moder().modify(|_, w| w.moder5().input());
                pupdr.pupdr().modify(|_, w| w.pupdr5().floating());
                PE5 { _mode: PhantomData }
            }
            #[doc = " Configures the pin to operate as a pulled down input pin"]
            pub fn into_pull_down_input(
                self,
                moder: &mut MODER,
                pupdr: &mut PUPDR,
            ) -> PE5<Input<PullDown>> {
                moder.moder().modify(|_, w| w.moder5().input());
                pupdr.pupdr().modify(|_, w| w.pupdr5().pull_down());
                PE5 { _mode: PhantomData }
            }
            #[doc = " Configures the pin to operate as a pulled up input pin"]
            pub fn into_pull_up_input(
                self,
                moder: &mut MODER,
                pupdr: &mut PUPDR,
            ) -> PE5<Input<PullUp>> {
                moder.moder().modify(|_, w| w.moder5().input());
                pupdr.pupdr().modify(|_, w| w.pupdr5().pull_up());
                PE5 { _mode: PhantomData }
            }
            #[doc = " Configures the pin to operate as an open drain output pin"]
            pub fn into_open_drain_output(
                self,
                moder: &mut MODER,
                otyper: &mut OTYPER,
            ) -> PE5<Output<OpenDrain>> {
                moder.moder().modify(|_, w| w.moder5().output());
                otyper.otyper().modify(|_, w| w.ot5().open_drain());
                PE5 { _mode: PhantomData }
            }
            #[doc = " Configures the pin to operate as an push pull output pin"]
            pub fn into_push_pull_output(
                self,
                moder: &mut MODER,
                otyper: &mut OTYPER,
            ) -> PE5<Output<PushPull>> {
                moder.moder().modify(|_, w| w.moder5().output());
                otyper.otyper().modify(|_, w| w.ot5().push_pull());
                PE5 { _mode: PhantomData }
            }
            #[doc = " Configures the pin to operate as analog, with disabled schmitt trigger."]
            #[doc = " This mode is suitable when the pin is connected to the DAC or ADC."]
            pub fn into_analog(self, moder: &mut MODER, pupdr: &mut PUPDR) -> PE5<Analog> {
                moder.moder().modify(|_, w| w.moder5().analog());
                pupdr.pupdr().modify(|_, w| w.pupdr5().floating());
                PE5 { _mode: PhantomData }
            }
        }
        impl PE5<Output<OpenDrain>> {
            #[doc = " Enables / disables the internal pull up"]
            pub fn internal_pull_up(&mut self, pupdr: &mut PUPDR, on: bool) {
                pupdr.pupdr().modify(|_, w| {
                    if on {
                        w.pupdr5().pull_up()
                    } else {
                        w.pupdr5().floating()
                    }
                });
            }
        }
        impl<MODE> PE5<Output<MODE>> {
            #[doc = " Erases the pin number from the type"]
            #[doc = ""]
            #[doc = " This is useful when you want to collect the pins into an array where you"]
            #[doc = " need all the elements to have the same type"]
            pub fn downgrade(self) -> PEx<Output<MODE>> {
                PEx {
                    i: 5,
                    _mode: self._mode,
                }
            }
        }
        impl<MODE> PE5<Input<MODE>> {
            #[doc = " Erases the pin number from the type"]
            #[doc = ""]
            #[doc = " This is useful when you want to collect the pins into an array where you"]
            #[doc = " need all the elements to have the same type"]
            pub fn downgrade(self) -> PEx<Input<MODE>> {
                PEx {
                    i: 5,
                    _mode: self._mode,
                }
            }
        }
        impl<MODE> OutputPin for PE5<Output<MODE>> {
            type Error = Infallible;
            fn set_high(&mut self) -> Result<(), Self::Error> {
                unsafe { (*GPIOE::ptr()).bsrr.write(|w| w.bs5().set()) }
                Ok(())
            }
            fn set_low(&mut self) -> Result<(), Self::Error> {
                unsafe { (*GPIOE::ptr()).bsrr.write(|w| w.br5().reset()) }
                Ok(())
            }
        }
        #[cfg(feature = "unproven")]
        impl<MODE> InputPin for PE5<Input<MODE>> {
            type Error = Infallible;
            fn is_high(&self) -> Result<bool, Self::Error> {
                Ok(!self.is_low()?)
            }
            fn is_low(&self) -> Result<bool, Self::Error> {
                Ok(unsafe { (*GPIOE::ptr()).idr.read().idr5().is_low() })
            }
        }
        #[cfg(feature = "unproven")]
        impl InputPin for PE5<Output<OpenDrain>> {
            type Error = Infallible;
            fn is_high(&self) -> Result<bool, Self::Error> {
                Ok(!self.is_low()?)
            }
            fn is_low(&self) -> Result<bool, Self::Error> {
                Ok(unsafe { (*GPIOE::ptr()).idr.read().idr5().is_low() })
            }
        }
        #[cfg(feature = "unproven")]
        impl<MODE> StatefulOutputPin for PE5<Output<MODE>> {
            fn is_set_high(&self) -> Result<bool, Self::Error> {
                self.is_set_low().map(|b| !b)
            }
            fn is_set_low(&self) -> Result<bool, Self::Error> {
                Ok(unsafe { (*GPIOE::ptr()).odr.read().odr5().is_low() })
            }
        }
        #[cfg(feature = "unproven")]
        impl<MODE> toggleable::Default for PE5<Output<MODE>> {}
        #[doc = "Pin `PE6`"]
        pub struct PE6<MODE> {
            _mode: PhantomData<MODE>,
        }
        impl<MODE> PE6<MODE> {
            #[doc = "Configures `PE6` to serve as alternate function: `AF0`"]
            pub fn into_af0(self, moder: &mut MODER, afr: &mut AFRL) -> PE6<AF0> {
                moder.moder().modify(|_, w| w.moder6().alternate());
                afr.afr().modify(|_, w| w.afrl6().af0());
                PE6 { _mode: PhantomData }
            }
            #[doc = "Configures `PE6` to serve as alternate function: `AF1`"]
            pub fn into_af1(self, moder: &mut MODER, afr: &mut AFRL) -> PE6<AF1> {
                moder.moder().modify(|_, w| w.moder6().alternate());
                afr.afr().modify(|_, w| w.afrl6().af1());
                PE6 { _mode: PhantomData }
            }
            #[doc = " Configures the pin to operate as a floating input pin"]
            pub fn into_floating_input(
                self,
                moder: &mut MODER,
                pupdr: &mut PUPDR,
            ) -> PE6<Input<Floating>> {
                moder.moder().modify(|_, w| w.moder6().input());
                pupdr.pupdr().modify(|_, w| w.pupdr6().floating());
                PE6 { _mode: PhantomData }
            }
            #[doc = " Configures the pin to operate as a pulled down input pin"]
            pub fn into_pull_down_input(
                self,
                moder: &mut MODER,
                pupdr: &mut PUPDR,
            ) -> PE6<Input<PullDown>> {
                moder.moder().modify(|_, w| w.moder6().input());
                pupdr.pupdr().modify(|_, w| w.pupdr6().pull_down());
                PE6 { _mode: PhantomData }
            }
            #[doc = " Configures the pin to operate as a pulled up input pin"]
            pub fn into_pull_up_input(
                self,
                moder: &mut MODER,
                pupdr: &mut PUPDR,
            ) -> PE6<Input<PullUp>> {
                moder.moder().modify(|_, w| w.moder6().input());
                pupdr.pupdr().modify(|_, w| w.pupdr6().pull_up());
                PE6 { _mode: PhantomData }
            }
            #[doc = " Configures the pin to operate as an open drain output pin"]
            pub fn into_open_drain_output(
                self,
                moder: &mut MODER,
                otyper: &mut OTYPER,
            ) -> PE6<Output<OpenDrain>> {
                moder.moder().modify(|_, w| w.moder6().output());
                otyper.otyper().modify(|_, w| w.ot6().open_drain());
                PE6 { _mode: PhantomData }
            }
            #[doc = " Configures the pin to operate as an push pull output pin"]
            pub fn into_push_pull_output(
                self,
                moder: &mut MODER,
                otyper: &mut OTYPER,
            ) -> PE6<Output<PushPull>> {
                moder.moder().modify(|_, w| w.moder6().output());
                otyper.otyper().modify(|_, w| w.ot6().push_pull());
                PE6 { _mode: PhantomData }
            }
            #[doc = " Configures the pin to operate as analog, with disabled schmitt trigger."]
            #[doc = " This mode is suitable when the pin is connected to the DAC or ADC."]
            pub fn into_analog(self, moder: &mut MODER, pupdr: &mut PUPDR) -> PE6<Analog> {
                moder.moder().modify(|_, w| w.moder6().analog());
                pupdr.pupdr().modify(|_, w| w.pupdr6().floating());
                PE6 { _mode: PhantomData }
            }
        }
        impl PE6<Output<OpenDrain>> {
            #[doc = " Enables / disables the internal pull up"]
            pub fn internal_pull_up(&mut self, pupdr: &mut PUPDR, on: bool) {
                pupdr.pupdr().modify(|_, w| {
                    if on {
                        w.pupdr6().pull_up()
                    } else {
                        w.pupdr6().floating()
                    }
                });
            }
        }
        impl<MODE> PE6<Output<MODE>> {
            #[doc = " Erases the pin number from the type"]
            #[doc = ""]
            #[doc = " This is useful when you want to collect the pins into an array where you"]
            #[doc = " need all the elements to have the same type"]
            pub fn downgrade(self) -> PEx<Output<MODE>> {
                PEx {
                    i: 6,
                    _mode: self._mode,
                }
            }
        }
        impl<MODE> PE6<Input<MODE>> {
            #[doc = " Erases the pin number from the type"]
            #[doc = ""]
            #[doc = " This is useful when you want to collect the pins into an array where you"]
            #[doc = " need all the elements to have the same type"]
            pub fn downgrade(self) -> PEx<Input<MODE>> {
                PEx {
                    i: 6,
                    _mode: self._mode,
                }
            }
        }
        impl<MODE> OutputPin for PE6<Output<MODE>> {
            type Error = Infallible;
            fn set_high(&mut self) -> Result<(), Self::Error> {
                unsafe { (*GPIOE::ptr()).bsrr.write(|w| w.bs6().set()) }
                Ok(())
            }
            fn set_low(&mut self) -> Result<(), Self::Error> {
                unsafe { (*GPIOE::ptr()).bsrr.write(|w| w.br6().reset()) }
                Ok(())
            }
        }
        #[cfg(feature = "unproven")]
        impl<MODE> InputPin for PE6<Input<MODE>> {
            type Error = Infallible;
            fn is_high(&self) -> Result<bool, Self::Error> {
                Ok(!self.is_low()?)
            }
            fn is_low(&self) -> Result<bool, Self::Error> {
                Ok(unsafe { (*GPIOE::ptr()).idr.read().idr6().is_low() })
            }
        }
        #[cfg(feature = "unproven")]
        impl InputPin for PE6<Output<OpenDrain>> {
            type Error = Infallible;
            fn is_high(&self) -> Result<bool, Self::Error> {
                Ok(!self.is_low()?)
            }
            fn is_low(&self) -> Result<bool, Self::Error> {
                Ok(unsafe { (*GPIOE::ptr()).idr.read().idr6().is_low() })
            }
        }
        #[cfg(feature = "unproven")]
        impl<MODE> StatefulOutputPin for PE6<Output<MODE>> {
            fn is_set_high(&self) -> Result<bool, Self::Error> {
                self.is_set_low().map(|b| !b)
            }
            fn is_set_low(&self) -> Result<bool, Self::Error> {
                Ok(unsafe { (*GPIOE::ptr()).odr.read().odr6().is_low() })
            }
        }
        #[cfg(feature = "unproven")]
        impl<MODE> toggleable::Default for PE6<Output<MODE>> {}
        #[doc = "Pin `PE7`"]
        pub struct PE7<MODE> {
            _mode: PhantomData<MODE>,
        }
        impl<MODE> PE7<MODE> {
            #[doc = "Configures `PE7` to serve as alternate function: `AF1`"]
            pub fn into_af1(self, moder: &mut MODER, afr: &mut AFRL) -> PE7<AF1> {
                moder.moder().modify(|_, w| w.moder7().alternate());
                afr.afr().modify(|_, w| w.afrl7().af1());
                PE7 { _mode: PhantomData }
            }
            #[doc = "Configures `PE7` to serve as alternate function: `AF2`"]
            pub fn into_af2(self, moder: &mut MODER, afr: &mut AFRL) -> PE7<AF2> {
                moder.moder().modify(|_, w| w.moder7().alternate());
                afr.afr().modify(|_, w| w.afrl7().af2());
                PE7 { _mode: PhantomData }
            }
            #[doc = " Configures the pin to operate as a floating input pin"]
            pub fn into_floating_input(
                self,
                moder: &mut MODER,
                pupdr: &mut PUPDR,
            ) -> PE7<Input<Floating>> {
                moder.moder().modify(|_, w| w.moder7().input());
                pupdr.pupdr().modify(|_, w| w.pupdr7().floating());
                PE7 { _mode: PhantomData }
            }
            #[doc = " Configures the pin to operate as a pulled down input pin"]
            pub fn into_pull_down_input(
                self,
                moder: &mut MODER,
                pupdr: &mut PUPDR,
            ) -> PE7<Input<PullDown>> {
                moder.moder().modify(|_, w| w.moder7().input());
                pupdr.pupdr().modify(|_, w| w.pupdr7().pull_down());
                PE7 { _mode: PhantomData }
            }
            #[doc = " Configures the pin to operate as a pulled up input pin"]
            pub fn into_pull_up_input(
                self,
                moder: &mut MODER,
                pupdr: &mut PUPDR,
            ) -> PE7<Input<PullUp>> {
                moder.moder().modify(|_, w| w.moder7().input());
                pupdr.pupdr().modify(|_, w| w.pupdr7().pull_up());
                PE7 { _mode: PhantomData }
            }
            #[doc = " Configures the pin to operate as an open drain output pin"]
            pub fn into_open_drain_output(
                self,
                moder: &mut MODER,
                otyper: &mut OTYPER,
            ) -> PE7<Output<OpenDrain>> {
                moder.moder().modify(|_, w| w.moder7().output());
                otyper.otyper().modify(|_, w| w.ot7().open_drain());
                PE7 { _mode: PhantomData }
            }
            #[doc = " Configures the pin to operate as an push pull output pin"]
            pub fn into_push_pull_output(
                self,
                moder: &mut MODER,
                otyper: &mut OTYPER,
            ) -> PE7<Output<PushPull>> {
                moder.moder().modify(|_, w| w.moder7().output());
                otyper.otyper().modify(|_, w| w.ot7().push_pull());
                PE7 { _mode: PhantomData }
            }
            #[doc = " Configures the pin to operate as analog, with disabled schmitt trigger."]
            #[doc = " This mode is suitable when the pin is connected to the DAC or ADC."]
            pub fn into_analog(self, moder: &mut MODER, pupdr: &mut PUPDR) -> PE7<Analog> {
                moder.moder().modify(|_, w| w.moder7().analog());
                pupdr.pupdr().modify(|_, w| w.pupdr7().floating());
                PE7 { _mode: PhantomData }
            }
        }
        impl PE7<Output<OpenDrain>> {
            #[doc = " Enables / disables the internal pull up"]
            pub fn internal_pull_up(&mut self, pupdr: &mut PUPDR, on: bool) {
                pupdr.pupdr().modify(|_, w| {
                    if on {
                        w.pupdr7().pull_up()
                    } else {
                        w.pupdr7().floating()
                    }
                });
            }
        }
        impl<MODE> PE7<Output<MODE>> {
            #[doc = " Erases the pin number from the type"]
            #[doc = ""]
            #[doc = " This is useful when you want to collect the pins into an array where you"]
            #[doc = " need all the elements to have the same type"]
            pub fn downgrade(self) -> PEx<Output<MODE>> {
                PEx {
                    i: 7,
                    _mode: self._mode,
                }
            }
        }
        impl<MODE> PE7<Input<MODE>> {
            #[doc = " Erases the pin number from the type"]
            #[doc = ""]
            #[doc = " This is useful when you want to collect the pins into an array where you"]
            #[doc = " need all the elements to have the same type"]
            pub fn downgrade(self) -> PEx<Input<MODE>> {
                PEx {
                    i: 7,
                    _mode: self._mode,
                }
            }
        }
        impl<MODE> OutputPin for PE7<Output<MODE>> {
            type Error = Infallible;
            fn set_high(&mut self) -> Result<(), Self::Error> {
                unsafe { (*GPIOE::ptr()).bsrr.write(|w| w.bs7().set()) }
                Ok(())
            }
            fn set_low(&mut self) -> Result<(), Self::Error> {
                unsafe { (*GPIOE::ptr()).bsrr.write(|w| w.br7().reset()) }
                Ok(())
            }
        }
        #[cfg(feature = "unproven")]
        impl<MODE> InputPin for PE7<Input<MODE>> {
            type Error = Infallible;
            fn is_high(&self) -> Result<bool, Self::Error> {
                Ok(!self.is_low()?)
            }
            fn is_low(&self) -> Result<bool, Self::Error> {
                Ok(unsafe { (*GPIOE::ptr()).idr.read().idr7().is_low() })
            }
        }
        #[cfg(feature = "unproven")]
        impl InputPin for PE7<Output<OpenDrain>> {
            type Error = Infallible;
            fn is_high(&self) -> Result<bool, Self::Error> {
                Ok(!self.is_low()?)
            }
            fn is_low(&self) -> Result<bool, Self::Error> {
                Ok(unsafe { (*GPIOE::ptr()).idr.read().idr7().is_low() })
            }
        }
        #[cfg(feature = "unproven")]
        impl<MODE> StatefulOutputPin for PE7<Output<MODE>> {
            fn is_set_high(&self) -> Result<bool, Self::Error> {
                self.is_set_low().map(|b| !b)
            }
            fn is_set_low(&self) -> Result<bool, Self::Error> {
                Ok(unsafe { (*GPIOE::ptr()).odr.read().odr7().is_low() })
            }
        }
        #[cfg(feature = "unproven")]
        impl<MODE> toggleable::Default for PE7<Output<MODE>> {}
        #[doc = "Pin `PE8`"]
        pub struct PE8<MODE> {
            _mode: PhantomData<MODE>,
        }
        impl<MODE> PE8<MODE> {
            #[doc = "Configures `PE8` to serve as alternate function: `AF1`"]
            pub fn into_af1(self, moder: &mut MODER, afr: &mut AFRH) -> PE8<AF1> {
                moder.moder().modify(|_, w| w.moder8().alternate());
                afr.afr().modify(|_, w| w.afrh8().af1());
                PE8 { _mode: PhantomData }
            }
            #[doc = "Configures `PE8` to serve as alternate function: `AF2`"]
            pub fn into_af2(self, moder: &mut MODER, afr: &mut AFRH) -> PE8<AF2> {
                moder.moder().modify(|_, w| w.moder8().alternate());
                afr.afr().modify(|_, w| w.afrh8().af2());
                PE8 { _mode: PhantomData }
            }
            #[doc = " Configures the pin to operate as a floating input pin"]
            pub fn into_floating_input(
                self,
                moder: &mut MODER,
                pupdr: &mut PUPDR,
            ) -> PE8<Input<Floating>> {
                moder.moder().modify(|_, w| w.moder8().input());
                pupdr.pupdr().modify(|_, w| w.pupdr8().floating());
                PE8 { _mode: PhantomData }
            }
            #[doc = " Configures the pin to operate as a pulled down input pin"]
            pub fn into_pull_down_input(
                self,
                moder: &mut MODER,
                pupdr: &mut PUPDR,
            ) -> PE8<Input<PullDown>> {
                moder.moder().modify(|_, w| w.moder8().input());
                pupdr.pupdr().modify(|_, w| w.pupdr8().pull_down());
                PE8 { _mode: PhantomData }
            }
            #[doc = " Configures the pin to operate as a pulled up input pin"]
            pub fn into_pull_up_input(
                self,
                moder: &mut MODER,
                pupdr: &mut PUPDR,
            ) -> PE8<Input<PullUp>> {
                moder.moder().modify(|_, w| w.moder8().input());
                pupdr.pupdr().modify(|_, w| w.pupdr8().pull_up());
                PE8 { _mode: PhantomData }
            }
            #[doc = " Configures the pin to operate as an open drain output pin"]
            pub fn into_open_drain_output(
                self,
                moder: &mut MODER,
                otyper: &mut OTYPER,
            ) -> PE8<Output<OpenDrain>> {
                moder.moder().modify(|_, w| w.moder8().output());
                otyper.otyper().modify(|_, w| w.ot8().open_drain());
                PE8 { _mode: PhantomData }
            }
            #[doc = " Configures the pin to operate as an push pull output pin"]
            pub fn into_push_pull_output(
                self,
                moder: &mut MODER,
                otyper: &mut OTYPER,
            ) -> PE8<Output<PushPull>> {
                moder.moder().modify(|_, w| w.moder8().output());
                otyper.otyper().modify(|_, w| w.ot8().push_pull());
                PE8 { _mode: PhantomData }
            }
            #[doc = " Configures the pin to operate as analog, with disabled schmitt trigger."]
            #[doc = " This mode is suitable when the pin is connected to the DAC or ADC."]
            pub fn into_analog(self, moder: &mut MODER, pupdr: &mut PUPDR) -> PE8<Analog> {
                moder.moder().modify(|_, w| w.moder8().analog());
                pupdr.pupdr().modify(|_, w| w.pupdr8().floating());
                PE8 { _mode: PhantomData }
            }
        }
        impl PE8<Output<OpenDrain>> {
            #[doc = " Enables / disables the internal pull up"]
            pub fn internal_pull_up(&mut self, pupdr: &mut PUPDR, on: bool) {
                pupdr.pupdr().modify(|_, w| {
                    if on {
                        w.pupdr8().pull_up()
                    } else {
                        w.pupdr8().floating()
                    }
                });
            }
        }
        impl<MODE> PE8<Output<MODE>> {
            #[doc = " Erases the pin number from the type"]
            #[doc = ""]
            #[doc = " This is useful when you want to collect the pins into an array where you"]
            #[doc = " need all the elements to have the same type"]
            pub fn downgrade(self) -> PEx<Output<MODE>> {
                PEx {
                    i: 8,
                    _mode: self._mode,
                }
            }
        }
        impl<MODE> PE8<Input<MODE>> {
            #[doc = " Erases the pin number from the type"]
            #[doc = ""]
            #[doc = " This is useful when you want to collect the pins into an array where you"]
            #[doc = " need all the elements to have the same type"]
            pub fn downgrade(self) -> PEx<Input<MODE>> {
                PEx {
                    i: 8,
                    _mode: self._mode,
                }
            }
        }
        impl<MODE> OutputPin for PE8<Output<MODE>> {
            type Error = Infallible;
            fn set_high(&mut self) -> Result<(), Self::Error> {
                unsafe { (*GPIOE::ptr()).bsrr.write(|w| w.bs8().set()) }
                Ok(())
            }
            fn set_low(&mut self) -> Result<(), Self::Error> {
                unsafe { (*GPIOE::ptr()).bsrr.write(|w| w.br8().reset()) }
                Ok(())
            }
        }
        #[cfg(feature = "unproven")]
        impl<MODE> InputPin for PE8<Input<MODE>> {
            type Error = Infallible;
            fn is_high(&self) -> Result<bool, Self::Error> {
                Ok(!self.is_low()?)
            }
            fn is_low(&self) -> Result<bool, Self::Error> {
                Ok(unsafe { (*GPIOE::ptr()).idr.read().idr8().is_low() })
            }
        }
        #[cfg(feature = "unproven")]
        impl InputPin for PE8<Output<OpenDrain>> {
            type Error = Infallible;
            fn is_high(&self) -> Result<bool, Self::Error> {
                Ok(!self.is_low()?)
            }
            fn is_low(&self) -> Result<bool, Self::Error> {
                Ok(unsafe { (*GPIOE::ptr()).idr.read().idr8().is_low() })
            }
        }
        #[cfg(feature = "unproven")]
        impl<MODE> StatefulOutputPin for PE8<Output<MODE>> {
            fn is_set_high(&self) -> Result<bool, Self::Error> {
                self.is_set_low().map(|b| !b)
            }
            fn is_set_low(&self) -> Result<bool, Self::Error> {
                Ok(unsafe { (*GPIOE::ptr()).odr.read().odr8().is_low() })
            }
        }
        #[cfg(feature = "unproven")]
        impl<MODE> toggleable::Default for PE8<Output<MODE>> {}
        #[doc = "Pin `PE9`"]
        pub struct PE9<MODE> {
            _mode: PhantomData<MODE>,
        }
        impl<MODE> PE9<MODE> {
            #[doc = "Configures `PE9` to serve as alternate function: `AF1`"]
            pub fn into_af1(self, moder: &mut MODER, afr: &mut AFRH) -> PE9<AF1> {
                moder.moder().modify(|_, w| w.moder9().alternate());
                afr.afr().modify(|_, w| w.afrh9().af1());
                PE9 { _mode: PhantomData }
            }
            #[doc = "Configures `PE9` to serve as alternate function: `AF2`"]
            pub fn into_af2(self, moder: &mut MODER, afr: &mut AFRH) -> PE9<AF2> {
                moder.moder().modify(|_, w| w.moder9().alternate());
                afr.afr().modify(|_, w| w.afrh9().af2());
                PE9 { _mode: PhantomData }
            }
            #[doc = " Configures the pin to operate as a floating input pin"]
            pub fn into_floating_input(
                self,
                moder: &mut MODER,
                pupdr: &mut PUPDR,
            ) -> PE9<Input<Floating>> {
                moder.moder().modify(|_, w| w.moder9().input());
                pupdr.pupdr().modify(|_, w| w.pupdr9().floating());
                PE9 { _mode: PhantomData }
            }
            #[doc = " Configures the pin to operate as a pulled down input pin"]
            pub fn into_pull_down_input(
                self,
                moder: &mut MODER,
                pupdr: &mut PUPDR,
            ) -> PE9<Input<PullDown>> {
                moder.moder().modify(|_, w| w.moder9().input());
                pupdr.pupdr().modify(|_, w| w.pupdr9().pull_down());
                PE9 { _mode: PhantomData }
            }
            #[doc = " Configures the pin to operate as a pulled up input pin"]
            pub fn into_pull_up_input(
                self,
                moder: &mut MODER,
                pupdr: &mut PUPDR,
            ) -> PE9<Input<PullUp>> {
                moder.moder().modify(|_, w| w.moder9().input());
                pupdr.pupdr().modify(|_, w| w.pupdr9().pull_up());
                PE9 { _mode: PhantomData }
            }
            #[doc = " Configures the pin to operate as an open drain output pin"]
            pub fn into_open_drain_output(
                self,
                moder: &mut MODER,
                otyper: &mut OTYPER,
            ) -> PE9<Output<OpenDrain>> {
                moder.moder().modify(|_, w| w.moder9().output());
                otyper.otyper().modify(|_, w| w.ot9().open_drain());
                PE9 { _mode: PhantomData }
            }
            #[doc = " Configures the pin to operate as an push pull output pin"]
            pub fn into_push_pull_output(
                self,
                moder: &mut MODER,
                otyper: &mut OTYPER,
            ) -> PE9<Output<PushPull>> {
                moder.moder().modify(|_, w| w.moder9().output());
                otyper.otyper().modify(|_, w| w.ot9().push_pull());
                PE9 { _mode: PhantomData }
            }
            #[doc = " Configures the pin to operate as analog, with disabled schmitt trigger."]
            #[doc = " This mode is suitable when the pin is connected to the DAC or ADC."]
            pub fn into_analog(self, moder: &mut MODER, pupdr: &mut PUPDR) -> PE9<Analog> {
                moder.moder().modify(|_, w| w.moder9().analog());
                pupdr.pupdr().modify(|_, w| w.pupdr9().floating());
                PE9 { _mode: PhantomData }
            }
        }
        impl PE9<Output<OpenDrain>> {
            #[doc = " Enables / disables the internal pull up"]
            pub fn internal_pull_up(&mut self, pupdr: &mut PUPDR, on: bool) {
                pupdr.pupdr().modify(|_, w| {
                    if on {
                        w.pupdr9().pull_up()
                    } else {
                        w.pupdr9().floating()
                    }
                });
            }
        }
        impl<MODE> PE9<Output<MODE>> {
            #[doc = " Erases the pin number from the type"]
            #[doc = ""]
            #[doc = " This is useful when you want to collect the pins into an array where you"]
            #[doc = " need all the elements to have the same type"]
            pub fn downgrade(self) -> PEx<Output<MODE>> {
                PEx {
                    i: 9,
                    _mode: self._mode,
                }
            }
        }
        impl<MODE> PE9<Input<MODE>> {
            #[doc = " Erases the pin number from the type"]
            #[doc = ""]
            #[doc = " This is useful when you want to collect the pins into an array where you"]
            #[doc = " need all the elements to have the same type"]
            pub fn downgrade(self) -> PEx<Input<MODE>> {
                PEx {
                    i: 9,
                    _mode: self._mode,
                }
            }
        }
        impl<MODE> OutputPin for PE9<Output<MODE>> {
            type Error = Infallible;
            fn set_high(&mut self) -> Result<(), Self::Error> {
                unsafe { (*GPIOE::ptr()).bsrr.write(|w| w.bs9().set()) }
                Ok(())
            }
            fn set_low(&mut self) -> Result<(), Self::Error> {
                unsafe { (*GPIOE::ptr()).bsrr.write(|w| w.br9().reset()) }
                Ok(())
            }
        }
        #[cfg(feature = "unproven")]
        impl<MODE> InputPin for PE9<Input<MODE>> {
            type Error = Infallible;
            fn is_high(&self) -> Result<bool, Self::Error> {
                Ok(!self.is_low()?)
            }
            fn is_low(&self) -> Result<bool, Self::Error> {
                Ok(unsafe { (*GPIOE::ptr()).idr.read().idr9().is_low() })
            }
        }
        #[cfg(feature = "unproven")]
        impl InputPin for PE9<Output<OpenDrain>> {
            type Error = Infallible;
            fn is_high(&self) -> Result<bool, Self::Error> {
                Ok(!self.is_low()?)
            }
            fn is_low(&self) -> Result<bool, Self::Error> {
                Ok(unsafe { (*GPIOE::ptr()).idr.read().idr9().is_low() })
            }
        }
        #[cfg(feature = "unproven")]
        impl<MODE> StatefulOutputPin for PE9<Output<MODE>> {
            fn is_set_high(&self) -> Result<bool, Self::Error> {
                self.is_set_low().map(|b| !b)
            }
            fn is_set_low(&self) -> Result<bool, Self::Error> {
                Ok(unsafe { (*GPIOE::ptr()).odr.read().odr9().is_low() })
            }
        }
        #[cfg(feature = "unproven")]
        impl<MODE> toggleable::Default for PE9<Output<MODE>> {}
        #[doc = "Pin `PE10`"]
        pub struct PE10<MODE> {
            _mode: PhantomData<MODE>,
        }
        impl<MODE> PE10<MODE> {
            #[doc = "Configures `PE10` to serve as alternate function: `AF1`"]
            pub fn into_af1(self, moder: &mut MODER, afr: &mut AFRH) -> PE10<AF1> {
                moder.moder().modify(|_, w| w.moder10().alternate());
                afr.afr().modify(|_, w| w.afrh10().af1());
                PE10 { _mode: PhantomData }
            }
            #[doc = "Configures `PE10` to serve as alternate function: `AF2`"]
            pub fn into_af2(self, moder: &mut MODER, afr: &mut AFRH) -> PE10<AF2> {
                moder.moder().modify(|_, w| w.moder10().alternate());
                afr.afr().modify(|_, w| w.afrh10().af2());
                PE10 { _mode: PhantomData }
            }
            #[doc = " Configures the pin to operate as a floating input pin"]
            pub fn into_floating_input(
                self,
                moder: &mut MODER,
                pupdr: &mut PUPDR,
            ) -> PE10<Input<Floating>> {
                moder.moder().modify(|_, w| w.moder10().input());
                pupdr.pupdr().modify(|_, w| w.pupdr10().floating());
                PE10 { _mode: PhantomData }
            }
            #[doc = " Configures the pin to operate as a pulled down input pin"]
            pub fn into_pull_down_input(
                self,
                moder: &mut MODER,
                pupdr: &mut PUPDR,
            ) -> PE10<Input<PullDown>> {
                moder.moder().modify(|_, w| w.moder10().input());
                pupdr.pupdr().modify(|_, w| w.pupdr10().pull_down());
                PE10 { _mode: PhantomData }
            }
            #[doc = " Configures the pin to operate as a pulled up input pin"]
            pub fn into_pull_up_input(
                self,
                moder: &mut MODER,
                pupdr: &mut PUPDR,
            ) -> PE10<Input<PullUp>> {
                moder.moder().modify(|_, w| w.moder10().input());
                pupdr.pupdr().modify(|_, w| w.pupdr10().pull_up());
                PE10 { _mode: PhantomData }
            }
            #[doc = " Configures the pin to operate as an open drain output pin"]
            pub fn into_open_drain_output(
                self,
                moder: &mut MODER,
                otyper: &mut OTYPER,
            ) -> PE10<Output<OpenDrain>> {
                moder.moder().modify(|_, w| w.moder10().output());
                otyper.otyper().modify(|_, w| w.ot10().open_drain());
                PE10 { _mode: PhantomData }
            }
            #[doc = " Configures the pin to operate as an push pull output pin"]
            pub fn into_push_pull_output(
                self,
                moder: &mut MODER,
                otyper: &mut OTYPER,
            ) -> PE10<Output<PushPull>> {
                moder.moder().modify(|_, w| w.moder10().output());
                otyper.otyper().modify(|_, w| w.ot10().push_pull());
                PE10 { _mode: PhantomData }
            }
            #[doc = " Configures the pin to operate as analog, with disabled schmitt trigger."]
            #[doc = " This mode is suitable when the pin is connected to the DAC or ADC."]
            pub fn into_analog(self, moder: &mut MODER, pupdr: &mut PUPDR) -> PE10<Analog> {
                moder.moder().modify(|_, w| w.moder10().analog());
                pupdr.pupdr().modify(|_, w| w.pupdr10().floating());
                PE10 { _mode: PhantomData }
            }
        }
        impl PE10<Output<OpenDrain>> {
            #[doc = " Enables / disables the internal pull up"]
            pub fn internal_pull_up(&mut self, pupdr: &mut PUPDR, on: bool) {
                pupdr.pupdr().modify(|_, w| {
                    if on {
                        w.pupdr10().pull_up()
                    } else {
                        w.pupdr10().floating()
                    }
                });
            }
        }
        impl<MODE> PE10<Output<MODE>> {
            #[doc = " Erases the pin number from the type"]
            #[doc = ""]
            #[doc = " This is useful when you want to collect the pins into an array where you"]
            #[doc = " need all the elements to have the same type"]
            pub fn downgrade(self) -> PEx<Output<MODE>> {
                PEx {
                    i: 10,
                    _mode: self._mode,
                }
            }
        }
        impl<MODE> PE10<Input<MODE>> {
            #[doc = " Erases the pin number from the type"]
            #[doc = ""]
            #[doc = " This is useful when you want to collect the pins into an array where you"]
            #[doc = " need all the elements to have the same type"]
            pub fn downgrade(self) -> PEx<Input<MODE>> {
                PEx {
                    i: 10,
                    _mode: self._mode,
                }
            }
        }
        impl<MODE> OutputPin for PE10<Output<MODE>> {
            type Error = Infallible;
            fn set_high(&mut self) -> Result<(), Self::Error> {
                unsafe { (*GPIOE::ptr()).bsrr.write(|w| w.bs10().set()) }
                Ok(())
            }
            fn set_low(&mut self) -> Result<(), Self::Error> {
                unsafe { (*GPIOE::ptr()).bsrr.write(|w| w.br10().reset()) }
                Ok(())
            }
        }
        #[cfg(feature = "unproven")]
        impl<MODE> InputPin for PE10<Input<MODE>> {
            type Error = Infallible;
            fn is_high(&self) -> Result<bool, Self::Error> {
                Ok(!self.is_low()?)
            }
            fn is_low(&self) -> Result<bool, Self::Error> {
                Ok(unsafe { (*GPIOE::ptr()).idr.read().idr10().is_low() })
            }
        }
        #[cfg(feature = "unproven")]
        impl InputPin for PE10<Output<OpenDrain>> {
            type Error = Infallible;
            fn is_high(&self) -> Result<bool, Self::Error> {
                Ok(!self.is_low()?)
            }
            fn is_low(&self) -> Result<bool, Self::Error> {
                Ok(unsafe { (*GPIOE::ptr()).idr.read().idr10().is_low() })
            }
        }
        #[cfg(feature = "unproven")]
        impl<MODE> StatefulOutputPin for PE10<Output<MODE>> {
            fn is_set_high(&self) -> Result<bool, Self::Error> {
                self.is_set_low().map(|b| !b)
            }
            fn is_set_low(&self) -> Result<bool, Self::Error> {
                Ok(unsafe { (*GPIOE::ptr()).odr.read().odr10().is_low() })
            }
        }
        #[cfg(feature = "unproven")]
        impl<MODE> toggleable::Default for PE10<Output<MODE>> {}
        #[doc = "Pin `PE11`"]
        pub struct PE11<MODE> {
            _mode: PhantomData<MODE>,
        }
        impl<MODE> PE11<MODE> {
            #[doc = "Configures `PE11` to serve as alternate function: `AF1`"]
            pub fn into_af1(self, moder: &mut MODER, afr: &mut AFRH) -> PE11<AF1> {
                moder.moder().modify(|_, w| w.moder11().alternate());
                afr.afr().modify(|_, w| w.afrh11().af1());
                PE11 { _mode: PhantomData }
            }
            #[doc = "Configures `PE11` to serve as alternate function: `AF2`"]
            pub fn into_af2(self, moder: &mut MODER, afr: &mut AFRH) -> PE11<AF2> {
                moder.moder().modify(|_, w| w.moder11().alternate());
                afr.afr().modify(|_, w| w.afrh11().af2());
                PE11 { _mode: PhantomData }
            }
            #[doc = " Configures the pin to operate as a floating input pin"]
            pub fn into_floating_input(
                self,
                moder: &mut MODER,
                pupdr: &mut PUPDR,
            ) -> PE11<Input<Floating>> {
                moder.moder().modify(|_, w| w.moder11().input());
                pupdr.pupdr().modify(|_, w| w.pupdr11().floating());
                PE11 { _mode: PhantomData }
            }
            #[doc = " Configures the pin to operate as a pulled down input pin"]
            pub fn into_pull_down_input(
                self,
                moder: &mut MODER,
                pupdr: &mut PUPDR,
            ) -> PE11<Input<PullDown>> {
                moder.moder().modify(|_, w| w.moder11().input());
                pupdr.pupdr().modify(|_, w| w.pupdr11().pull_down());
                PE11 { _mode: PhantomData }
            }
            #[doc = " Configures the pin to operate as a pulled up input pin"]
            pub fn into_pull_up_input(
                self,
                moder: &mut MODER,
                pupdr: &mut PUPDR,
            ) -> PE11<Input<PullUp>> {
                moder.moder().modify(|_, w| w.moder11().input());
                pupdr.pupdr().modify(|_, w| w.pupdr11().pull_up());
                PE11 { _mode: PhantomData }
            }
            #[doc = " Configures the pin to operate as an open drain output pin"]
            pub fn into_open_drain_output(
                self,
                moder: &mut MODER,
                otyper: &mut OTYPER,
            ) -> PE11<Output<OpenDrain>> {
                moder.moder().modify(|_, w| w.moder11().output());
                otyper.otyper().modify(|_, w| w.ot11().open_drain());
                PE11 { _mode: PhantomData }
            }
            #[doc = " Configures the pin to operate as an push pull output pin"]
            pub fn into_push_pull_output(
                self,
                moder: &mut MODER,
                otyper: &mut OTYPER,
            ) -> PE11<Output<PushPull>> {
                moder.moder().modify(|_, w| w.moder11().output());
                otyper.otyper().modify(|_, w| w.ot11().push_pull());
                PE11 { _mode: PhantomData }
            }
            #[doc = " Configures the pin to operate as analog, with disabled schmitt trigger."]
            #[doc = " This mode is suitable when the pin is connected to the DAC or ADC."]
            pub fn into_analog(self, moder: &mut MODER, pupdr: &mut PUPDR) -> PE11<Analog> {
                moder.moder().modify(|_, w| w.moder11().analog());
                pupdr.pupdr().modify(|_, w| w.pupdr11().floating());
                PE11 { _mode: PhantomData }
            }
        }
        impl PE11<Output<OpenDrain>> {
            #[doc = " Enables / disables the internal pull up"]
            pub fn internal_pull_up(&mut self, pupdr: &mut PUPDR, on: bool) {
                pupdr.pupdr().modify(|_, w| {
                    if on {
                        w.pupdr11().pull_up()
                    } else {
                        w.pupdr11().floating()
                    }
                });
            }
        }
        impl<MODE> PE11<Output<MODE>> {
            #[doc = " Erases the pin number from the type"]
            #[doc = ""]
            #[doc = " This is useful when you want to collect the pins into an array where you"]
            #[doc = " need all the elements to have the same type"]
            pub fn downgrade(self) -> PEx<Output<MODE>> {
                PEx {
                    i: 11,
                    _mode: self._mode,
                }
            }
        }
        impl<MODE> PE11<Input<MODE>> {
            #[doc = " Erases the pin number from the type"]
            #[doc = ""]
            #[doc = " This is useful when you want to collect the pins into an array where you"]
            #[doc = " need all the elements to have the same type"]
            pub fn downgrade(self) -> PEx<Input<MODE>> {
                PEx {
                    i: 11,
                    _mode: self._mode,
                }
            }
        }
        impl<MODE> OutputPin for PE11<Output<MODE>> {
            type Error = Infallible;
            fn set_high(&mut self) -> Result<(), Self::Error> {
                unsafe { (*GPIOE::ptr()).bsrr.write(|w| w.bs11().set()) }
                Ok(())
            }
            fn set_low(&mut self) -> Result<(), Self::Error> {
                unsafe { (*GPIOE::ptr()).bsrr.write(|w| w.br11().reset()) }
                Ok(())
            }
        }
        #[cfg(feature = "unproven")]
        impl<MODE> InputPin for PE11<Input<MODE>> {
            type Error = Infallible;
            fn is_high(&self) -> Result<bool, Self::Error> {
                Ok(!self.is_low()?)
            }
            fn is_low(&self) -> Result<bool, Self::Error> {
                Ok(unsafe { (*GPIOE::ptr()).idr.read().idr11().is_low() })
            }
        }
        #[cfg(feature = "unproven")]
        impl InputPin for PE11<Output<OpenDrain>> {
            type Error = Infallible;
            fn is_high(&self) -> Result<bool, Self::Error> {
                Ok(!self.is_low()?)
            }
            fn is_low(&self) -> Result<bool, Self::Error> {
                Ok(unsafe { (*GPIOE::ptr()).idr.read().idr11().is_low() })
            }
        }
        #[cfg(feature = "unproven")]
        impl<MODE> StatefulOutputPin for PE11<Output<MODE>> {
            fn is_set_high(&self) -> Result<bool, Self::Error> {
                self.is_set_low().map(|b| !b)
            }
            fn is_set_low(&self) -> Result<bool, Self::Error> {
                Ok(unsafe { (*GPIOE::ptr()).odr.read().odr11().is_low() })
            }
        }
        #[cfg(feature = "unproven")]
        impl<MODE> toggleable::Default for PE11<Output<MODE>> {}
        #[doc = "Pin `PE12`"]
        pub struct PE12<MODE> {
            _mode: PhantomData<MODE>,
        }
        impl<MODE> PE12<MODE> {
            #[doc = "Configures `PE12` to serve as alternate function: `AF1`"]
            pub fn into_af1(self, moder: &mut MODER, afr: &mut AFRH) -> PE12<AF1> {
                moder.moder().modify(|_, w| w.moder12().alternate());
                afr.afr().modify(|_, w| w.afrh12().af1());
                PE12 { _mode: PhantomData }
            }
            #[doc = "Configures `PE12` to serve as alternate function: `AF2`"]
            pub fn into_af2(self, moder: &mut MODER, afr: &mut AFRH) -> PE12<AF2> {
                moder.moder().modify(|_, w| w.moder12().alternate());
                afr.afr().modify(|_, w| w.afrh12().af2());
                PE12 { _mode: PhantomData }
            }
            #[doc = " Configures the pin to operate as a floating input pin"]
            pub fn into_floating_input(
                self,
                moder: &mut MODER,
                pupdr: &mut PUPDR,
            ) -> PE12<Input<Floating>> {
                moder.moder().modify(|_, w| w.moder12().input());
                pupdr.pupdr().modify(|_, w| w.pupdr12().floating());
                PE12 { _mode: PhantomData }
            }
            #[doc = " Configures the pin to operate as a pulled down input pin"]
            pub fn into_pull_down_input(
                self,
                moder: &mut MODER,
                pupdr: &mut PUPDR,
            ) -> PE12<Input<PullDown>> {
                moder.moder().modify(|_, w| w.moder12().input());
                pupdr.pupdr().modify(|_, w| w.pupdr12().pull_down());
                PE12 { _mode: PhantomData }
            }
            #[doc = " Configures the pin to operate as a pulled up input pin"]
            pub fn into_pull_up_input(
                self,
                moder: &mut MODER,
                pupdr: &mut PUPDR,
            ) -> PE12<Input<PullUp>> {
                moder.moder().modify(|_, w| w.moder12().input());
                pupdr.pupdr().modify(|_, w| w.pupdr12().pull_up());
                PE12 { _mode: PhantomData }
            }
            #[doc = " Configures the pin to operate as an open drain output pin"]
            pub fn into_open_drain_output(
                self,
                moder: &mut MODER,
                otyper: &mut OTYPER,
            ) -> PE12<Output<OpenDrain>> {
                moder.moder().modify(|_, w| w.moder12().output());
                otyper.otyper().modify(|_, w| w.ot12().open_drain());
                PE12 { _mode: PhantomData }
            }
            #[doc = " Configures the pin to operate as an push pull output pin"]
            pub fn into_push_pull_output(
                self,
                moder: &mut MODER,
                otyper: &mut OTYPER,
            ) -> PE12<Output<PushPull>> {
                moder.moder().modify(|_, w| w.moder12().output());
                otyper.otyper().modify(|_, w| w.ot12().push_pull());
                PE12 { _mode: PhantomData }
            }
            #[doc = " Configures the pin to operate as analog, with disabled schmitt trigger."]
            #[doc = " This mode is suitable when the pin is connected to the DAC or ADC."]
            pub fn into_analog(self, moder: &mut MODER, pupdr: &mut PUPDR) -> PE12<Analog> {
                moder.moder().modify(|_, w| w.moder12().analog());
                pupdr.pupdr().modify(|_, w| w.pupdr12().floating());
                PE12 { _mode: PhantomData }
            }
        }
        impl PE12<Output<OpenDrain>> {
            #[doc = " Enables / disables the internal pull up"]
            pub fn internal_pull_up(&mut self, pupdr: &mut PUPDR, on: bool) {
                pupdr.pupdr().modify(|_, w| {
                    if on {
                        w.pupdr12().pull_up()
                    } else {
                        w.pupdr12().floating()
                    }
                });
            }
        }
        impl<MODE> PE12<Output<MODE>> {
            #[doc = " Erases the pin number from the type"]
            #[doc = ""]
            #[doc = " This is useful when you want to collect the pins into an array where you"]
            #[doc = " need all the elements to have the same type"]
            pub fn downgrade(self) -> PEx<Output<MODE>> {
                PEx {
                    i: 12,
                    _mode: self._mode,
                }
            }
        }
        impl<MODE> PE12<Input<MODE>> {
            #[doc = " Erases the pin number from the type"]
            #[doc = ""]
            #[doc = " This is useful when you want to collect the pins into an array where you"]
            #[doc = " need all the elements to have the same type"]
            pub fn downgrade(self) -> PEx<Input<MODE>> {
                PEx {
                    i: 12,
                    _mode: self._mode,
                }
            }
        }
        impl<MODE> OutputPin for PE12<Output<MODE>> {
            type Error = Infallible;
            fn set_high(&mut self) -> Result<(), Self::Error> {
                unsafe { (*GPIOE::ptr()).bsrr.write(|w| w.bs12().set()) }
                Ok(())
            }
            fn set_low(&mut self) -> Result<(), Self::Error> {
                unsafe { (*GPIOE::ptr()).bsrr.write(|w| w.br12().reset()) }
                Ok(())
            }
        }
        #[cfg(feature = "unproven")]
        impl<MODE> InputPin for PE12<Input<MODE>> {
            type Error = Infallible;
            fn is_high(&self) -> Result<bool, Self::Error> {
                Ok(!self.is_low()?)
            }
            fn is_low(&self) -> Result<bool, Self::Error> {
                Ok(unsafe { (*GPIOE::ptr()).idr.read().idr12().is_low() })
            }
        }
        #[cfg(feature = "unproven")]
        impl InputPin for PE12<Output<OpenDrain>> {
            type Error = Infallible;
            fn is_high(&self) -> Result<bool, Self::Error> {
                Ok(!self.is_low()?)
            }
            fn is_low(&self) -> Result<bool, Self::Error> {
                Ok(unsafe { (*GPIOE::ptr()).idr.read().idr12().is_low() })
            }
        }
        #[cfg(feature = "unproven")]
        impl<MODE> StatefulOutputPin for PE12<Output<MODE>> {
            fn is_set_high(&self) -> Result<bool, Self::Error> {
                self.is_set_low().map(|b| !b)
            }
            fn is_set_low(&self) -> Result<bool, Self::Error> {
                Ok(unsafe { (*GPIOE::ptr()).odr.read().odr12().is_low() })
            }
        }
        #[cfg(feature = "unproven")]
        impl<MODE> toggleable::Default for PE12<Output<MODE>> {}
        #[doc = "Pin `PE13`"]
        pub struct PE13<MODE> {
            _mode: PhantomData<MODE>,
        }
        impl<MODE> PE13<MODE> {
            #[doc = "Configures `PE13` to serve as alternate function: `AF1`"]
            pub fn into_af1(self, moder: &mut MODER, afr: &mut AFRH) -> PE13<AF1> {
                moder.moder().modify(|_, w| w.moder13().alternate());
                afr.afr().modify(|_, w| w.afrh13().af1());
                PE13 { _mode: PhantomData }
            }
            #[doc = "Configures `PE13` to serve as alternate function: `AF2`"]
            pub fn into_af2(self, moder: &mut MODER, afr: &mut AFRH) -> PE13<AF2> {
                moder.moder().modify(|_, w| w.moder13().alternate());
                afr.afr().modify(|_, w| w.afrh13().af2());
                PE13 { _mode: PhantomData }
            }
            #[doc = " Configures the pin to operate as a floating input pin"]
            pub fn into_floating_input(
                self,
                moder: &mut MODER,
                pupdr: &mut PUPDR,
            ) -> PE13<Input<Floating>> {
                moder.moder().modify(|_, w| w.moder13().input());
                pupdr.pupdr().modify(|_, w| w.pupdr13().floating());
                PE13 { _mode: PhantomData }
            }
            #[doc = " Configures the pin to operate as a pulled down input pin"]
            pub fn into_pull_down_input(
                self,
                moder: &mut MODER,
                pupdr: &mut PUPDR,
            ) -> PE13<Input<PullDown>> {
                moder.moder().modify(|_, w| w.moder13().input());
                pupdr.pupdr().modify(|_, w| w.pupdr13().pull_down());
                PE13 { _mode: PhantomData }
            }
            #[doc = " Configures the pin to operate as a pulled up input pin"]
            pub fn into_pull_up_input(
                self,
                moder: &mut MODER,
                pupdr: &mut PUPDR,
            ) -> PE13<Input<PullUp>> {
                moder.moder().modify(|_, w| w.moder13().input());
                pupdr.pupdr().modify(|_, w| w.pupdr13().pull_up());
                PE13 { _mode: PhantomData }
            }
            #[doc = " Configures the pin to operate as an open drain output pin"]
            pub fn into_open_drain_output(
                self,
                moder: &mut MODER,
                otyper: &mut OTYPER,
            ) -> PE13<Output<OpenDrain>> {
                moder.moder().modify(|_, w| w.moder13().output());
                otyper.otyper().modify(|_, w| w.ot13().open_drain());
                PE13 { _mode: PhantomData }
            }
            #[doc = " Configures the pin to operate as an push pull output pin"]
            pub fn into_push_pull_output(
                self,
                moder: &mut MODER,
                otyper: &mut OTYPER,
            ) -> PE13<Output<PushPull>> {
                moder.moder().modify(|_, w| w.moder13().output());
                otyper.otyper().modify(|_, w| w.ot13().push_pull());
                PE13 { _mode: PhantomData }
            }
            #[doc = " Configures the pin to operate as analog, with disabled schmitt trigger."]
            #[doc = " This mode is suitable when the pin is connected to the DAC or ADC."]
            pub fn into_analog(self, moder: &mut MODER, pupdr: &mut PUPDR) -> PE13<Analog> {
                moder.moder().modify(|_, w| w.moder13().analog());
                pupdr.pupdr().modify(|_, w| w.pupdr13().floating());
                PE13 { _mode: PhantomData }
            }
        }
        impl PE13<Output<OpenDrain>> {
            #[doc = " Enables / disables the internal pull up"]
            pub fn internal_pull_up(&mut self, pupdr: &mut PUPDR, on: bool) {
                pupdr.pupdr().modify(|_, w| {
                    if on {
                        w.pupdr13().pull_up()
                    } else {
                        w.pupdr13().floating()
                    }
                });
            }
        }
        impl<MODE> PE13<Output<MODE>> {
            #[doc = " Erases the pin number from the type"]
            #[doc = ""]
            #[doc = " This is useful when you want to collect the pins into an array where you"]
            #[doc = " need all the elements to have the same type"]
            pub fn downgrade(self) -> PEx<Output<MODE>> {
                PEx {
                    i: 13,
                    _mode: self._mode,
                }
            }
        }
        impl<MODE> PE13<Input<MODE>> {
            #[doc = " Erases the pin number from the type"]
            #[doc = ""]
            #[doc = " This is useful when you want to collect the pins into an array where you"]
            #[doc = " need all the elements to have the same type"]
            pub fn downgrade(self) -> PEx<Input<MODE>> {
                PEx {
                    i: 13,
                    _mode: self._mode,
                }
            }
        }
        impl<MODE> OutputPin for PE13<Output<MODE>> {
            type Error = Infallible;
            fn set_high(&mut self) -> Result<(), Self::Error> {
                unsafe { (*GPIOE::ptr()).bsrr.write(|w| w.bs13().set()) }
                Ok(())
            }
            fn set_low(&mut self) -> Result<(), Self::Error> {
                unsafe { (*GPIOE::ptr()).bsrr.write(|w| w.br13().reset()) }
                Ok(())
            }
        }
        #[cfg(feature = "unproven")]
        impl<MODE> InputPin for PE13<Input<MODE>> {
            type Error = Infallible;
            fn is_high(&self) -> Result<bool, Self::Error> {
                Ok(!self.is_low()?)
            }
            fn is_low(&self) -> Result<bool, Self::Error> {
                Ok(unsafe { (*GPIOE::ptr()).idr.read().idr13().is_low() })
            }
        }
        #[cfg(feature = "unproven")]
        impl InputPin for PE13<Output<OpenDrain>> {
            type Error = Infallible;
            fn is_high(&self) -> Result<bool, Self::Error> {
                Ok(!self.is_low()?)
            }
            fn is_low(&self) -> Result<bool, Self::Error> {
                Ok(unsafe { (*GPIOE::ptr()).idr.read().idr13().is_low() })
            }
        }
        #[cfg(feature = "unproven")]
        impl<MODE> StatefulOutputPin for PE13<Output<MODE>> {
            fn is_set_high(&self) -> Result<bool, Self::Error> {
                self.is_set_low().map(|b| !b)
            }
            fn is_set_low(&self) -> Result<bool, Self::Error> {
                Ok(unsafe { (*GPIOE::ptr()).odr.read().odr13().is_low() })
            }
        }
        #[cfg(feature = "unproven")]
        impl<MODE> toggleable::Default for PE13<Output<MODE>> {}
        #[doc = "Pin `PE14`"]
        pub struct PE14<MODE> {
            _mode: PhantomData<MODE>,
        }
        impl<MODE> PE14<MODE> {
            #[doc = "Configures `PE14` to serve as alternate function: `AF1`"]
            pub fn into_af1(self, moder: &mut MODER, afr: &mut AFRH) -> PE14<AF1> {
                moder.moder().modify(|_, w| w.moder14().alternate());
                afr.afr().modify(|_, w| w.afrh14().af1());
                PE14 { _mode: PhantomData }
            }
            #[doc = "Configures `PE14` to serve as alternate function: `AF2`"]
            pub fn into_af2(self, moder: &mut MODER, afr: &mut AFRH) -> PE14<AF2> {
                moder.moder().modify(|_, w| w.moder14().alternate());
                afr.afr().modify(|_, w| w.afrh14().af2());
                PE14 { _mode: PhantomData }
            }
            #[doc = "Configures `PE14` to serve as alternate function: `AF6`"]
            pub fn into_af6(self, moder: &mut MODER, afr: &mut AFRH) -> PE14<AF6> {
                moder.moder().modify(|_, w| w.moder14().alternate());
                afr.afr().modify(|_, w| w.afrh14().af6());
                PE14 { _mode: PhantomData }
            }
            #[doc = " Configures the pin to operate as a floating input pin"]
            pub fn into_floating_input(
                self,
                moder: &mut MODER,
                pupdr: &mut PUPDR,
            ) -> PE14<Input<Floating>> {
                moder.moder().modify(|_, w| w.moder14().input());
                pupdr.pupdr().modify(|_, w| w.pupdr14().floating());
                PE14 { _mode: PhantomData }
            }
            #[doc = " Configures the pin to operate as a pulled down input pin"]
            pub fn into_pull_down_input(
                self,
                moder: &mut MODER,
                pupdr: &mut PUPDR,
            ) -> PE14<Input<PullDown>> {
                moder.moder().modify(|_, w| w.moder14().input());
                pupdr.pupdr().modify(|_, w| w.pupdr14().pull_down());
                PE14 { _mode: PhantomData }
            }
            #[doc = " Configures the pin to operate as a pulled up input pin"]
            pub fn into_pull_up_input(
                self,
                moder: &mut MODER,
                pupdr: &mut PUPDR,
            ) -> PE14<Input<PullUp>> {
                moder.moder().modify(|_, w| w.moder14().input());
                pupdr.pupdr().modify(|_, w| w.pupdr14().pull_up());
                PE14 { _mode: PhantomData }
            }
            #[doc = " Configures the pin to operate as an open drain output pin"]
            pub fn into_open_drain_output(
                self,
                moder: &mut MODER,
                otyper: &mut OTYPER,
            ) -> PE14<Output<OpenDrain>> {
                moder.moder().modify(|_, w| w.moder14().output());
                otyper.otyper().modify(|_, w| w.ot14().open_drain());
                PE14 { _mode: PhantomData }
            }
            #[doc = " Configures the pin to operate as an push pull output pin"]
            pub fn into_push_pull_output(
                self,
                moder: &mut MODER,
                otyper: &mut OTYPER,
            ) -> PE14<Output<PushPull>> {
                moder.moder().modify(|_, w| w.moder14().output());
                otyper.otyper().modify(|_, w| w.ot14().push_pull());
                PE14 { _mode: PhantomData }
            }
            #[doc = " Configures the pin to operate as analog, with disabled schmitt trigger."]
            #[doc = " This mode is suitable when the pin is connected to the DAC or ADC."]
            pub fn into_analog(self, moder: &mut MODER, pupdr: &mut PUPDR) -> PE14<Analog> {
                moder.moder().modify(|_, w| w.moder14().analog());
                pupdr.pupdr().modify(|_, w| w.pupdr14().floating());
                PE14 { _mode: PhantomData }
            }
        }
        impl PE14<Output<OpenDrain>> {
            #[doc = " Enables / disables the internal pull up"]
            pub fn internal_pull_up(&mut self, pupdr: &mut PUPDR, on: bool) {
                pupdr.pupdr().modify(|_, w| {
                    if on {
                        w.pupdr14().pull_up()
                    } else {
                        w.pupdr14().floating()
                    }
                });
            }
        }
        impl<MODE> PE14<Output<MODE>> {
            #[doc = " Erases the pin number from the type"]
            #[doc = ""]
            #[doc = " This is useful when you want to collect the pins into an array where you"]
            #[doc = " need all the elements to have the same type"]
            pub fn downgrade(self) -> PEx<Output<MODE>> {
                PEx {
                    i: 14,
                    _mode: self._mode,
                }
            }
        }
        impl<MODE> PE14<Input<MODE>> {
            #[doc = " Erases the pin number from the type"]
            #[doc = ""]
            #[doc = " This is useful when you want to collect the pins into an array where you"]
            #[doc = " need all the elements to have the same type"]
            pub fn downgrade(self) -> PEx<Input<MODE>> {
                PEx {
                    i: 14,
                    _mode: self._mode,
                }
            }
        }
        impl<MODE> OutputPin for PE14<Output<MODE>> {
            type Error = Infallible;
            fn set_high(&mut self) -> Result<(), Self::Error> {
                unsafe { (*GPIOE::ptr()).bsrr.write(|w| w.bs14().set()) }
                Ok(())
            }
            fn set_low(&mut self) -> Result<(), Self::Error> {
                unsafe { (*GPIOE::ptr()).bsrr.write(|w| w.br14().reset()) }
                Ok(())
            }
        }
        #[cfg(feature = "unproven")]
        impl<MODE> InputPin for PE14<Input<MODE>> {
            type Error = Infallible;
            fn is_high(&self) -> Result<bool, Self::Error> {
                Ok(!self.is_low()?)
            }
            fn is_low(&self) -> Result<bool, Self::Error> {
                Ok(unsafe { (*GPIOE::ptr()).idr.read().idr14().is_low() })
            }
        }
        #[cfg(feature = "unproven")]
        impl InputPin for PE14<Output<OpenDrain>> {
            type Error = Infallible;
            fn is_high(&self) -> Result<bool, Self::Error> {
                Ok(!self.is_low()?)
            }
            fn is_low(&self) -> Result<bool, Self::Error> {
                Ok(unsafe { (*GPIOE::ptr()).idr.read().idr14().is_low() })
            }
        }
        #[cfg(feature = "unproven")]
        impl<MODE> StatefulOutputPin for PE14<Output<MODE>> {
            fn is_set_high(&self) -> Result<bool, Self::Error> {
                self.is_set_low().map(|b| !b)
            }
            fn is_set_low(&self) -> Result<bool, Self::Error> {
                Ok(unsafe { (*GPIOE::ptr()).odr.read().odr14().is_low() })
            }
        }
        #[cfg(feature = "unproven")]
        impl<MODE> toggleable::Default for PE14<Output<MODE>> {}
        #[doc = "Pin `PE15`"]
        pub struct PE15<MODE> {
            _mode: PhantomData<MODE>,
        }
        impl<MODE> PE15<MODE> {
            #[doc = "Configures `PE15` to serve as alternate function: `AF1`"]
            pub fn into_af1(self, moder: &mut MODER, afr: &mut AFRH) -> PE15<AF1> {
                moder.moder().modify(|_, w| w.moder15().alternate());
                afr.afr().modify(|_, w| w.afrh15().af1());
                PE15 { _mode: PhantomData }
            }
            #[doc = "Configures `PE15` to serve as alternate function: `AF2`"]
            pub fn into_af2(self, moder: &mut MODER, afr: &mut AFRH) -> PE15<AF2> {
                moder.moder().modify(|_, w| w.moder15().alternate());
                afr.afr().modify(|_, w| w.afrh15().af2());
                PE15 { _mode: PhantomData }
            }
            #[doc = "Configures `PE15` to serve as alternate function: `AF7`"]
            pub fn into_af7(self, moder: &mut MODER, afr: &mut AFRH) -> PE15<AF7> {
                moder.moder().modify(|_, w| w.moder15().alternate());
                afr.afr().modify(|_, w| w.afrh15().af7());
                PE15 { _mode: PhantomData }
            }
            #[doc = " Configures the pin to operate as a floating input pin"]
            pub fn into_floating_input(
                self,
                moder: &mut MODER,
                pupdr: &mut PUPDR,
            ) -> PE15<Input<Floating>> {
                moder.moder().modify(|_, w| w.moder15().input());
                pupdr.pupdr().modify(|_, w| w.pupdr15().floating());
                PE15 { _mode: PhantomData }
            }
            #[doc = " Configures the pin to operate as a pulled down input pin"]
            pub fn into_pull_down_input(
                self,
                moder: &mut MODER,
                pupdr: &mut PUPDR,
            ) -> PE15<Input<PullDown>> {
                moder.moder().modify(|_, w| w.moder15().input());
                pupdr.pupdr().modify(|_, w| w.pupdr15().pull_down());
                PE15 { _mode: PhantomData }
            }
            #[doc = " Configures the pin to operate as a pulled up input pin"]
            pub fn into_pull_up_input(
                self,
                moder: &mut MODER,
                pupdr: &mut PUPDR,
            ) -> PE15<Input<PullUp>> {
                moder.moder().modify(|_, w| w.moder15().input());
                pupdr.pupdr().modify(|_, w| w.pupdr15().pull_up());
                PE15 { _mode: PhantomData }
            }
            #[doc = " Configures the pin to operate as an open drain output pin"]
            pub fn into_open_drain_output(
                self,
                moder: &mut MODER,
                otyper: &mut OTYPER,
            ) -> PE15<Output<OpenDrain>> {
                moder.moder().modify(|_, w| w.moder15().output());
                otyper.otyper().modify(|_, w| w.ot15().open_drain());
                PE15 { _mode: PhantomData }
            }
            #[doc = " Configures the pin to operate as an push pull output pin"]
            pub fn into_push_pull_output(
                self,
                moder: &mut MODER,
                otyper: &mut OTYPER,
            ) -> PE15<Output<PushPull>> {
                moder.moder().modify(|_, w| w.moder15().output());
                otyper.otyper().modify(|_, w| w.ot15().push_pull());
                PE15 { _mode: PhantomData }
            }
            #[doc = " Configures the pin to operate as analog, with disabled schmitt trigger."]
            #[doc = " This mode is suitable when the pin is connected to the DAC or ADC."]
            pub fn into_analog(self, moder: &mut MODER, pupdr: &mut PUPDR) -> PE15<Analog> {
                moder.moder().modify(|_, w| w.moder15().analog());
                pupdr.pupdr().modify(|_, w| w.pupdr15().floating());
                PE15 { _mode: PhantomData }
            }
        }
        impl PE15<Output<OpenDrain>> {
            #[doc = " Enables / disables the internal pull up"]
            pub fn internal_pull_up(&mut self, pupdr: &mut PUPDR, on: bool) {
                pupdr.pupdr().modify(|_, w| {
                    if on {
                        w.pupdr15().pull_up()
                    } else {
                        w.pupdr15().floating()
                    }
                });
            }
        }
        impl<MODE> PE15<Output<MODE>> {
            #[doc = " Erases the pin number from the type"]
            #[doc = ""]
            #[doc = " This is useful when you want to collect the pins into an array where you"]
            #[doc = " need all the elements to have the same type"]
            pub fn downgrade(self) -> PEx<Output<MODE>> {
                PEx {
                    i: 15,
                    _mode: self._mode,
                }
            }
        }
        impl<MODE> PE15<Input<MODE>> {
            #[doc = " Erases the pin number from the type"]
            #[doc = ""]
            #[doc = " This is useful when you want to collect the pins into an array where you"]
            #[doc = " need all the elements to have the same type"]
            pub fn downgrade(self) -> PEx<Input<MODE>> {
                PEx {
                    i: 15,
                    _mode: self._mode,
                }
            }
        }
        impl<MODE> OutputPin for PE15<Output<MODE>> {
            type Error = Infallible;
            fn set_high(&mut self) -> Result<(), Self::Error> {
                unsafe { (*GPIOE::ptr()).bsrr.write(|w| w.bs15().set()) }
                Ok(())
            }
            fn set_low(&mut self) -> Result<(), Self::Error> {
                unsafe { (*GPIOE::ptr()).bsrr.write(|w| w.br15().reset()) }
                Ok(())
            }
        }
        #[cfg(feature = "unproven")]
        impl<MODE> InputPin for PE15<Input<MODE>> {
            type Error = Infallible;
            fn is_high(&self) -> Result<bool, Self::Error> {
                Ok(!self.is_low()?)
            }
            fn is_low(&self) -> Result<bool, Self::Error> {
                Ok(unsafe { (*GPIOE::ptr()).idr.read().idr15().is_low() })
            }
        }
        #[cfg(feature = "unproven")]
        impl InputPin for PE15<Output<OpenDrain>> {
            type Error = Infallible;
            fn is_high(&self) -> Result<bool, Self::Error> {
                Ok(!self.is_low()?)
            }
            fn is_low(&self) -> Result<bool, Self::Error> {
                Ok(unsafe { (*GPIOE::ptr()).idr.read().idr15().is_low() })
            }
        }
        #[cfg(feature = "unproven")]
        impl<MODE> StatefulOutputPin for PE15<Output<MODE>> {
            fn is_set_high(&self) -> Result<bool, Self::Error> {
                self.is_set_low().map(|b| !b)
            }
            fn is_set_low(&self) -> Result<bool, Self::Error> {
                Ok(unsafe { (*GPIOE::ptr()).odr.read().odr15().is_low() })
            }
        }
        #[cfg(feature = "unproven")]
        impl<MODE> toggleable::Default for PE15<Output<MODE>> {}
    }
    #[doc = "All Pins and associated functions for GPIO Bank: `GPIOF`"]
    pub mod gpiof {
        use core::marker::PhantomData;
        use core::convert::Infallible;
        use crate::hal::digital::v2::OutputPin;
        #[cfg(feature = "unproven")]
        use crate::hal::digital::v2::InputPin;
        #[cfg(feature = "unproven")]
        use crate::hal::digital::v2::StatefulOutputPin;
        #[cfg(feature = "unproven")]
        use crate::hal::digital::v2::toggleable;
        use crate::pac::{gpioc, GPIOF};
        use crate::rcc::AHB;
        #[allow(unused_imports)]
        use super::{
            AF0, AF1, AF2, AF3, AF4, AF5, AF6, AF7, AF8, AF9, AF10, AF11, AF12, AF13, AF14, AF15,
        };
        use super::{
            Floating, GpioExt, Input, OpenDrain, Output, Analog, PullDown, PullUp, PushPull, PXx,
            Gpio,
        };
        #[doc = " GPIO parts"]
        pub struct Parts {
            #[doc = " Opaque AFRH register"]
            pub afrh: AFRH,
            #[doc = " Opaque AFRL register"]
            pub afrl: AFRL,
            #[doc = " Opaque MODER register"]
            pub moder: MODER,
            #[doc = " Opaque OTYPER register"]
            pub otyper: OTYPER,
            #[doc = " Opaque PUPDR register"]
            pub pupdr: PUPDR,
            #[doc = " Pin"]
            pub pf0: PF0<Input<Floating>>,
            #[doc = " Pin"]
            pub pf1: PF1<Input<Floating>>,
            #[doc = " Pin"]
            pub pf2: PF2<Input<Floating>>,
            #[doc = " Pin"]
            pub pf4: PF4<Input<Floating>>,
            #[doc = " Pin"]
            pub pf6: PF6<Input<Floating>>,
            #[doc = " Pin"]
            pub pf9: PF9<Input<Floating>>,
            #[doc = " Pin"]
            pub pf10: PF10<Input<Floating>>,
        }
        impl GpioExt for GPIOF {
            type Parts = Parts;
            fn split(self, ahb: &mut AHB) -> Parts {
                ahb.enr().modify(|_, w| w.iopfen().set_bit());
                ahb.rstr().modify(|_, w| w.iopfrst().set_bit());
                ahb.rstr().modify(|_, w| w.iopfrst().clear_bit());
                Parts {
                    afrh: AFRH { _0: () },
                    afrl: AFRL { _0: () },
                    moder: MODER { _0: () },
                    otyper: OTYPER { _0: () },
                    pupdr: PUPDR { _0: () },
                    pf0: PF0 { _mode: PhantomData },
                    pf1: PF1 { _mode: PhantomData },
                    pf2: PF2 { _mode: PhantomData },
                    pf4: PF4 { _mode: PhantomData },
                    pf6: PF6 { _mode: PhantomData },
                    pf9: PF9 { _mode: PhantomData },
                    pf10: PF10 { _mode: PhantomData },
                }
            }
        }
        #[doc = " Opaque AFRL register"]
        pub struct AFRL {
            _0: (),
        }
        impl AFRL {
            #[allow(dead_code)]
            pub(crate) fn afr(&mut self) -> &gpioc::AFRL {
                unsafe { &(*GPIOF::ptr()).afrl }
            }
        }
        #[doc = " Opaque AFRH register"]
        pub struct AFRH {
            _0: (),
        }
        impl AFRH {
            #[allow(dead_code)]
            pub(crate) fn afr(&mut self) -> &gpioc::AFRH {
                unsafe { &(*GPIOF::ptr()).afrh }
            }
        }
        #[doc = " Opaque MODER register"]
        pub struct MODER {
            _0: (),
        }
        impl MODER {
            pub(crate) fn moder(&mut self) -> &gpioc::MODER {
                unsafe { &(*GPIOF::ptr()).moder }
            }
        }
        #[doc = " Opaque OTYPER register"]
        pub struct OTYPER {
            _0: (),
        }
        impl OTYPER {
            pub(crate) fn otyper(&mut self) -> &gpioc::OTYPER {
                unsafe { &(*GPIOF::ptr()).otyper }
            }
        }
        #[doc = " Opaque PUPDR register"]
        pub struct PUPDR {
            _0: (),
        }
        impl PUPDR {
            pub(crate) fn pupdr(&mut self) -> &gpioc::PUPDR {
                unsafe { &(*GPIOF::ptr()).pupdr }
            }
        }
        #[doc = " Partially erased pin"]
        pub struct PFx<MODE> {
            i: u8,
            _mode: PhantomData<MODE>,
        }
        impl<MODE> PFx<MODE> {
            #[doc = " Erases the port letter from the type"]
            #[doc = ""]
            #[doc = " This is useful when you want to collect the pins into an array where you"]
            #[doc = " need all the elements to have the same type"]
            pub fn downgrade(self) -> PXx<MODE> {
                PXx {
                    i: self.i,
                    gpio: Gpio::GPIOF,
                    _mode: self._mode,
                }
            }
        }
        impl<MODE> OutputPin for PFx<Output<MODE>> {
            type Error = Infallible;
            fn set_high(&mut self) -> Result<(), Self::Error> {
                unsafe { (*GPIOF::ptr()).bsrr.write(|w| w.bits(1 << self.i)) }
                Ok(())
            }
            fn set_low(&mut self) -> Result<(), Self::Error> {
                unsafe { (*GPIOF::ptr()).bsrr.write(|w| w.bits(1 << (16 + self.i))) }
                Ok(())
            }
        }
        #[cfg(feature = "unproven")]
        impl<MODE> InputPin for PFx<Input<MODE>> {
            type Error = Infallible;
            fn is_high(&self) -> Result<bool, Self::Error> {
                Ok(!self.is_low()?)
            }
            fn is_low(&self) -> Result<bool, Self::Error> {
                Ok(unsafe { (*GPIOF::ptr()).idr.read().bits() & (1 << self.i) == 0 })
            }
        }
        #[cfg(feature = "unproven")]
        impl InputPin for PFx<Output<OpenDrain>> {
            type Error = Infallible;
            fn is_high(&self) -> Result<bool, Self::Error> {
                Ok(!self.is_low()?)
            }
            fn is_low(&self) -> Result<bool, Self::Error> {
                Ok(unsafe { (*GPIOF::ptr()).idr.read().bits() & (1 << self.i) == 0 })
            }
        }
        #[cfg(feature = "unproven")]
        impl<MODE> StatefulOutputPin for PFx<Output<MODE>> {
            fn is_set_high(&self) -> Result<bool, Self::Error> {
                self.is_set_low().map(|b| !b)
            }
            fn is_set_low(&self) -> Result<bool, Self::Error> {
                Ok(unsafe { (*GPIOF::ptr()).odr.read().bits() & (1 << self.i) == 0 })
            }
        }
        #[cfg(feature = "unproven")]
        impl<MODE> toggleable::Default for PFx<Output<MODE>> {}
        #[doc = "Pin `PF0`"]
        pub struct PF0<MODE> {
            _mode: PhantomData<MODE>,
        }
        impl<MODE> PF0<MODE> {
            #[doc = "Configures `PF0` to serve as alternate function: `AF4`"]
            pub fn into_af4(self, moder: &mut MODER, afr: &mut AFRL) -> PF0<AF4> {
                moder.moder().modify(|_, w| w.moder0().alternate());
                afr.afr().modify(|_, w| w.afrl0().af4());
                PF0 { _mode: PhantomData }
            }
            #[doc = "Configures `PF0` to serve as alternate function: `AF6`"]
            pub fn into_af6(self, moder: &mut MODER, afr: &mut AFRL) -> PF0<AF6> {
                moder.moder().modify(|_, w| w.moder0().alternate());
                afr.afr().modify(|_, w| w.afrl0().af6());
                PF0 { _mode: PhantomData }
            }
            #[doc = " Configures the pin to operate as a floating input pin"]
            pub fn into_floating_input(
                self,
                moder: &mut MODER,
                pupdr: &mut PUPDR,
            ) -> PF0<Input<Floating>> {
                moder.moder().modify(|_, w| w.moder0().input());
                pupdr.pupdr().modify(|_, w| w.pupdr0().floating());
                PF0 { _mode: PhantomData }
            }
            #[doc = " Configures the pin to operate as a pulled down input pin"]
            pub fn into_pull_down_input(
                self,
                moder: &mut MODER,
                pupdr: &mut PUPDR,
            ) -> PF0<Input<PullDown>> {
                moder.moder().modify(|_, w| w.moder0().input());
                pupdr.pupdr().modify(|_, w| w.pupdr0().pull_down());
                PF0 { _mode: PhantomData }
            }
            #[doc = " Configures the pin to operate as a pulled up input pin"]
            pub fn into_pull_up_input(
                self,
                moder: &mut MODER,
                pupdr: &mut PUPDR,
            ) -> PF0<Input<PullUp>> {
                moder.moder().modify(|_, w| w.moder0().input());
                pupdr.pupdr().modify(|_, w| w.pupdr0().pull_up());
                PF0 { _mode: PhantomData }
            }
            #[doc = " Configures the pin to operate as an open drain output pin"]
            pub fn into_open_drain_output(
                self,
                moder: &mut MODER,
                otyper: &mut OTYPER,
            ) -> PF0<Output<OpenDrain>> {
                moder.moder().modify(|_, w| w.moder0().output());
                otyper.otyper().modify(|_, w| w.ot0().open_drain());
                PF0 { _mode: PhantomData }
            }
            #[doc = " Configures the pin to operate as an push pull output pin"]
            pub fn into_push_pull_output(
                self,
                moder: &mut MODER,
                otyper: &mut OTYPER,
            ) -> PF0<Output<PushPull>> {
                moder.moder().modify(|_, w| w.moder0().output());
                otyper.otyper().modify(|_, w| w.ot0().push_pull());
                PF0 { _mode: PhantomData }
            }
            #[doc = " Configures the pin to operate as analog, with disabled schmitt trigger."]
            #[doc = " This mode is suitable when the pin is connected to the DAC or ADC."]
            pub fn into_analog(self, moder: &mut MODER, pupdr: &mut PUPDR) -> PF0<Analog> {
                moder.moder().modify(|_, w| w.moder0().analog());
                pupdr.pupdr().modify(|_, w| w.pupdr0().floating());
                PF0 { _mode: PhantomData }
            }
        }
        impl PF0<Output<OpenDrain>> {
            #[doc = " Enables / disables the internal pull up"]
            pub fn internal_pull_up(&mut self, pupdr: &mut PUPDR, on: bool) {
                pupdr.pupdr().modify(|_, w| {
                    if on {
                        w.pupdr0().pull_up()
                    } else {
                        w.pupdr0().floating()
                    }
                });
            }
        }
        impl<MODE> PF0<Output<MODE>> {
            #[doc = " Erases the pin number from the type"]
            #[doc = ""]
            #[doc = " This is useful when you want to collect the pins into an array where you"]
            #[doc = " need all the elements to have the same type"]
            pub fn downgrade(self) -> PFx<Output<MODE>> {
                PFx {
                    i: 0,
                    _mode: self._mode,
                }
            }
        }
        impl<MODE> PF0<Input<MODE>> {
            #[doc = " Erases the pin number from the type"]
            #[doc = ""]
            #[doc = " This is useful when you want to collect the pins into an array where you"]
            #[doc = " need all the elements to have the same type"]
            pub fn downgrade(self) -> PFx<Input<MODE>> {
                PFx {
                    i: 0,
                    _mode: self._mode,
                }
            }
        }
        impl<MODE> OutputPin for PF0<Output<MODE>> {
            type Error = Infallible;
            fn set_high(&mut self) -> Result<(), Self::Error> {
                unsafe { (*GPIOF::ptr()).bsrr.write(|w| w.bs0().set()) }
                Ok(())
            }
            fn set_low(&mut self) -> Result<(), Self::Error> {
                unsafe { (*GPIOF::ptr()).bsrr.write(|w| w.br0().reset()) }
                Ok(())
            }
        }
        #[cfg(feature = "unproven")]
        impl<MODE> InputPin for PF0<Input<MODE>> {
            type Error = Infallible;
            fn is_high(&self) -> Result<bool, Self::Error> {
                Ok(!self.is_low()?)
            }
            fn is_low(&self) -> Result<bool, Self::Error> {
                Ok(unsafe { (*GPIOF::ptr()).idr.read().idr0().is_low() })
            }
        }
        #[cfg(feature = "unproven")]
        impl InputPin for PF0<Output<OpenDrain>> {
            type Error = Infallible;
            fn is_high(&self) -> Result<bool, Self::Error> {
                Ok(!self.is_low()?)
            }
            fn is_low(&self) -> Result<bool, Self::Error> {
                Ok(unsafe { (*GPIOF::ptr()).idr.read().idr0().is_low() })
            }
        }
        #[cfg(feature = "unproven")]
        impl<MODE> StatefulOutputPin for PF0<Output<MODE>> {
            fn is_set_high(&self) -> Result<bool, Self::Error> {
                self.is_set_low().map(|b| !b)
            }
            fn is_set_low(&self) -> Result<bool, Self::Error> {
                Ok(unsafe { (*GPIOF::ptr()).odr.read().odr0().is_low() })
            }
        }
        #[cfg(feature = "unproven")]
        impl<MODE> toggleable::Default for PF0<Output<MODE>> {}
        #[doc = "Pin `PF1`"]
        pub struct PF1<MODE> {
            _mode: PhantomData<MODE>,
        }
        impl<MODE> PF1<MODE> {
            #[doc = "Configures `PF1` to serve as alternate function: `AF4`"]
            pub fn into_af4(self, moder: &mut MODER, afr: &mut AFRL) -> PF1<AF4> {
                moder.moder().modify(|_, w| w.moder1().alternate());
                afr.afr().modify(|_, w| w.afrl1().af4());
                PF1 { _mode: PhantomData }
            }
            #[doc = " Configures the pin to operate as a floating input pin"]
            pub fn into_floating_input(
                self,
                moder: &mut MODER,
                pupdr: &mut PUPDR,
            ) -> PF1<Input<Floating>> {
                moder.moder().modify(|_, w| w.moder1().input());
                pupdr.pupdr().modify(|_, w| w.pupdr1().floating());
                PF1 { _mode: PhantomData }
            }
            #[doc = " Configures the pin to operate as a pulled down input pin"]
            pub fn into_pull_down_input(
                self,
                moder: &mut MODER,
                pupdr: &mut PUPDR,
            ) -> PF1<Input<PullDown>> {
                moder.moder().modify(|_, w| w.moder1().input());
                pupdr.pupdr().modify(|_, w| w.pupdr1().pull_down());
                PF1 { _mode: PhantomData }
            }
            #[doc = " Configures the pin to operate as a pulled up input pin"]
            pub fn into_pull_up_input(
                self,
                moder: &mut MODER,
                pupdr: &mut PUPDR,
            ) -> PF1<Input<PullUp>> {
                moder.moder().modify(|_, w| w.moder1().input());
                pupdr.pupdr().modify(|_, w| w.pupdr1().pull_up());
                PF1 { _mode: PhantomData }
            }
            #[doc = " Configures the pin to operate as an open drain output pin"]
            pub fn into_open_drain_output(
                self,
                moder: &mut MODER,
                otyper: &mut OTYPER,
            ) -> PF1<Output<OpenDrain>> {
                moder.moder().modify(|_, w| w.moder1().output());
                otyper.otyper().modify(|_, w| w.ot1().open_drain());
                PF1 { _mode: PhantomData }
            }
            #[doc = " Configures the pin to operate as an push pull output pin"]
            pub fn into_push_pull_output(
                self,
                moder: &mut MODER,
                otyper: &mut OTYPER,
            ) -> PF1<Output<PushPull>> {
                moder.moder().modify(|_, w| w.moder1().output());
                otyper.otyper().modify(|_, w| w.ot1().push_pull());
                PF1 { _mode: PhantomData }
            }
            #[doc = " Configures the pin to operate as analog, with disabled schmitt trigger."]
            #[doc = " This mode is suitable when the pin is connected to the DAC or ADC."]
            pub fn into_analog(self, moder: &mut MODER, pupdr: &mut PUPDR) -> PF1<Analog> {
                moder.moder().modify(|_, w| w.moder1().analog());
                pupdr.pupdr().modify(|_, w| w.pupdr1().floating());
                PF1 { _mode: PhantomData }
            }
        }
        impl PF1<Output<OpenDrain>> {
            #[doc = " Enables / disables the internal pull up"]
            pub fn internal_pull_up(&mut self, pupdr: &mut PUPDR, on: bool) {
                pupdr.pupdr().modify(|_, w| {
                    if on {
                        w.pupdr1().pull_up()
                    } else {
                        w.pupdr1().floating()
                    }
                });
            }
        }
        impl<MODE> PF1<Output<MODE>> {
            #[doc = " Erases the pin number from the type"]
            #[doc = ""]
            #[doc = " This is useful when you want to collect the pins into an array where you"]
            #[doc = " need all the elements to have the same type"]
            pub fn downgrade(self) -> PFx<Output<MODE>> {
                PFx {
                    i: 1,
                    _mode: self._mode,
                }
            }
        }
        impl<MODE> PF1<Input<MODE>> {
            #[doc = " Erases the pin number from the type"]
            #[doc = ""]
            #[doc = " This is useful when you want to collect the pins into an array where you"]
            #[doc = " need all the elements to have the same type"]
            pub fn downgrade(self) -> PFx<Input<MODE>> {
                PFx {
                    i: 1,
                    _mode: self._mode,
                }
            }
        }
        impl<MODE> OutputPin for PF1<Output<MODE>> {
            type Error = Infallible;
            fn set_high(&mut self) -> Result<(), Self::Error> {
                unsafe { (*GPIOF::ptr()).bsrr.write(|w| w.bs1().set()) }
                Ok(())
            }
            fn set_low(&mut self) -> Result<(), Self::Error> {
                unsafe { (*GPIOF::ptr()).bsrr.write(|w| w.br1().reset()) }
                Ok(())
            }
        }
        #[cfg(feature = "unproven")]
        impl<MODE> InputPin for PF1<Input<MODE>> {
            type Error = Infallible;
            fn is_high(&self) -> Result<bool, Self::Error> {
                Ok(!self.is_low()?)
            }
            fn is_low(&self) -> Result<bool, Self::Error> {
                Ok(unsafe { (*GPIOF::ptr()).idr.read().idr1().is_low() })
            }
        }
        #[cfg(feature = "unproven")]
        impl InputPin for PF1<Output<OpenDrain>> {
            type Error = Infallible;
            fn is_high(&self) -> Result<bool, Self::Error> {
                Ok(!self.is_low()?)
            }
            fn is_low(&self) -> Result<bool, Self::Error> {
                Ok(unsafe { (*GPIOF::ptr()).idr.read().idr1().is_low() })
            }
        }
        #[cfg(feature = "unproven")]
        impl<MODE> StatefulOutputPin for PF1<Output<MODE>> {
            fn is_set_high(&self) -> Result<bool, Self::Error> {
                self.is_set_low().map(|b| !b)
            }
            fn is_set_low(&self) -> Result<bool, Self::Error> {
                Ok(unsafe { (*GPIOF::ptr()).odr.read().odr1().is_low() })
            }
        }
        #[cfg(feature = "unproven")]
        impl<MODE> toggleable::Default for PF1<Output<MODE>> {}
        #[doc = "Pin `PF2`"]
        pub struct PF2<MODE> {
            _mode: PhantomData<MODE>,
        }
        impl<MODE> PF2<MODE> {
            #[doc = "Configures `PF2` to serve as alternate function: `AF1`"]
            pub fn into_af1(self, moder: &mut MODER, afr: &mut AFRL) -> PF2<AF1> {
                moder.moder().modify(|_, w| w.moder2().alternate());
                afr.afr().modify(|_, w| w.afrl2().af1());
                PF2 { _mode: PhantomData }
            }
            #[doc = " Configures the pin to operate as a floating input pin"]
            pub fn into_floating_input(
                self,
                moder: &mut MODER,
                pupdr: &mut PUPDR,
            ) -> PF2<Input<Floating>> {
                moder.moder().modify(|_, w| w.moder2().input());
                pupdr.pupdr().modify(|_, w| w.pupdr2().floating());
                PF2 { _mode: PhantomData }
            }
            #[doc = " Configures the pin to operate as a pulled down input pin"]
            pub fn into_pull_down_input(
                self,
                moder: &mut MODER,
                pupdr: &mut PUPDR,
            ) -> PF2<Input<PullDown>> {
                moder.moder().modify(|_, w| w.moder2().input());
                pupdr.pupdr().modify(|_, w| w.pupdr2().pull_down());
                PF2 { _mode: PhantomData }
            }
            #[doc = " Configures the pin to operate as a pulled up input pin"]
            pub fn into_pull_up_input(
                self,
                moder: &mut MODER,
                pupdr: &mut PUPDR,
            ) -> PF2<Input<PullUp>> {
                moder.moder().modify(|_, w| w.moder2().input());
                pupdr.pupdr().modify(|_, w| w.pupdr2().pull_up());
                PF2 { _mode: PhantomData }
            }
            #[doc = " Configures the pin to operate as an open drain output pin"]
            pub fn into_open_drain_output(
                self,
                moder: &mut MODER,
                otyper: &mut OTYPER,
            ) -> PF2<Output<OpenDrain>> {
                moder.moder().modify(|_, w| w.moder2().output());
                otyper.otyper().modify(|_, w| w.ot2().open_drain());
                PF2 { _mode: PhantomData }
            }
            #[doc = " Configures the pin to operate as an push pull output pin"]
            pub fn into_push_pull_output(
                self,
                moder: &mut MODER,
                otyper: &mut OTYPER,
            ) -> PF2<Output<PushPull>> {
                moder.moder().modify(|_, w| w.moder2().output());
                otyper.otyper().modify(|_, w| w.ot2().push_pull());
                PF2 { _mode: PhantomData }
            }
            #[doc = " Configures the pin to operate as analog, with disabled schmitt trigger."]
            #[doc = " This mode is suitable when the pin is connected to the DAC or ADC."]
            pub fn into_analog(self, moder: &mut MODER, pupdr: &mut PUPDR) -> PF2<Analog> {
                moder.moder().modify(|_, w| w.moder2().analog());
                pupdr.pupdr().modify(|_, w| w.pupdr2().floating());
                PF2 { _mode: PhantomData }
            }
        }
        impl PF2<Output<OpenDrain>> {
            #[doc = " Enables / disables the internal pull up"]
            pub fn internal_pull_up(&mut self, pupdr: &mut PUPDR, on: bool) {
                pupdr.pupdr().modify(|_, w| {
                    if on {
                        w.pupdr2().pull_up()
                    } else {
                        w.pupdr2().floating()
                    }
                });
            }
        }
        impl<MODE> PF2<Output<MODE>> {
            #[doc = " Erases the pin number from the type"]
            #[doc = ""]
            #[doc = " This is useful when you want to collect the pins into an array where you"]
            #[doc = " need all the elements to have the same type"]
            pub fn downgrade(self) -> PFx<Output<MODE>> {
                PFx {
                    i: 2,
                    _mode: self._mode,
                }
            }
        }
        impl<MODE> PF2<Input<MODE>> {
            #[doc = " Erases the pin number from the type"]
            #[doc = ""]
            #[doc = " This is useful when you want to collect the pins into an array where you"]
            #[doc = " need all the elements to have the same type"]
            pub fn downgrade(self) -> PFx<Input<MODE>> {
                PFx {
                    i: 2,
                    _mode: self._mode,
                }
            }
        }
        impl<MODE> OutputPin for PF2<Output<MODE>> {
            type Error = Infallible;
            fn set_high(&mut self) -> Result<(), Self::Error> {
                unsafe { (*GPIOF::ptr()).bsrr.write(|w| w.bs2().set()) }
                Ok(())
            }
            fn set_low(&mut self) -> Result<(), Self::Error> {
                unsafe { (*GPIOF::ptr()).bsrr.write(|w| w.br2().reset()) }
                Ok(())
            }
        }
        #[cfg(feature = "unproven")]
        impl<MODE> InputPin for PF2<Input<MODE>> {
            type Error = Infallible;
            fn is_high(&self) -> Result<bool, Self::Error> {
                Ok(!self.is_low()?)
            }
            fn is_low(&self) -> Result<bool, Self::Error> {
                Ok(unsafe { (*GPIOF::ptr()).idr.read().idr2().is_low() })
            }
        }
        #[cfg(feature = "unproven")]
        impl InputPin for PF2<Output<OpenDrain>> {
            type Error = Infallible;
            fn is_high(&self) -> Result<bool, Self::Error> {
                Ok(!self.is_low()?)
            }
            fn is_low(&self) -> Result<bool, Self::Error> {
                Ok(unsafe { (*GPIOF::ptr()).idr.read().idr2().is_low() })
            }
        }
        #[cfg(feature = "unproven")]
        impl<MODE> StatefulOutputPin for PF2<Output<MODE>> {
            fn is_set_high(&self) -> Result<bool, Self::Error> {
                self.is_set_low().map(|b| !b)
            }
            fn is_set_low(&self) -> Result<bool, Self::Error> {
                Ok(unsafe { (*GPIOF::ptr()).odr.read().odr2().is_low() })
            }
        }
        #[cfg(feature = "unproven")]
        impl<MODE> toggleable::Default for PF2<Output<MODE>> {}
        #[doc = "Pin `PF4`"]
        pub struct PF4<MODE> {
            _mode: PhantomData<MODE>,
        }
        impl<MODE> PF4<MODE> {
            #[doc = "Configures `PF4` to serve as alternate function: `AF1`"]
            pub fn into_af1(self, moder: &mut MODER, afr: &mut AFRL) -> PF4<AF1> {
                moder.moder().modify(|_, w| w.moder4().alternate());
                afr.afr().modify(|_, w| w.afrl4().af1());
                PF4 { _mode: PhantomData }
            }
            #[doc = "Configures `PF4` to serve as alternate function: `AF2`"]
            pub fn into_af2(self, moder: &mut MODER, afr: &mut AFRL) -> PF4<AF2> {
                moder.moder().modify(|_, w| w.moder4().alternate());
                afr.afr().modify(|_, w| w.afrl4().af2());
                PF4 { _mode: PhantomData }
            }
            #[doc = " Configures the pin to operate as a floating input pin"]
            pub fn into_floating_input(
                self,
                moder: &mut MODER,
                pupdr: &mut PUPDR,
            ) -> PF4<Input<Floating>> {
                moder.moder().modify(|_, w| w.moder4().input());
                pupdr.pupdr().modify(|_, w| w.pupdr4().floating());
                PF4 { _mode: PhantomData }
            }
            #[doc = " Configures the pin to operate as a pulled down input pin"]
            pub fn into_pull_down_input(
                self,
                moder: &mut MODER,
                pupdr: &mut PUPDR,
            ) -> PF4<Input<PullDown>> {
                moder.moder().modify(|_, w| w.moder4().input());
                pupdr.pupdr().modify(|_, w| w.pupdr4().pull_down());
                PF4 { _mode: PhantomData }
            }
            #[doc = " Configures the pin to operate as a pulled up input pin"]
            pub fn into_pull_up_input(
                self,
                moder: &mut MODER,
                pupdr: &mut PUPDR,
            ) -> PF4<Input<PullUp>> {
                moder.moder().modify(|_, w| w.moder4().input());
                pupdr.pupdr().modify(|_, w| w.pupdr4().pull_up());
                PF4 { _mode: PhantomData }
            }
            #[doc = " Configures the pin to operate as an open drain output pin"]
            pub fn into_open_drain_output(
                self,
                moder: &mut MODER,
                otyper: &mut OTYPER,
            ) -> PF4<Output<OpenDrain>> {
                moder.moder().modify(|_, w| w.moder4().output());
                otyper.otyper().modify(|_, w| w.ot4().open_drain());
                PF4 { _mode: PhantomData }
            }
            #[doc = " Configures the pin to operate as an push pull output pin"]
            pub fn into_push_pull_output(
                self,
                moder: &mut MODER,
                otyper: &mut OTYPER,
            ) -> PF4<Output<PushPull>> {
                moder.moder().modify(|_, w| w.moder4().output());
                otyper.otyper().modify(|_, w| w.ot4().push_pull());
                PF4 { _mode: PhantomData }
            }
            #[doc = " Configures the pin to operate as analog, with disabled schmitt trigger."]
            #[doc = " This mode is suitable when the pin is connected to the DAC or ADC."]
            pub fn into_analog(self, moder: &mut MODER, pupdr: &mut PUPDR) -> PF4<Analog> {
                moder.moder().modify(|_, w| w.moder4().analog());
                pupdr.pupdr().modify(|_, w| w.pupdr4().floating());
                PF4 { _mode: PhantomData }
            }
        }
        impl PF4<Output<OpenDrain>> {
            #[doc = " Enables / disables the internal pull up"]
            pub fn internal_pull_up(&mut self, pupdr: &mut PUPDR, on: bool) {
                pupdr.pupdr().modify(|_, w| {
                    if on {
                        w.pupdr4().pull_up()
                    } else {
                        w.pupdr4().floating()
                    }
                });
            }
        }
        impl<MODE> PF4<Output<MODE>> {
            #[doc = " Erases the pin number from the type"]
            #[doc = ""]
            #[doc = " This is useful when you want to collect the pins into an array where you"]
            #[doc = " need all the elements to have the same type"]
            pub fn downgrade(self) -> PFx<Output<MODE>> {
                PFx {
                    i: 4,
                    _mode: self._mode,
                }
            }
        }
        impl<MODE> PF4<Input<MODE>> {
            #[doc = " Erases the pin number from the type"]
            #[doc = ""]
            #[doc = " This is useful when you want to collect the pins into an array where you"]
            #[doc = " need all the elements to have the same type"]
            pub fn downgrade(self) -> PFx<Input<MODE>> {
                PFx {
                    i: 4,
                    _mode: self._mode,
                }
            }
        }
        impl<MODE> OutputPin for PF4<Output<MODE>> {
            type Error = Infallible;
            fn set_high(&mut self) -> Result<(), Self::Error> {
                unsafe { (*GPIOF::ptr()).bsrr.write(|w| w.bs4().set()) }
                Ok(())
            }
            fn set_low(&mut self) -> Result<(), Self::Error> {
                unsafe { (*GPIOF::ptr()).bsrr.write(|w| w.br4().reset()) }
                Ok(())
            }
        }
        #[cfg(feature = "unproven")]
        impl<MODE> InputPin for PF4<Input<MODE>> {
            type Error = Infallible;
            fn is_high(&self) -> Result<bool, Self::Error> {
                Ok(!self.is_low()?)
            }
            fn is_low(&self) -> Result<bool, Self::Error> {
                Ok(unsafe { (*GPIOF::ptr()).idr.read().idr4().is_low() })
            }
        }
        #[cfg(feature = "unproven")]
        impl InputPin for PF4<Output<OpenDrain>> {
            type Error = Infallible;
            fn is_high(&self) -> Result<bool, Self::Error> {
                Ok(!self.is_low()?)
            }
            fn is_low(&self) -> Result<bool, Self::Error> {
                Ok(unsafe { (*GPIOF::ptr()).idr.read().idr4().is_low() })
            }
        }
        #[cfg(feature = "unproven")]
        impl<MODE> StatefulOutputPin for PF4<Output<MODE>> {
            fn is_set_high(&self) -> Result<bool, Self::Error> {
                self.is_set_low().map(|b| !b)
            }
            fn is_set_low(&self) -> Result<bool, Self::Error> {
                Ok(unsafe { (*GPIOF::ptr()).odr.read().odr4().is_low() })
            }
        }
        #[cfg(feature = "unproven")]
        impl<MODE> toggleable::Default for PF4<Output<MODE>> {}
        #[doc = "Pin `PF6`"]
        pub struct PF6<MODE> {
            _mode: PhantomData<MODE>,
        }
        impl<MODE> PF6<MODE> {
            #[doc = "Configures `PF6` to serve as alternate function: `AF1`"]
            pub fn into_af1(self, moder: &mut MODER, afr: &mut AFRL) -> PF6<AF1> {
                moder.moder().modify(|_, w| w.moder6().alternate());
                afr.afr().modify(|_, w| w.afrl6().af1());
                PF6 { _mode: PhantomData }
            }
            #[doc = "Configures `PF6` to serve as alternate function: `AF2`"]
            pub fn into_af2(self, moder: &mut MODER, afr: &mut AFRL) -> PF6<AF2> {
                moder.moder().modify(|_, w| w.moder6().alternate());
                afr.afr().modify(|_, w| w.afrl6().af2());
                PF6 { _mode: PhantomData }
            }
            #[doc = "Configures `PF6` to serve as alternate function: `AF4`"]
            pub fn into_af4(self, moder: &mut MODER, afr: &mut AFRL) -> PF6<AF4> {
                moder.moder().modify(|_, w| w.moder6().alternate());
                afr.afr().modify(|_, w| w.afrl6().af4());
                PF6 { _mode: PhantomData }
            }
            #[doc = "Configures `PF6` to serve as alternate function: `AF7`"]
            pub fn into_af7(self, moder: &mut MODER, afr: &mut AFRL) -> PF6<AF7> {
                moder.moder().modify(|_, w| w.moder6().alternate());
                afr.afr().modify(|_, w| w.afrl6().af7());
                PF6 { _mode: PhantomData }
            }
            #[doc = " Configures the pin to operate as a floating input pin"]
            pub fn into_floating_input(
                self,
                moder: &mut MODER,
                pupdr: &mut PUPDR,
            ) -> PF6<Input<Floating>> {
                moder.moder().modify(|_, w| w.moder6().input());
                pupdr.pupdr().modify(|_, w| w.pupdr6().floating());
                PF6 { _mode: PhantomData }
            }
            #[doc = " Configures the pin to operate as a pulled down input pin"]
            pub fn into_pull_down_input(
                self,
                moder: &mut MODER,
                pupdr: &mut PUPDR,
            ) -> PF6<Input<PullDown>> {
                moder.moder().modify(|_, w| w.moder6().input());
                pupdr.pupdr().modify(|_, w| w.pupdr6().pull_down());
                PF6 { _mode: PhantomData }
            }
            #[doc = " Configures the pin to operate as a pulled up input pin"]
            pub fn into_pull_up_input(
                self,
                moder: &mut MODER,
                pupdr: &mut PUPDR,
            ) -> PF6<Input<PullUp>> {
                moder.moder().modify(|_, w| w.moder6().input());
                pupdr.pupdr().modify(|_, w| w.pupdr6().pull_up());
                PF6 { _mode: PhantomData }
            }
            #[doc = " Configures the pin to operate as an open drain output pin"]
            pub fn into_open_drain_output(
                self,
                moder: &mut MODER,
                otyper: &mut OTYPER,
            ) -> PF6<Output<OpenDrain>> {
                moder.moder().modify(|_, w| w.moder6().output());
                otyper.otyper().modify(|_, w| w.ot6().open_drain());
                PF6 { _mode: PhantomData }
            }
            #[doc = " Configures the pin to operate as an push pull output pin"]
            pub fn into_push_pull_output(
                self,
                moder: &mut MODER,
                otyper: &mut OTYPER,
            ) -> PF6<Output<PushPull>> {
                moder.moder().modify(|_, w| w.moder6().output());
                otyper.otyper().modify(|_, w| w.ot6().push_pull());
                PF6 { _mode: PhantomData }
            }
            #[doc = " Configures the pin to operate as analog, with disabled schmitt trigger."]
            #[doc = " This mode is suitable when the pin is connected to the DAC or ADC."]
            pub fn into_analog(self, moder: &mut MODER, pupdr: &mut PUPDR) -> PF6<Analog> {
                moder.moder().modify(|_, w| w.moder6().analog());
                pupdr.pupdr().modify(|_, w| w.pupdr6().floating());
                PF6 { _mode: PhantomData }
            }
        }
        impl PF6<Output<OpenDrain>> {
            #[doc = " Enables / disables the internal pull up"]
            pub fn internal_pull_up(&mut self, pupdr: &mut PUPDR, on: bool) {
                pupdr.pupdr().modify(|_, w| {
                    if on {
                        w.pupdr6().pull_up()
                    } else {
                        w.pupdr6().floating()
                    }
                });
            }
        }
        impl<MODE> PF6<Output<MODE>> {
            #[doc = " Erases the pin number from the type"]
            #[doc = ""]
            #[doc = " This is useful when you want to collect the pins into an array where you"]
            #[doc = " need all the elements to have the same type"]
            pub fn downgrade(self) -> PFx<Output<MODE>> {
                PFx {
                    i: 6,
                    _mode: self._mode,
                }
            }
        }
        impl<MODE> PF6<Input<MODE>> {
            #[doc = " Erases the pin number from the type"]
            #[doc = ""]
            #[doc = " This is useful when you want to collect the pins into an array where you"]
            #[doc = " need all the elements to have the same type"]
            pub fn downgrade(self) -> PFx<Input<MODE>> {
                PFx {
                    i: 6,
                    _mode: self._mode,
                }
            }
        }
        impl<MODE> OutputPin for PF6<Output<MODE>> {
            type Error = Infallible;
            fn set_high(&mut self) -> Result<(), Self::Error> {
                unsafe { (*GPIOF::ptr()).bsrr.write(|w| w.bs6().set()) }
                Ok(())
            }
            fn set_low(&mut self) -> Result<(), Self::Error> {
                unsafe { (*GPIOF::ptr()).bsrr.write(|w| w.br6().reset()) }
                Ok(())
            }
        }
        #[cfg(feature = "unproven")]
        impl<MODE> InputPin for PF6<Input<MODE>> {
            type Error = Infallible;
            fn is_high(&self) -> Result<bool, Self::Error> {
                Ok(!self.is_low()?)
            }
            fn is_low(&self) -> Result<bool, Self::Error> {
                Ok(unsafe { (*GPIOF::ptr()).idr.read().idr6().is_low() })
            }
        }
        #[cfg(feature = "unproven")]
        impl InputPin for PF6<Output<OpenDrain>> {
            type Error = Infallible;
            fn is_high(&self) -> Result<bool, Self::Error> {
                Ok(!self.is_low()?)
            }
            fn is_low(&self) -> Result<bool, Self::Error> {
                Ok(unsafe { (*GPIOF::ptr()).idr.read().idr6().is_low() })
            }
        }
        #[cfg(feature = "unproven")]
        impl<MODE> StatefulOutputPin for PF6<Output<MODE>> {
            fn is_set_high(&self) -> Result<bool, Self::Error> {
                self.is_set_low().map(|b| !b)
            }
            fn is_set_low(&self) -> Result<bool, Self::Error> {
                Ok(unsafe { (*GPIOF::ptr()).odr.read().odr6().is_low() })
            }
        }
        #[cfg(feature = "unproven")]
        impl<MODE> toggleable::Default for PF6<Output<MODE>> {}
        #[doc = "Pin `PF9`"]
        pub struct PF9<MODE> {
            _mode: PhantomData<MODE>,
        }
        impl<MODE> PF9<MODE> {
            #[doc = "Configures `PF9` to serve as alternate function: `AF1`"]
            pub fn into_af1(self, moder: &mut MODER, afr: &mut AFRH) -> PF9<AF1> {
                moder.moder().modify(|_, w| w.moder9().alternate());
                afr.afr().modify(|_, w| w.afrh9().af1());
                PF9 { _mode: PhantomData }
            }
            #[doc = "Configures `PF9` to serve as alternate function: `AF3`"]
            pub fn into_af3(self, moder: &mut MODER, afr: &mut AFRH) -> PF9<AF3> {
                moder.moder().modify(|_, w| w.moder9().alternate());
                afr.afr().modify(|_, w| w.afrh9().af3());
                PF9 { _mode: PhantomData }
            }
            #[doc = "Configures `PF9` to serve as alternate function: `AF5`"]
            pub fn into_af5(self, moder: &mut MODER, afr: &mut AFRH) -> PF9<AF5> {
                moder.moder().modify(|_, w| w.moder9().alternate());
                afr.afr().modify(|_, w| w.afrh9().af5());
                PF9 { _mode: PhantomData }
            }
            #[doc = " Configures the pin to operate as a floating input pin"]
            pub fn into_floating_input(
                self,
                moder: &mut MODER,
                pupdr: &mut PUPDR,
            ) -> PF9<Input<Floating>> {
                moder.moder().modify(|_, w| w.moder9().input());
                pupdr.pupdr().modify(|_, w| w.pupdr9().floating());
                PF9 { _mode: PhantomData }
            }
            #[doc = " Configures the pin to operate as a pulled down input pin"]
            pub fn into_pull_down_input(
                self,
                moder: &mut MODER,
                pupdr: &mut PUPDR,
            ) -> PF9<Input<PullDown>> {
                moder.moder().modify(|_, w| w.moder9().input());
                pupdr.pupdr().modify(|_, w| w.pupdr9().pull_down());
                PF9 { _mode: PhantomData }
            }
            #[doc = " Configures the pin to operate as a pulled up input pin"]
            pub fn into_pull_up_input(
                self,
                moder: &mut MODER,
                pupdr: &mut PUPDR,
            ) -> PF9<Input<PullUp>> {
                moder.moder().modify(|_, w| w.moder9().input());
                pupdr.pupdr().modify(|_, w| w.pupdr9().pull_up());
                PF9 { _mode: PhantomData }
            }
            #[doc = " Configures the pin to operate as an open drain output pin"]
            pub fn into_open_drain_output(
                self,
                moder: &mut MODER,
                otyper: &mut OTYPER,
            ) -> PF9<Output<OpenDrain>> {
                moder.moder().modify(|_, w| w.moder9().output());
                otyper.otyper().modify(|_, w| w.ot9().open_drain());
                PF9 { _mode: PhantomData }
            }
            #[doc = " Configures the pin to operate as an push pull output pin"]
            pub fn into_push_pull_output(
                self,
                moder: &mut MODER,
                otyper: &mut OTYPER,
            ) -> PF9<Output<PushPull>> {
                moder.moder().modify(|_, w| w.moder9().output());
                otyper.otyper().modify(|_, w| w.ot9().push_pull());
                PF9 { _mode: PhantomData }
            }
            #[doc = " Configures the pin to operate as analog, with disabled schmitt trigger."]
            #[doc = " This mode is suitable when the pin is connected to the DAC or ADC."]
            pub fn into_analog(self, moder: &mut MODER, pupdr: &mut PUPDR) -> PF9<Analog> {
                moder.moder().modify(|_, w| w.moder9().analog());
                pupdr.pupdr().modify(|_, w| w.pupdr9().floating());
                PF9 { _mode: PhantomData }
            }
        }
        impl PF9<Output<OpenDrain>> {
            #[doc = " Enables / disables the internal pull up"]
            pub fn internal_pull_up(&mut self, pupdr: &mut PUPDR, on: bool) {
                pupdr.pupdr().modify(|_, w| {
                    if on {
                        w.pupdr9().pull_up()
                    } else {
                        w.pupdr9().floating()
                    }
                });
            }
        }
        impl<MODE> PF9<Output<MODE>> {
            #[doc = " Erases the pin number from the type"]
            #[doc = ""]
            #[doc = " This is useful when you want to collect the pins into an array where you"]
            #[doc = " need all the elements to have the same type"]
            pub fn downgrade(self) -> PFx<Output<MODE>> {
                PFx {
                    i: 9,
                    _mode: self._mode,
                }
            }
        }
        impl<MODE> PF9<Input<MODE>> {
            #[doc = " Erases the pin number from the type"]
            #[doc = ""]
            #[doc = " This is useful when you want to collect the pins into an array where you"]
            #[doc = " need all the elements to have the same type"]
            pub fn downgrade(self) -> PFx<Input<MODE>> {
                PFx {
                    i: 9,
                    _mode: self._mode,
                }
            }
        }
        impl<MODE> OutputPin for PF9<Output<MODE>> {
            type Error = Infallible;
            fn set_high(&mut self) -> Result<(), Self::Error> {
                unsafe { (*GPIOF::ptr()).bsrr.write(|w| w.bs9().set()) }
                Ok(())
            }
            fn set_low(&mut self) -> Result<(), Self::Error> {
                unsafe { (*GPIOF::ptr()).bsrr.write(|w| w.br9().reset()) }
                Ok(())
            }
        }
        #[cfg(feature = "unproven")]
        impl<MODE> InputPin for PF9<Input<MODE>> {
            type Error = Infallible;
            fn is_high(&self) -> Result<bool, Self::Error> {
                Ok(!self.is_low()?)
            }
            fn is_low(&self) -> Result<bool, Self::Error> {
                Ok(unsafe { (*GPIOF::ptr()).idr.read().idr9().is_low() })
            }
        }
        #[cfg(feature = "unproven")]
        impl InputPin for PF9<Output<OpenDrain>> {
            type Error = Infallible;
            fn is_high(&self) -> Result<bool, Self::Error> {
                Ok(!self.is_low()?)
            }
            fn is_low(&self) -> Result<bool, Self::Error> {
                Ok(unsafe { (*GPIOF::ptr()).idr.read().idr9().is_low() })
            }
        }
        #[cfg(feature = "unproven")]
        impl<MODE> StatefulOutputPin for PF9<Output<MODE>> {
            fn is_set_high(&self) -> Result<bool, Self::Error> {
                self.is_set_low().map(|b| !b)
            }
            fn is_set_low(&self) -> Result<bool, Self::Error> {
                Ok(unsafe { (*GPIOF::ptr()).odr.read().odr9().is_low() })
            }
        }
        #[cfg(feature = "unproven")]
        impl<MODE> toggleable::Default for PF9<Output<MODE>> {}
        #[doc = "Pin `PF10`"]
        pub struct PF10<MODE> {
            _mode: PhantomData<MODE>,
        }
        impl<MODE> PF10<MODE> {
            #[doc = "Configures `PF10` to serve as alternate function: `AF1`"]
            pub fn into_af1(self, moder: &mut MODER, afr: &mut AFRH) -> PF10<AF1> {
                moder.moder().modify(|_, w| w.moder10().alternate());
                afr.afr().modify(|_, w| w.afrh10().af1());
                PF10 { _mode: PhantomData }
            }
            #[doc = "Configures `PF10` to serve as alternate function: `AF3`"]
            pub fn into_af3(self, moder: &mut MODER, afr: &mut AFRH) -> PF10<AF3> {
                moder.moder().modify(|_, w| w.moder10().alternate());
                afr.afr().modify(|_, w| w.afrh10().af3());
                PF10 { _mode: PhantomData }
            }
            #[doc = "Configures `PF10` to serve as alternate function: `AF5`"]
            pub fn into_af5(self, moder: &mut MODER, afr: &mut AFRH) -> PF10<AF5> {
                moder.moder().modify(|_, w| w.moder10().alternate());
                afr.afr().modify(|_, w| w.afrh10().af5());
                PF10 { _mode: PhantomData }
            }
            #[doc = " Configures the pin to operate as a floating input pin"]
            pub fn into_floating_input(
                self,
                moder: &mut MODER,
                pupdr: &mut PUPDR,
            ) -> PF10<Input<Floating>> {
                moder.moder().modify(|_, w| w.moder10().input());
                pupdr.pupdr().modify(|_, w| w.pupdr10().floating());
                PF10 { _mode: PhantomData }
            }
            #[doc = " Configures the pin to operate as a pulled down input pin"]
            pub fn into_pull_down_input(
                self,
                moder: &mut MODER,
                pupdr: &mut PUPDR,
            ) -> PF10<Input<PullDown>> {
                moder.moder().modify(|_, w| w.moder10().input());
                pupdr.pupdr().modify(|_, w| w.pupdr10().pull_down());
                PF10 { _mode: PhantomData }
            }
            #[doc = " Configures the pin to operate as a pulled up input pin"]
            pub fn into_pull_up_input(
                self,
                moder: &mut MODER,
                pupdr: &mut PUPDR,
            ) -> PF10<Input<PullUp>> {
                moder.moder().modify(|_, w| w.moder10().input());
                pupdr.pupdr().modify(|_, w| w.pupdr10().pull_up());
                PF10 { _mode: PhantomData }
            }
            #[doc = " Configures the pin to operate as an open drain output pin"]
            pub fn into_open_drain_output(
                self,
                moder: &mut MODER,
                otyper: &mut OTYPER,
            ) -> PF10<Output<OpenDrain>> {
                moder.moder().modify(|_, w| w.moder10().output());
                otyper.otyper().modify(|_, w| w.ot10().open_drain());
                PF10 { _mode: PhantomData }
            }
            #[doc = " Configures the pin to operate as an push pull output pin"]
            pub fn into_push_pull_output(
                self,
                moder: &mut MODER,
                otyper: &mut OTYPER,
            ) -> PF10<Output<PushPull>> {
                moder.moder().modify(|_, w| w.moder10().output());
                otyper.otyper().modify(|_, w| w.ot10().push_pull());
                PF10 { _mode: PhantomData }
            }
            #[doc = " Configures the pin to operate as analog, with disabled schmitt trigger."]
            #[doc = " This mode is suitable when the pin is connected to the DAC or ADC."]
            pub fn into_analog(self, moder: &mut MODER, pupdr: &mut PUPDR) -> PF10<Analog> {
                moder.moder().modify(|_, w| w.moder10().analog());
                pupdr.pupdr().modify(|_, w| w.pupdr10().floating());
                PF10 { _mode: PhantomData }
            }
        }
        impl PF10<Output<OpenDrain>> {
            #[doc = " Enables / disables the internal pull up"]
            pub fn internal_pull_up(&mut self, pupdr: &mut PUPDR, on: bool) {
                pupdr.pupdr().modify(|_, w| {
                    if on {
                        w.pupdr10().pull_up()
                    } else {
                        w.pupdr10().floating()
                    }
                });
            }
        }
        impl<MODE> PF10<Output<MODE>> {
            #[doc = " Erases the pin number from the type"]
            #[doc = ""]
            #[doc = " This is useful when you want to collect the pins into an array where you"]
            #[doc = " need all the elements to have the same type"]
            pub fn downgrade(self) -> PFx<Output<MODE>> {
                PFx {
                    i: 10,
                    _mode: self._mode,
                }
            }
        }
        impl<MODE> PF10<Input<MODE>> {
            #[doc = " Erases the pin number from the type"]
            #[doc = ""]
            #[doc = " This is useful when you want to collect the pins into an array where you"]
            #[doc = " need all the elements to have the same type"]
            pub fn downgrade(self) -> PFx<Input<MODE>> {
                PFx {
                    i: 10,
                    _mode: self._mode,
                }
            }
        }
        impl<MODE> OutputPin for PF10<Output<MODE>> {
            type Error = Infallible;
            fn set_high(&mut self) -> Result<(), Self::Error> {
                unsafe { (*GPIOF::ptr()).bsrr.write(|w| w.bs10().set()) }
                Ok(())
            }
            fn set_low(&mut self) -> Result<(), Self::Error> {
                unsafe { (*GPIOF::ptr()).bsrr.write(|w| w.br10().reset()) }
                Ok(())
            }
        }
        #[cfg(feature = "unproven")]
        impl<MODE> InputPin for PF10<Input<MODE>> {
            type Error = Infallible;
            fn is_high(&self) -> Result<bool, Self::Error> {
                Ok(!self.is_low()?)
            }
            fn is_low(&self) -> Result<bool, Self::Error> {
                Ok(unsafe { (*GPIOF::ptr()).idr.read().idr10().is_low() })
            }
        }
        #[cfg(feature = "unproven")]
        impl InputPin for PF10<Output<OpenDrain>> {
            type Error = Infallible;
            fn is_high(&self) -> Result<bool, Self::Error> {
                Ok(!self.is_low()?)
            }
            fn is_low(&self) -> Result<bool, Self::Error> {
                Ok(unsafe { (*GPIOF::ptr()).idr.read().idr10().is_low() })
            }
        }
        #[cfg(feature = "unproven")]
        impl<MODE> StatefulOutputPin for PF10<Output<MODE>> {
            fn is_set_high(&self) -> Result<bool, Self::Error> {
                self.is_set_low().map(|b| !b)
            }
            fn is_set_low(&self) -> Result<bool, Self::Error> {
                Ok(unsafe { (*GPIOF::ptr()).odr.read().odr10().is_low() })
            }
        }
        #[cfg(feature = "unproven")]
        impl<MODE> toggleable::Default for PF10<Output<MODE>> {}
    }
}
pub mod i2c {
    #![doc = " Inter-Integrated Circuit (I2C) bus"]
    #![doc = ""]
    #![doc = " A usage example of the i2c peripheral can be found at [examples/i2c_scanner.rs]"]
    #![doc = ""]
    #![doc = " [examples/i2c_scanner.rs]: https://github.com/stm32-rs/stm32f3xx-hal/blob/v0.6.0/examples/i2c_scanner.rs"]
    use core::convert::TryFrom;
    use core::ops::Deref;
    use crate::{
        gpio::{gpioa, gpiob, AF4},
        hal::blocking::i2c::{Read, Write, WriteRead},
        pac::{i2c1::RegisterBlock, rcc::cfgr3::I2C1SW_A, I2C1, RCC},
        rcc::{Clocks, APB1},
        time::{Hertz, U32Ext},
    };
    #[cfg(not(feature = "gpio-f333"))]
    use crate::{gpio::gpiof, pac::I2C2};
    use cfg_if::cfg_if;
    #[doc = " I2C error"]
    #[non_exhaustive]
    pub enum Error {
        #[doc = " Arbitration loss"]
        Arbitration,
        #[doc = " Bus error"]
        Bus,
        #[doc = " Bus busy"]
        Busy,
        #[doc = " Not Acknowledge received"]
        Nack,
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::fmt::Debug for Error {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            match (&*self,) {
                (&Error::Arbitration,) => {
                    let mut debug_trait_builder = f.debug_tuple("Arbitration");
                    debug_trait_builder.finish()
                }
                (&Error::Bus,) => {
                    let mut debug_trait_builder = f.debug_tuple("Bus");
                    debug_trait_builder.finish()
                }
                (&Error::Busy,) => {
                    let mut debug_trait_builder = f.debug_tuple("Busy");
                    debug_trait_builder.finish()
                }
                (&Error::Nack,) => {
                    let mut debug_trait_builder = f.debug_tuple("Nack");
                    debug_trait_builder.finish()
                }
            }
        }
    }
    #[doc = " SCL pin -- DO NOT IMPLEMENT THIS TRAIT"]
    pub unsafe trait SclPin<I2C> {}
    #[doc = " SDA pin -- DO NOT IMPLEMENT THIS TRAIT"]
    pub unsafe trait SdaPin<I2C> {}
    unsafe impl SclPin<I2C1> for gpioa::PA15<AF4> {}
    unsafe impl SclPin<I2C1> for gpiob::PB6<AF4> {}
    unsafe impl SclPin<I2C1> for gpiob::PB8<AF4> {}
    unsafe impl SdaPin<I2C1> for gpioa::PA14<AF4> {}
    unsafe impl SdaPin<I2C1> for gpiob::PB7<AF4> {}
    unsafe impl SdaPin<I2C1> for gpiob::PB9<AF4> {}
    unsafe impl SclPin<I2C2> for gpioa::PA9<AF4> {}
    unsafe impl SclPin<I2C2> for gpiof::PF1<AF4> {}
    #[cfg(any(feature = "gpio-f303", feature = "gpio-f303e", feature = "gpio-f373"))]
    unsafe impl SclPin<I2C2> for gpiof::PF6<AF4> {}
    unsafe impl SdaPin<I2C2> for gpioa::PA10<AF4> {}
    unsafe impl SdaPin<I2C2> for gpiof::PF0<AF4> {}
    #[doc = " I2C peripheral operating in master mode"]
    pub struct I2c<I2C, PINS> {
        i2c: I2C,
        pins: PINS,
    }
    impl<I2C, SCL, SDA> I2c<I2C, (SCL, SDA)> {
        #[doc = " Configures the I2C peripheral to work in master mode"]
        pub fn new<F>(i2c: I2C, pins: (SCL, SDA), freq: F, clocks: Clocks, apb1: &mut APB1) -> Self
        where
            I2C: Instance,
            SCL: SclPin<I2C>,
            SDA: SdaPin<I2C>,
            F: Into<Hertz>,
        {
            let freq = freq.into().0;
            if !(freq <= 1_000_000) {
                ::core::panicking::panic("assertion failed: freq <= 1_000_000")
            };
            I2C::enable_clock(apb1);
            let i2cclk = I2C::clock(&clocks).0;
            let ratio = i2cclk / freq - 4;
            let (presc, scll, sclh, sdadel, scldel) = if freq >= 100_000 {
                let presc = ratio / 387;
                let sclh = ((ratio / (presc + 1)) - 3) / 3;
                let scll = 2 * (sclh + 1) - 1;
                let (sdadel, scldel) = if freq > 400_000 {
                    let sdadel = 0;
                    let scldel = i2cclk / 4_000_000 / (presc + 1) - 1;
                    (sdadel, scldel)
                } else {
                    let sdadel = i2cclk / 8_000_000 / (presc + 1);
                    let scldel = i2cclk / 2_000_000 / (presc + 1) - 1;
                    (sdadel, scldel)
                };
                (presc, scll, sclh, sdadel, scldel)
            } else {
                let presc = ratio / 514;
                let sclh = ((ratio / (presc + 1)) - 2) / 2;
                let scll = sclh;
                let sdadel = i2cclk / 2_000_000 / (presc + 1);
                let scldel = i2cclk / 800_000 / (presc + 1) - 1;
                (presc, scll, sclh, sdadel, scldel)
            };
            if !(presc < 16) {
                ::core::panicking::panic("assertion failed: presc < 16")
            };
            if !(scldel < 16) {
                ::core::panicking::panic("assertion failed: scldel < 16")
            };
            if !(sdadel < 16) {
                ::core::panicking::panic("assertion failed: sdadel < 16")
            };
            let sclh = u8::try_from(sclh).ok().unwrap();
            let scll = u8::try_from(scll).ok().unwrap();
            i2c.timingr.write(|w| {
                w.presc()
                    .bits(presc as u8)
                    .sdadel()
                    .bits(sdadel as u8)
                    .scldel()
                    .bits(scldel as u8)
                    .scll()
                    .bits(scll)
                    .sclh()
                    .bits(sclh)
            });
            i2c.cr1.modify(|_, w| w.pe().set_bit());
            Self { i2c, pins }
        }
        #[doc = " Releases the I2C peripheral and associated pins"]
        pub fn free(self) -> (I2C, (SCL, SDA)) {
            (self.i2c, self.pins)
        }
    }
    impl<I2C, PINS> Read for I2c<I2C, PINS>
    where
        I2C: Instance,
    {
        type Error = Error;
        fn read(&mut self, addr: u8, buffer: &mut [u8]) -> Result<(), Self::Error> {
            if !!buffer.is_empty() {
                ::core::panicking::panic("assertion failed: !buffer.is_empty()")
            };
            if self.i2c.isr.read().busy().is_busy() {
                return Err(Error::Busy);
            }
            let end = buffer.len() / 0xFF;
            for (i, buffer) in buffer.chunks_mut(0xFF).enumerate() {
                self.i2c.cr2.modify(|_, w| {
                    if i == 0 {
                        w.add10().bit7();
                        w.sadd().bits((addr << 1) as u16);
                        w.rd_wrn().read();
                        w.start().start();
                    }
                    w.nbytes().bits(buffer.len() as u8);
                    if i != end {
                        w.reload().not_completed()
                    } else {
                        w.reload().completed().autoend().automatic()
                    }
                });
                for byte in buffer {
                    loop {
                        let isr = self.i2c.isr.read();
                        let icr = &self.i2c.icr;
                        if isr.arlo().is_lost() {
                            icr.write(|w| w.arlocf().clear());
                            return Err(Error::Arbitration);
                        } else if isr.berr().is_error() {
                            icr.write(|w| w.berrcf().clear());
                            return Err(Error::Bus);
                        } else if isr.nackf().is_nack() {
                            while self.i2c.isr.read().stopf().is_no_stop() {}
                            icr.write(|w| w.nackcf().clear());
                            icr.write(|w| w.stopcf().clear());
                            return Err(Error::Nack);
                        } else if isr.rxne().is_not_empty() {
                            break;
                        }
                    }
                    *byte = self.i2c.rxdr.read().rxdata().bits();
                }
                if i != end {
                    loop {
                        let isr = self.i2c.isr.read();
                        let icr = &self.i2c.icr;
                        if isr.arlo().is_lost() {
                            icr.write(|w| w.arlocf().clear());
                            return Err(Error::Arbitration);
                        } else if isr.berr().is_error() {
                            icr.write(|w| w.berrcf().clear());
                            return Err(Error::Bus);
                        } else if isr.nackf().is_nack() {
                            while self.i2c.isr.read().stopf().is_no_stop() {}
                            icr.write(|w| w.nackcf().clear());
                            icr.write(|w| w.stopcf().clear());
                            return Err(Error::Nack);
                        } else if isr.tcr().is_complete() {
                            break;
                        }
                    }
                }
            }
            loop {
                let isr = self.i2c.isr.read();
                let icr = &self.i2c.icr;
                if isr.arlo().is_lost() {
                    icr.write(|w| w.arlocf().clear());
                    return Err(Error::Arbitration);
                } else if isr.berr().is_error() {
                    icr.write(|w| w.berrcf().clear());
                    return Err(Error::Bus);
                } else if isr.nackf().is_nack() {
                    while self.i2c.isr.read().stopf().is_no_stop() {}
                    icr.write(|w| w.nackcf().clear());
                    icr.write(|w| w.stopcf().clear());
                    return Err(Error::Nack);
                } else if isr.stopf().is_stop() {
                    break;
                }
            }
            self.i2c.icr.write(|w| w.stopcf().clear());
            Ok(())
        }
    }
    impl<I2C, PINS> Write for I2c<I2C, PINS>
    where
        I2C: Instance,
    {
        type Error = Error;
        fn write(&mut self, addr: u8, bytes: &[u8]) -> Result<(), Error> {
            if self.i2c.isr.read().busy().is_busy() {
                return Err(Error::Busy);
            }
            if bytes.is_empty() {
                self.i2c.cr2.modify(|_, w| {
                    w.add10().bit7();
                    w.sadd().bits((addr << 1) as u16);
                    w.rd_wrn().write();
                    w.nbytes().bits(0);
                    w.reload().completed();
                    w.autoend().automatic();
                    w.start().start()
                });
            } else {
                let end = bytes.len() / 0xFF;
                for (i, bytes) in bytes.chunks(0xFF).enumerate() {
                    self.i2c.cr2.modify(|_, w| {
                        if i == 0 {
                            w.add10().bit7();
                            w.sadd().bits((addr << 1) as u16);
                            w.rd_wrn().write();
                            w.start().start();
                        }
                        w.nbytes().bits(bytes.len() as u8);
                        if i != end {
                            w.reload().not_completed()
                        } else {
                            w.reload().completed().autoend().automatic()
                        }
                    });
                    for byte in bytes {
                        loop {
                            let isr = self.i2c.isr.read();
                            let icr = &self.i2c.icr;
                            if isr.arlo().is_lost() {
                                icr.write(|w| w.arlocf().clear());
                                return Err(Error::Arbitration);
                            } else if isr.berr().is_error() {
                                icr.write(|w| w.berrcf().clear());
                                return Err(Error::Bus);
                            } else if isr.nackf().is_nack() {
                                while self.i2c.isr.read().stopf().is_no_stop() {}
                                icr.write(|w| w.nackcf().clear());
                                icr.write(|w| w.stopcf().clear());
                                return Err(Error::Nack);
                            } else if isr.txis().is_empty() {
                                break;
                            }
                        }
                        self.i2c.txdr.write(|w| w.txdata().bits(*byte));
                    }
                    if i != end {
                        loop {
                            let isr = self.i2c.isr.read();
                            let icr = &self.i2c.icr;
                            if isr.arlo().is_lost() {
                                icr.write(|w| w.arlocf().clear());
                                return Err(Error::Arbitration);
                            } else if isr.berr().is_error() {
                                icr.write(|w| w.berrcf().clear());
                                return Err(Error::Bus);
                            } else if isr.nackf().is_nack() {
                                while self.i2c.isr.read().stopf().is_no_stop() {}
                                icr.write(|w| w.nackcf().clear());
                                icr.write(|w| w.stopcf().clear());
                                return Err(Error::Nack);
                            } else if isr.tcr().is_complete() {
                                break;
                            }
                        }
                    }
                }
            }
            loop {
                let isr = self.i2c.isr.read();
                let icr = &self.i2c.icr;
                if isr.arlo().is_lost() {
                    icr.write(|w| w.arlocf().clear());
                    return Err(Error::Arbitration);
                } else if isr.berr().is_error() {
                    icr.write(|w| w.berrcf().clear());
                    return Err(Error::Bus);
                } else if isr.nackf().is_nack() {
                    while self.i2c.isr.read().stopf().is_no_stop() {}
                    icr.write(|w| w.nackcf().clear());
                    icr.write(|w| w.stopcf().clear());
                    return Err(Error::Nack);
                } else if isr.stopf().is_stop() {
                    break;
                }
            }
            self.i2c.icr.write(|w| w.stopcf().clear());
            Ok(())
        }
    }
    impl<I2C, PINS> WriteRead for I2c<I2C, PINS>
    where
        I2C: Instance,
    {
        type Error = Error;
        fn write_read(&mut self, addr: u8, bytes: &[u8], buffer: &mut [u8]) -> Result<(), Error> {
            if !(!bytes.is_empty() && !buffer.is_empty()) {
                ::core::panicking::panic(
                    "assertion failed: !bytes.is_empty() && !buffer.is_empty()",
                )
            };
            if self.i2c.isr.read().busy().is_busy() {
                return Err(Error::Busy);
            }
            let end = bytes.len() / 0xFF;
            for (i, bytes) in bytes.chunks(0xFF).enumerate() {
                self.i2c.cr2.modify(|_, w| {
                    if i == 0 {
                        w.add10().bit7();
                        w.sadd().bits((addr << 1) as u16);
                        w.rd_wrn().write();
                        w.start().start();
                    }
                    w.nbytes().bits(bytes.len() as u8);
                    if i != end {
                        w.reload().not_completed()
                    } else {
                        w.reload().completed().autoend().software()
                    }
                });
                for byte in bytes {
                    loop {
                        let isr = self.i2c.isr.read();
                        let icr = &self.i2c.icr;
                        if isr.arlo().is_lost() {
                            icr.write(|w| w.arlocf().clear());
                            return Err(Error::Arbitration);
                        } else if isr.berr().is_error() {
                            icr.write(|w| w.berrcf().clear());
                            return Err(Error::Bus);
                        } else if isr.nackf().is_nack() {
                            while self.i2c.isr.read().stopf().is_no_stop() {}
                            icr.write(|w| w.nackcf().clear());
                            icr.write(|w| w.stopcf().clear());
                            return Err(Error::Nack);
                        } else if isr.txis().is_empty() {
                            break;
                        }
                    }
                    self.i2c.txdr.write(|w| w.txdata().bits(*byte));
                }
                if i != end {
                    loop {
                        let isr = self.i2c.isr.read();
                        let icr = &self.i2c.icr;
                        if isr.arlo().is_lost() {
                            icr.write(|w| w.arlocf().clear());
                            return Err(Error::Arbitration);
                        } else if isr.berr().is_error() {
                            icr.write(|w| w.berrcf().clear());
                            return Err(Error::Bus);
                        } else if isr.nackf().is_nack() {
                            while self.i2c.isr.read().stopf().is_no_stop() {}
                            icr.write(|w| w.nackcf().clear());
                            icr.write(|w| w.stopcf().clear());
                            return Err(Error::Nack);
                        } else if isr.tcr().is_complete() {
                            break;
                        }
                    }
                }
            }
            loop {
                let isr = self.i2c.isr.read();
                let icr = &self.i2c.icr;
                if isr.arlo().is_lost() {
                    icr.write(|w| w.arlocf().clear());
                    return Err(Error::Arbitration);
                } else if isr.berr().is_error() {
                    icr.write(|w| w.berrcf().clear());
                    return Err(Error::Bus);
                } else if isr.nackf().is_nack() {
                    while self.i2c.isr.read().stopf().is_no_stop() {}
                    icr.write(|w| w.nackcf().clear());
                    icr.write(|w| w.stopcf().clear());
                    return Err(Error::Nack);
                } else if isr.tc().is_complete() {
                    break;
                }
            }
            let end = buffer.len() / 0xFF;
            for (i, buffer) in buffer.chunks_mut(0xFF).enumerate() {
                self.i2c.cr2.modify(|_, w| {
                    if i == 0 {
                        w.add10().bit7();
                        w.sadd().bits((addr << 1) as u16);
                        w.rd_wrn().read();
                        w.start().start();
                    }
                    w.nbytes().bits(buffer.len() as u8);
                    if i != end {
                        w.reload().not_completed()
                    } else {
                        w.reload().completed().autoend().automatic()
                    }
                });
                for byte in buffer {
                    loop {
                        let isr = self.i2c.isr.read();
                        let icr = &self.i2c.icr;
                        if isr.arlo().is_lost() {
                            icr.write(|w| w.arlocf().clear());
                            return Err(Error::Arbitration);
                        } else if isr.berr().is_error() {
                            icr.write(|w| w.berrcf().clear());
                            return Err(Error::Bus);
                        } else if isr.nackf().is_nack() {
                            while self.i2c.isr.read().stopf().is_no_stop() {}
                            icr.write(|w| w.nackcf().clear());
                            icr.write(|w| w.stopcf().clear());
                            return Err(Error::Nack);
                        } else if isr.rxne().is_not_empty() {
                            break;
                        }
                    }
                    *byte = self.i2c.rxdr.read().rxdata().bits();
                }
                if i != end {
                    loop {
                        let isr = self.i2c.isr.read();
                        let icr = &self.i2c.icr;
                        if isr.arlo().is_lost() {
                            icr.write(|w| w.arlocf().clear());
                            return Err(Error::Arbitration);
                        } else if isr.berr().is_error() {
                            icr.write(|w| w.berrcf().clear());
                            return Err(Error::Bus);
                        } else if isr.nackf().is_nack() {
                            while self.i2c.isr.read().stopf().is_no_stop() {}
                            icr.write(|w| w.nackcf().clear());
                            icr.write(|w| w.stopcf().clear());
                            return Err(Error::Nack);
                        } else if isr.tcr().is_complete() {
                            break;
                        }
                    }
                }
            }
            loop {
                let isr = self.i2c.isr.read();
                let icr = &self.i2c.icr;
                if isr.arlo().is_lost() {
                    icr.write(|w| w.arlocf().clear());
                    return Err(Error::Arbitration);
                } else if isr.berr().is_error() {
                    icr.write(|w| w.berrcf().clear());
                    return Err(Error::Bus);
                } else if isr.nackf().is_nack() {
                    while self.i2c.isr.read().stopf().is_no_stop() {}
                    icr.write(|w| w.nackcf().clear());
                    icr.write(|w| w.stopcf().clear());
                    return Err(Error::Nack);
                } else if isr.stopf().is_stop() {
                    break;
                }
            }
            self.i2c.icr.write(|w| w.stopcf().clear());
            Ok(())
        }
    }
    #[doc = " I2C instance -- DO NOT IMPLEMENT THIS TRAIT"]
    pub unsafe trait Instance: Deref<Target = RegisterBlock> {
        #[doc(hidden)]
        fn enable_clock(apb1: &mut APB1);
        #[doc(hidden)]
        fn clock(clocks: &Clocks) -> Hertz;
    }
    unsafe impl Instance for I2C1 {
        fn enable_clock(apb1: &mut APB1) {
            apb1.enr().modify(|_, w| w.i2c1en().enabled());
            apb1.rstr().modify(|_, w| w.i2c1rst().reset());
            apb1.rstr().modify(|_, w| w.i2c1rst().clear_bit());
        }
        fn clock(clocks: &Clocks) -> Hertz {
            match unsafe { (*RCC::ptr()).cfgr3.read().i2c1sw().variant() } {
                I2C1SW_A::HSI => 8.mhz().into(),
                I2C1SW_A::SYSCLK => clocks.sysclk(),
            }
        }
    }
    unsafe impl Instance for I2C2 {
        fn enable_clock(apb1: &mut APB1) {
            apb1.enr().modify(|_, w| w.i2c2en().enabled());
            apb1.rstr().modify(|_, w| w.i2c2rst().reset());
            apb1.rstr().modify(|_, w| w.i2c2rst().clear_bit());
        }
        fn clock(clocks: &Clocks) -> Hertz {
            match unsafe { (*RCC::ptr()).cfgr3.read().i2c2sw().variant() } {
                I2C1SW_A::HSI => 8.mhz().into(),
                I2C1SW_A::SYSCLK => clocks.sysclk(),
            }
        }
    }
}
pub mod prelude {
    #![doc = " Prelude"]
    #[cfg(any(feature = "stm32f302", feature = "stm32f303"))]
    pub use crate::dma::DmaExt as _stm32f3xx_hal_dma_DmaExt;
    pub use crate::flash::FlashExt as _stm32f3xx_hal_flash_FlashExt;
    pub use crate::gpio::GpioExt as _stm32f3xx_hal_gpio_GpioExt;
    pub use crate::hal::prelude::*;
    pub use crate::rcc::RccExt as _stm32f3xx_hal_rcc_RccExt;
    pub use crate::time::U32Ext as _stm32f3xx_hal_time_U32Ext;
    #[cfg(feature = "unproven")]
    pub use crate::{
        hal::digital::v2::InputPin as _embedded_hal_digital_InputPin,
        hal::digital::v2::OutputPin as _embedded_hal_digital_OutputPin,
        hal::digital::v2::StatefulOutputPin as _embedded_hal_digital_StatefulOutputPin,
        hal::digital::v2::ToggleableOutputPin as _embedded_hal_digital_ToggleableOutputPin,
    };
}
pub mod pwm {
    #![doc = "\n  # Pulse width modulation\n\n  Numerous stm32 timers can be used to output pulse width modulated\n  signals on a variety of pins.  The timers support up to 4\n  simultaneous pwm outputs in separate `Channels`.  These channels\n  share a period and resolution, but can have a different duty cycle.\n  All pins on a shared channel have the exact same output.\n\n  ## Creating the (unconfigured) channels\n\n  Before we connect any pins, we need to convert our timer peripheral\n  into a set of channels.  We may only be interested in using one or\n  two of these channels, so we can simply ignore them with `_` when we\n  destructure.\n\n  ```\n    // (Other imports omitted)\n    use stm32f3xx-hal::pwm::tim3;\n\n    let dp = stm32f303::Peripherals::take().unwrap();\n\n    let mut flash = dp.FLASH.constrain();\n    let mut rcc = dp.RCC.constrain();\n    let clocks = rcc.cfgr.freeze(&mut flash.acr);\n\n    // Set the resolution of our duty cycle to 9000 and our period to\n    // 50hz.\n    let mut (c1_no_pins, _, _, c4_no_pins) =\n        tim3(device.TIM3, 9000, 50.hz(), clocks);\n  ```\n\n  In this case, we're only going to use channel 1 and channel 4.\n  Currently we can't enable these timers, because they don't have any\n  pins, so the following wouldn't compile.\n\n\n  ```\n    // DOES NOT COMPILE\n    c1_no_pins.enable();\n    c4_no_pins.enable();\n  ```\n\n  ## Connecting our pins and enabling the channels\n\n  From here we can connect as many compatible pins as we like.  Once\n  the channels have pins connected they can be enabled.\n\n  ```\n    let mut gpioa = dp.GPIOB.split(&mut rcc.ahb);\n    let pa6 = gpioa.pa6.into_af2(&mut gpioa.moder, &mut gpioa.afrl);\n\n    let mut gpiob = dp.GPIOB.split(&mut rcc.ahb);\n    let pb1 = gpiob.pb1.into_af2(&mut gpiob.moder, &mut gpiob.afrl);\n    let pb4 = gpiob.pb4.into_af2(&mut gpiob.moder, &mut gpiob.afrl);\n\n    let mut ch1 = ch1_no_pins\n        .output_to_pa6(pa6)\n        .output_to_pb4(pb4);\n\n    let mut ch4 = ch4_no_pins\n        .output_to_pb1(pb1);\n\n    ch1.enable();\n    ch4.enable();\n  ```\n\n  All three pins will output a 50hz period. PA6 and PB4 will share a\n  duty cycle, but the duty cycle for PB1 can be controlled\n  independently.\n\n  ```\n    // Affect PA6 and PB4\n    ch1.set_duty_cycle(1000);\n\n    // Affect only PB1\n    ch4.set_duty_cycle(2000);\n  ```\n\n  ## Single channel timers\n\n  Timers that only have only one channel do not return a tuple, and\n  instead return the (unconfigured) channel directly.\n\n  ```\n    // (Other imports omitted)\n    use stm32f3xx-hal::pwm::tim16;\n\n    let dp = stm32f303::Peripherals::take().unwrap();\n\n    let mut flash = dp.FLASH.constrain();\n    let mut rcc = dp.RCC.constrain();\n    let clocks = rcc.cfgr.freeze(&mut flash.acr);\n\n    // Set the resolution of our duty cycle to 9000 and our period to\n    // 50hz.\n    let mut c1_no_pins = tim16(device.TIM3, 9000, 50.hz(), clocks);\n  ```\n\n  ## Complementary timers\n\n  Certain timers have complementary outputs.  Currently, channels can\n  output to _either_ pins used for standard or complementary pins (and\n  do not exhibit complementary behaviors).  Most of the time this will\n  be totally invisible.\n\n  In this example, we use a complementary pin in the same way we'd use\n  any other pwm channel.\n\n  ```\n    // (Other imports omitted)\n    use stm32f3xx-hal::pwm::tim1;\n\n    let dp = stm32f303::Peripherals::take().unwrap();\n\n    let mut flash = dp.FLASH.constrain();\n    let mut rcc = dp.RCC.constrain();\n    let clocks = rcc.cfgr.freeze(&mut flash.acr);\n\n    // Set the resolution of our duty cycle to 9000 and our period to\n    // 50hz.\n    let mut (ch1_no_pins, _, _, _) = tim1(device.TIM3, 9000, 50.hz(), clocks);\n\n    let mut gpioa = dp.GPIOB.split(&mut rcc.ahb);\n    let pa7 = gpioa.pa7.into_af6(&mut gpioa.moder, &mut gpioa.afrl);\n\n    let mut ch1 = ch1_no_pins.output_to(pa7);\n    ch1.enable();\n  ```\n\n  We used this channel/pin exactly like any previous example.\n\n  However, we cannot use standard and complementary pins\n  simultaneously.  Luckily, typestates enforce this for us.\n\n  ```\n    ...\n\n    let mut gpioa = dp.GPIOB.split(&mut rcc.ahb);\n    let pa7 = gpioa.pa7.into_af6(&mut gpioa.moder, &mut gpioa.afrl);\n    let pa8 = gpioa.pa8.into_af6(&mut gpioa.moder, &mut gpioa.afrl);\n\n    let mut ch1 = ch1_no_pins\n        .output_to(pa7)\n        // DOES NOT COMPILE\n        .output_to(pa8);\n  ```\n\n  Once we've connected a complementary pin (PA7) we are now _only_\n  allowed to use other complementary pins.  PA8 is a valid choice if\n  we have no pins in use, but it cannot be used once we've used PA7.\n\n  A usage example can be found at [examples/pwm.rs]\n\n  [examples/pwm.rs]: https://github.com/stm32-rs/stm32f3xx-hal/blob/v0.6.0/examples/pwm.rs\n"]
    use crate::{
        gpio::{self, gpioa, gpiob},
        hal::PwmPin,
        pac::{RCC, TIM15, TIM16, TIM17, TIM2},
        rcc::Clocks,
        time::Hertz,
    };
    use core::marker::PhantomData;
    #[cfg(any(
        feature = "stm32f302xb",
        feature = "stm32f302xc",
        feature = "stm32f302xd",
        feature = "stm32f302xe",
        feature = "stm32f303xb",
        feature = "stm32f303xc",
        feature = "stm32f303xd",
        feature = "stm32f303xe",
        feature = "stm32f373",
        feature = "stm32f378",
        feature = "stm32f358",
        feature = "stm32f398",
    ))]
    use crate::gpio::gpiod;
    #[cfg(any(
        feature = "stm32f302xb",
        feature = "stm32f302xc",
        feature = "stm32f302xd",
        feature = "stm32f302xe",
        feature = "stm32f303xb",
        feature = "stm32f303xc",
        feature = "stm32f303xd",
        feature = "stm32f303xe",
        feature = "stm32f358",
        feature = "stm32f398",
    ))]
    use crate::gpio::gpioe;
    #[cfg(any(
        feature = "stm32f318",
        feature = "stm32f302",
        feature = "stm32f303",
        feature = "stm32f373",
        feature = "stm32f378",
        feature = "stm32f334",
        feature = "stm32f358",
        feature = "stm32f398",
    ))]
    use crate::gpio::{gpioc, gpiof};
    #[doc = " Output Compare Channel 1 of Timer 1 (type state)"]
    pub struct TIM2_CH1 {}
    #[doc = " Output Compare Channel 2 of Timer 1 (type state)"]
    pub struct TIM2_CH2 {}
    #[doc = " Output Compare Channel 3 of Timer 1 (type state)"]
    pub struct TIM2_CH3 {}
    #[doc = " Output Compare Channel 4 of Timer 1 (type state)"]
    pub struct TIM2_CH4 {}
    #[doc = " Output Compare Channel 1 of Timer 15 (type state)"]
    pub struct TIM15_CH1 {}
    #[doc = " Output Compare Channel 2 of Timer 15 (type state)"]
    pub struct TIM15_CH2 {}
    #[doc = " Output Compare Channel 1 of Timer 16 (type state)"]
    pub struct TIM16_CH1 {}
    #[doc = " Output Compare Channel 1 of Timer 17 (type state)"]
    pub struct TIM17_CH1 {}
    #[doc = " Type state used to represent a channel that has no pins yet"]
    pub struct NoPins {}
    #[doc = " Type state used to represent a channel is using regular pins"]
    pub struct WithPins {}
    #[doc = " Type state used to represent a channel is using (only) complementary pins"]
    pub struct WithNPins {}
    #[doc = " Representation of a Channel for an abritary timer channel,"]
    #[doc = " that also holds a type state for whether or not this channel"]
    #[doc = " is using any pins yet."]
    #[doc = ""]
    #[doc = " If there are no pins supplied, it cannot be enabled."]
    pub struct PwmChannel<X, T> {
        timx_chy: PhantomData<X>,
        pin_status: PhantomData<T>,
    }
    use crate::pac::TIM1;
    #[doc = " Output Compare Channel 1 of Timer 1 (type state)"]
    pub struct TIM1_CH1 {}
    #[doc = " Output Compare Channel 2 of Timer 1 (type state)"]
    pub struct TIM1_CH2 {}
    #[doc = " Output Compare Channel 3 of Timer 1 (type state)"]
    pub struct TIM1_CH3 {}
    #[doc = " Output Compare Channel 4 of Timer 1 (type state)"]
    pub struct TIM1_CH4 {}
    #[doc = " Create one or more output channels from a TIM Peripheral"]
    #[doc = " This function requires the maximum resolution of the duty cycle,"]
    #[doc = " the period of the PWM signal and the frozen clock configuration."]
    #[doc = ""]
    #[doc = " The resolution should be chosen to offer sufficient steps against"]
    #[doc = " your target peripheral.  For example, a servo that can turn from"]
    #[doc = " 0 degrees (2% duty cycle) to 180 degrees (4% duty cycle) might choose"]
    #[doc = " a resolution of 9000.  This allows the servo to be set in increments"]
    #[doc = " of exactly one degree."]
    #[allow(unused_parens)]
    pub fn tim1(
        tim: TIM1,
        res: u16,
        freq: Hertz,
        clocks: &Clocks,
    ) -> (
        PwmChannel<TIM1_CH1, NoPins>,
        PwmChannel<TIM1_CH2, NoPins>,
        PwmChannel<TIM1_CH3, NoPins>,
        PwmChannel<TIM1_CH4, NoPins>,
    ) {
        unsafe {
            (*RCC::ptr()).apb2enr.modify(|_, w| w.tim1en().set_bit());
            (*RCC::ptr()).apb2rstr.modify(|_, w| w.tim1rst().set_bit());
            (*RCC::ptr())
                .apb2rstr
                .modify(|_, w| w.tim1rst().clear_bit());
        }
        tim.cr1.modify(|_, w| w.arpe().set_bit());
        #[allow(unused_unsafe)]
        tim.arr.write(|w| unsafe { w.arr().bits(res) });
        let clock_freq = clocks.pclk2().0 * if clocks.ppre1() == 1 { 1 } else { 2 };
        let prescale_factor = clock_freq / res as u32 / freq.0;
        tim.psc.write(|w| w.psc().bits(prescale_factor as u16 - 1));
        tim.egr.write(|w| w.ug().set_bit());
        (|tim: &TIM1| tim.bdtr.modify(|_, w| w.moe().set_bit()))(&tim);
        tim.cr1.modify(|_, w| w.cen().set_bit());
        (
            PwmChannel {
                timx_chy: PhantomData,
                pin_status: PhantomData,
            },
            PwmChannel {
                timx_chy: PhantomData,
                pin_status: PhantomData,
            },
            PwmChannel {
                timx_chy: PhantomData,
                pin_status: PhantomData,
            },
            PwmChannel {
                timx_chy: PhantomData,
                pin_status: PhantomData,
            },
        )
    }
    impl PwmPin for PwmChannel<TIM1_CH1, WithPins> {
        type Duty = u16;
        fn disable(&mut self) {
            unsafe {
                (*TIM1::ptr()).ccer.modify(|_, w| w.cc1e().clear_bit());
            }
        }
        fn enable(&mut self) {
            unsafe {
                (*TIM1::ptr()).ccer.modify(|_, w| w.cc1e().set_bit());
            }
        }
        fn get_max_duty(&self) -> Self::Duty {
            unsafe { (*TIM1::ptr()).arr.read().arr().bits() }
        }
        fn get_duty(&self) -> Self::Duty {
            unsafe { (*TIM1::ptr()).ccr1.read().ccr().bits() }
        }
        fn set_duty(&mut self, duty: Self::Duty) -> () {
            unsafe {
                (*TIM1::ptr()).ccr1.modify(|_, w| w.ccr().bits(duty));
            }
        }
    }
    impl PwmPin for PwmChannel<TIM1_CH1, WithNPins> {
        type Duty = u16;
        fn disable(&mut self) {
            unsafe {
                (*TIM1::ptr()).ccer.modify(|_, w| w.cc1ne().clear_bit());
            }
        }
        fn enable(&mut self) {
            unsafe {
                (*TIM1::ptr()).ccer.modify(|_, w| w.cc1ne().set_bit());
            }
        }
        fn get_max_duty(&self) -> Self::Duty {
            unsafe { (*TIM1::ptr()).arr.read().arr().bits() }
        }
        fn get_duty(&self) -> Self::Duty {
            unsafe { (*TIM1::ptr()).ccr1.read().ccr().bits() }
        }
        fn set_duty(&mut self, duty: Self::Duty) -> () {
            unsafe {
                (*TIM1::ptr()).ccr1.modify(|_, w| w.ccr().bits(duty));
            }
        }
    }
    impl PwmPin for PwmChannel<TIM1_CH2, WithPins> {
        type Duty = u16;
        fn disable(&mut self) {
            unsafe {
                (*TIM1::ptr()).ccer.modify(|_, w| w.cc2e().clear_bit());
            }
        }
        fn enable(&mut self) {
            unsafe {
                (*TIM1::ptr()).ccer.modify(|_, w| w.cc2e().set_bit());
            }
        }
        fn get_max_duty(&self) -> Self::Duty {
            unsafe { (*TIM1::ptr()).arr.read().arr().bits() }
        }
        fn get_duty(&self) -> Self::Duty {
            unsafe { (*TIM1::ptr()).ccr2.read().ccr().bits() }
        }
        fn set_duty(&mut self, duty: Self::Duty) -> () {
            unsafe {
                (*TIM1::ptr()).ccr2.modify(|_, w| w.ccr().bits(duty));
            }
        }
    }
    impl PwmPin for PwmChannel<TIM1_CH2, WithNPins> {
        type Duty = u16;
        fn disable(&mut self) {
            unsafe {
                (*TIM1::ptr()).ccer.modify(|_, w| w.cc2ne().clear_bit());
            }
        }
        fn enable(&mut self) {
            unsafe {
                (*TIM1::ptr()).ccer.modify(|_, w| w.cc2ne().set_bit());
            }
        }
        fn get_max_duty(&self) -> Self::Duty {
            unsafe { (*TIM1::ptr()).arr.read().arr().bits() }
        }
        fn get_duty(&self) -> Self::Duty {
            unsafe { (*TIM1::ptr()).ccr2.read().ccr().bits() }
        }
        fn set_duty(&mut self, duty: Self::Duty) -> () {
            unsafe {
                (*TIM1::ptr()).ccr2.modify(|_, w| w.ccr().bits(duty));
            }
        }
    }
    impl PwmPin for PwmChannel<TIM1_CH3, WithPins> {
        type Duty = u16;
        fn disable(&mut self) {
            unsafe {
                (*TIM1::ptr()).ccer.modify(|_, w| w.cc3e().clear_bit());
            }
        }
        fn enable(&mut self) {
            unsafe {
                (*TIM1::ptr()).ccer.modify(|_, w| w.cc3e().set_bit());
            }
        }
        fn get_max_duty(&self) -> Self::Duty {
            unsafe { (*TIM1::ptr()).arr.read().arr().bits() }
        }
        fn get_duty(&self) -> Self::Duty {
            unsafe { (*TIM1::ptr()).ccr3.read().ccr().bits() }
        }
        fn set_duty(&mut self, duty: Self::Duty) -> () {
            unsafe {
                (*TIM1::ptr()).ccr3.modify(|_, w| w.ccr().bits(duty));
            }
        }
    }
    impl PwmPin for PwmChannel<TIM1_CH3, WithNPins> {
        type Duty = u16;
        fn disable(&mut self) {
            unsafe {
                (*TIM1::ptr()).ccer.modify(|_, w| w.cc3ne().clear_bit());
            }
        }
        fn enable(&mut self) {
            unsafe {
                (*TIM1::ptr()).ccer.modify(|_, w| w.cc3ne().set_bit());
            }
        }
        fn get_max_duty(&self) -> Self::Duty {
            unsafe { (*TIM1::ptr()).arr.read().arr().bits() }
        }
        fn get_duty(&self) -> Self::Duty {
            unsafe { (*TIM1::ptr()).ccr3.read().ccr().bits() }
        }
        fn set_duty(&mut self, duty: Self::Duty) -> () {
            unsafe {
                (*TIM1::ptr()).ccr3.modify(|_, w| w.ccr().bits(duty));
            }
        }
    }
    impl PwmPin for PwmChannel<TIM1_CH4, WithPins> {
        type Duty = u16;
        fn disable(&mut self) {
            unsafe {
                (*TIM1::ptr()).ccer.modify(|_, w| w.cc4e().clear_bit());
            }
        }
        fn enable(&mut self) {
            unsafe {
                (*TIM1::ptr()).ccer.modify(|_, w| w.cc4e().set_bit());
            }
        }
        fn get_max_duty(&self) -> Self::Duty {
            unsafe { (*TIM1::ptr()).arr.read().arr().bits() }
        }
        fn get_duty(&self) -> Self::Duty {
            unsafe { (*TIM1::ptr()).ccr4.read().ccr().bits() }
        }
        fn set_duty(&mut self, duty: Self::Duty) -> () {
            unsafe {
                (*TIM1::ptr()).ccr4.modify(|_, w| w.ccr().bits(duty));
            }
        }
    }
    impl PwmChannel<TIM1_CH1, NoPins> {
        #[doc = " Output to a specific pin from a channel that does not yet have"]
        #[doc = " any pins.  This channel cannot be enabled until this method"]
        #[doc = " is called."]
        #[doc = ""]
        #[doc = " The pin is consumed and cannot be returned."]
        pub fn output_to_pa8(self, _p: gpioa::PA8<gpio::AF6>) -> PwmChannel<TIM1_CH1, WithPins> {
            unsafe {
                (*TIM1::ptr())
                    .ccmr1_output()
                    .modify(|_, w| w.oc1m().bits(0b0110).oc1pe().set_bit());
            }
            PwmChannel {
                timx_chy: PhantomData,
                pin_status: PhantomData,
            }
        }
    }
    impl PwmChannel<TIM1_CH1, WithPins> {
        #[doc = " Output to a specific pin from a channel is already configured"]
        #[doc = " with output pins.  There is no limit to the number of pins that"]
        #[doc = " can be used (as long as they are compatible)."]
        #[doc = ""]
        #[doc = " The pin is consumed and cannot be returned."]
        pub fn output_to_pa8(self, _p: gpioa::PA8<gpio::AF6>) -> PwmChannel<TIM1_CH1, WithPins> {
            self
        }
    }
    impl PwmChannel<TIM1_CH1, NoPins> {
        #[doc = " Output to a specific pin from a channel that does not yet have"]
        #[doc = " any pins.  This channel cannot be enabled until this method"]
        #[doc = " is called."]
        #[doc = ""]
        #[doc = " The pin is consumed and cannot be returned."]
        pub fn output_to_pa7(self, _p: gpioa::PA7<gpio::AF6>) -> PwmChannel<TIM1_CH1, WithNPins> {
            unsafe {
                (*TIM1::ptr())
                    .ccmr1_output()
                    .modify(|_, w| w.oc1m().bits(0b0110).oc1pe().set_bit());
            }
            PwmChannel {
                timx_chy: PhantomData,
                pin_status: PhantomData,
            }
        }
    }
    impl PwmChannel<TIM1_CH1, WithNPins> {
        #[doc = " Output to a specific pin from a channel is already configured"]
        #[doc = " with output pins.  There is no limit to the number of pins that"]
        #[doc = " can be used (as long as they are compatible)."]
        #[doc = ""]
        #[doc = " The pin is consumed and cannot be returned."]
        pub fn output_to_pa7(self, _p: gpioa::PA7<gpio::AF6>) -> PwmChannel<TIM1_CH1, WithNPins> {
            self
        }
    }
    impl PwmChannel<TIM1_CH1, NoPins> {
        #[doc = " Output to a specific pin from a channel that does not yet have"]
        #[doc = " any pins.  This channel cannot be enabled until this method"]
        #[doc = " is called."]
        #[doc = ""]
        #[doc = " The pin is consumed and cannot be returned."]
        pub fn output_to_pa11(self, _p: gpioa::PA11<gpio::AF6>) -> PwmChannel<TIM1_CH1, WithNPins> {
            unsafe {
                (*TIM1::ptr())
                    .ccmr1_output()
                    .modify(|_, w| w.oc1m().bits(0b0110).oc1pe().set_bit());
            }
            PwmChannel {
                timx_chy: PhantomData,
                pin_status: PhantomData,
            }
        }
    }
    impl PwmChannel<TIM1_CH1, WithNPins> {
        #[doc = " Output to a specific pin from a channel is already configured"]
        #[doc = " with output pins.  There is no limit to the number of pins that"]
        #[doc = " can be used (as long as they are compatible)."]
        #[doc = ""]
        #[doc = " The pin is consumed and cannot be returned."]
        pub fn output_to_pa11(self, _p: gpioa::PA11<gpio::AF6>) -> PwmChannel<TIM1_CH1, WithNPins> {
            self
        }
    }
    impl PwmChannel<TIM1_CH1, NoPins> {
        #[doc = " Output to a specific pin from a channel that does not yet have"]
        #[doc = " any pins.  This channel cannot be enabled until this method"]
        #[doc = " is called."]
        #[doc = ""]
        #[doc = " The pin is consumed and cannot be returned."]
        pub fn output_to_pb13(self, _p: gpiob::PB13<gpio::AF6>) -> PwmChannel<TIM1_CH1, WithNPins> {
            unsafe {
                (*TIM1::ptr())
                    .ccmr1_output()
                    .modify(|_, w| w.oc1m().bits(0b0110).oc1pe().set_bit());
            }
            PwmChannel {
                timx_chy: PhantomData,
                pin_status: PhantomData,
            }
        }
    }
    impl PwmChannel<TIM1_CH1, WithNPins> {
        #[doc = " Output to a specific pin from a channel is already configured"]
        #[doc = " with output pins.  There is no limit to the number of pins that"]
        #[doc = " can be used (as long as they are compatible)."]
        #[doc = ""]
        #[doc = " The pin is consumed and cannot be returned."]
        pub fn output_to_pb13(self, _p: gpiob::PB13<gpio::AF6>) -> PwmChannel<TIM1_CH1, WithNPins> {
            self
        }
    }
    impl PwmChannel<TIM1_CH1, NoPins> {
        #[doc = " Output to a specific pin from a channel that does not yet have"]
        #[doc = " any pins.  This channel cannot be enabled until this method"]
        #[doc = " is called."]
        #[doc = ""]
        #[doc = " The pin is consumed and cannot be returned."]
        pub fn output_to_pc13(self, _p: gpioc::PC13<gpio::AF4>) -> PwmChannel<TIM1_CH1, WithNPins> {
            unsafe {
                (*TIM1::ptr())
                    .ccmr1_output()
                    .modify(|_, w| w.oc1m().bits(0b0110).oc1pe().set_bit());
            }
            PwmChannel {
                timx_chy: PhantomData,
                pin_status: PhantomData,
            }
        }
    }
    impl PwmChannel<TIM1_CH1, WithNPins> {
        #[doc = " Output to a specific pin from a channel is already configured"]
        #[doc = " with output pins.  There is no limit to the number of pins that"]
        #[doc = " can be used (as long as they are compatible)."]
        #[doc = ""]
        #[doc = " The pin is consumed and cannot be returned."]
        pub fn output_to_pc13(self, _p: gpioc::PC13<gpio::AF4>) -> PwmChannel<TIM1_CH1, WithNPins> {
            self
        }
    }
    impl PwmChannel<TIM1_CH2, NoPins> {
        #[doc = " Output to a specific pin from a channel that does not yet have"]
        #[doc = " any pins.  This channel cannot be enabled until this method"]
        #[doc = " is called."]
        #[doc = ""]
        #[doc = " The pin is consumed and cannot be returned."]
        pub fn output_to_pa9(self, _p: gpioa::PA9<gpio::AF6>) -> PwmChannel<TIM1_CH2, WithPins> {
            unsafe {
                (*TIM1::ptr())
                    .ccmr1_output()
                    .modify(|_, w| w.oc2m().bits(0b0110).oc2pe().set_bit());
            }
            PwmChannel {
                timx_chy: PhantomData,
                pin_status: PhantomData,
            }
        }
    }
    impl PwmChannel<TIM1_CH2, WithPins> {
        #[doc = " Output to a specific pin from a channel is already configured"]
        #[doc = " with output pins.  There is no limit to the number of pins that"]
        #[doc = " can be used (as long as they are compatible)."]
        #[doc = ""]
        #[doc = " The pin is consumed and cannot be returned."]
        pub fn output_to_pa9(self, _p: gpioa::PA9<gpio::AF6>) -> PwmChannel<TIM1_CH2, WithPins> {
            self
        }
    }
    impl PwmChannel<TIM1_CH2, NoPins> {
        #[doc = " Output to a specific pin from a channel that does not yet have"]
        #[doc = " any pins.  This channel cannot be enabled until this method"]
        #[doc = " is called."]
        #[doc = ""]
        #[doc = " The pin is consumed and cannot be returned."]
        pub fn output_to_pa12(self, _p: gpioa::PA12<gpio::AF6>) -> PwmChannel<TIM1_CH2, WithNPins> {
            unsafe {
                (*TIM1::ptr())
                    .ccmr1_output()
                    .modify(|_, w| w.oc2m().bits(0b0110).oc2pe().set_bit());
            }
            PwmChannel {
                timx_chy: PhantomData,
                pin_status: PhantomData,
            }
        }
    }
    impl PwmChannel<TIM1_CH2, WithNPins> {
        #[doc = " Output to a specific pin from a channel is already configured"]
        #[doc = " with output pins.  There is no limit to the number of pins that"]
        #[doc = " can be used (as long as they are compatible)."]
        #[doc = ""]
        #[doc = " The pin is consumed and cannot be returned."]
        pub fn output_to_pa12(self, _p: gpioa::PA12<gpio::AF6>) -> PwmChannel<TIM1_CH2, WithNPins> {
            self
        }
    }
    impl PwmChannel<TIM1_CH2, NoPins> {
        #[doc = " Output to a specific pin from a channel that does not yet have"]
        #[doc = " any pins.  This channel cannot be enabled until this method"]
        #[doc = " is called."]
        #[doc = ""]
        #[doc = " The pin is consumed and cannot be returned."]
        pub fn output_to_pb0(self, _p: gpiob::PB0<gpio::AF6>) -> PwmChannel<TIM1_CH2, WithNPins> {
            unsafe {
                (*TIM1::ptr())
                    .ccmr1_output()
                    .modify(|_, w| w.oc2m().bits(0b0110).oc2pe().set_bit());
            }
            PwmChannel {
                timx_chy: PhantomData,
                pin_status: PhantomData,
            }
        }
    }
    impl PwmChannel<TIM1_CH2, WithNPins> {
        #[doc = " Output to a specific pin from a channel is already configured"]
        #[doc = " with output pins.  There is no limit to the number of pins that"]
        #[doc = " can be used (as long as they are compatible)."]
        #[doc = ""]
        #[doc = " The pin is consumed and cannot be returned."]
        pub fn output_to_pb0(self, _p: gpiob::PB0<gpio::AF6>) -> PwmChannel<TIM1_CH2, WithNPins> {
            self
        }
    }
    impl PwmChannel<TIM1_CH2, NoPins> {
        #[doc = " Output to a specific pin from a channel that does not yet have"]
        #[doc = " any pins.  This channel cannot be enabled until this method"]
        #[doc = " is called."]
        #[doc = ""]
        #[doc = " The pin is consumed and cannot be returned."]
        pub fn output_to_pb14(self, _p: gpiob::PB14<gpio::AF6>) -> PwmChannel<TIM1_CH2, WithNPins> {
            unsafe {
                (*TIM1::ptr())
                    .ccmr1_output()
                    .modify(|_, w| w.oc2m().bits(0b0110).oc2pe().set_bit());
            }
            PwmChannel {
                timx_chy: PhantomData,
                pin_status: PhantomData,
            }
        }
    }
    impl PwmChannel<TIM1_CH2, WithNPins> {
        #[doc = " Output to a specific pin from a channel is already configured"]
        #[doc = " with output pins.  There is no limit to the number of pins that"]
        #[doc = " can be used (as long as they are compatible)."]
        #[doc = ""]
        #[doc = " The pin is consumed and cannot be returned."]
        pub fn output_to_pb14(self, _p: gpiob::PB14<gpio::AF6>) -> PwmChannel<TIM1_CH2, WithNPins> {
            self
        }
    }
    impl PwmChannel<TIM1_CH3, NoPins> {
        #[doc = " Output to a specific pin from a channel that does not yet have"]
        #[doc = " any pins.  This channel cannot be enabled until this method"]
        #[doc = " is called."]
        #[doc = ""]
        #[doc = " The pin is consumed and cannot be returned."]
        pub fn output_to_pa10(self, _p: gpioa::PA10<gpio::AF6>) -> PwmChannel<TIM1_CH3, WithPins> {
            unsafe {
                (*TIM1::ptr())
                    .ccmr2_output()
                    .modify(|_, w| w.oc3m().bits(0b0110).oc3pe().set_bit());
            }
            PwmChannel {
                timx_chy: PhantomData,
                pin_status: PhantomData,
            }
        }
    }
    impl PwmChannel<TIM1_CH3, WithPins> {
        #[doc = " Output to a specific pin from a channel is already configured"]
        #[doc = " with output pins.  There is no limit to the number of pins that"]
        #[doc = " can be used (as long as they are compatible)."]
        #[doc = ""]
        #[doc = " The pin is consumed and cannot be returned."]
        pub fn output_to_pa10(self, _p: gpioa::PA10<gpio::AF6>) -> PwmChannel<TIM1_CH3, WithPins> {
            self
        }
    }
    impl PwmChannel<TIM1_CH3, NoPins> {
        #[doc = " Output to a specific pin from a channel that does not yet have"]
        #[doc = " any pins.  This channel cannot be enabled until this method"]
        #[doc = " is called."]
        #[doc = ""]
        #[doc = " The pin is consumed and cannot be returned."]
        pub fn output_to_pb1(self, _p: gpiob::PB1<gpio::AF6>) -> PwmChannel<TIM1_CH3, WithNPins> {
            unsafe {
                (*TIM1::ptr())
                    .ccmr2_output()
                    .modify(|_, w| w.oc3m().bits(0b0110).oc3pe().set_bit());
            }
            PwmChannel {
                timx_chy: PhantomData,
                pin_status: PhantomData,
            }
        }
    }
    impl PwmChannel<TIM1_CH3, WithNPins> {
        #[doc = " Output to a specific pin from a channel is already configured"]
        #[doc = " with output pins.  There is no limit to the number of pins that"]
        #[doc = " can be used (as long as they are compatible)."]
        #[doc = ""]
        #[doc = " The pin is consumed and cannot be returned."]
        pub fn output_to_pb1(self, _p: gpiob::PB1<gpio::AF6>) -> PwmChannel<TIM1_CH3, WithNPins> {
            self
        }
    }
    impl PwmChannel<TIM1_CH3, NoPins> {
        #[doc = " Output to a specific pin from a channel that does not yet have"]
        #[doc = " any pins.  This channel cannot be enabled until this method"]
        #[doc = " is called."]
        #[doc = ""]
        #[doc = " The pin is consumed and cannot be returned."]
        pub fn output_to_pb15(self, _p: gpiob::PB15<gpio::AF4>) -> PwmChannel<TIM1_CH3, WithNPins> {
            unsafe {
                (*TIM1::ptr())
                    .ccmr2_output()
                    .modify(|_, w| w.oc3m().bits(0b0110).oc3pe().set_bit());
            }
            PwmChannel {
                timx_chy: PhantomData,
                pin_status: PhantomData,
            }
        }
    }
    impl PwmChannel<TIM1_CH3, WithNPins> {
        #[doc = " Output to a specific pin from a channel is already configured"]
        #[doc = " with output pins.  There is no limit to the number of pins that"]
        #[doc = " can be used (as long as they are compatible)."]
        #[doc = ""]
        #[doc = " The pin is consumed and cannot be returned."]
        pub fn output_to_pb15(self, _p: gpiob::PB15<gpio::AF4>) -> PwmChannel<TIM1_CH3, WithNPins> {
            self
        }
    }
    impl PwmChannel<TIM1_CH3, NoPins> {
        #[doc = " Output to a specific pin from a channel that does not yet have"]
        #[doc = " any pins.  This channel cannot be enabled until this method"]
        #[doc = " is called."]
        #[doc = ""]
        #[doc = " The pin is consumed and cannot be returned."]
        pub fn output_to_pf0(self, _p: gpiof::PF0<gpio::AF6>) -> PwmChannel<TIM1_CH3, WithNPins> {
            unsafe {
                (*TIM1::ptr())
                    .ccmr2_output()
                    .modify(|_, w| w.oc3m().bits(0b0110).oc3pe().set_bit());
            }
            PwmChannel {
                timx_chy: PhantomData,
                pin_status: PhantomData,
            }
        }
    }
    impl PwmChannel<TIM1_CH3, WithNPins> {
        #[doc = " Output to a specific pin from a channel is already configured"]
        #[doc = " with output pins.  There is no limit to the number of pins that"]
        #[doc = " can be used (as long as they are compatible)."]
        #[doc = ""]
        #[doc = " The pin is consumed and cannot be returned."]
        pub fn output_to_pf0(self, _p: gpiof::PF0<gpio::AF6>) -> PwmChannel<TIM1_CH3, WithNPins> {
            self
        }
    }
    impl PwmChannel<TIM1_CH4, NoPins> {
        #[doc = " Output to a specific pin from a channel that does not yet have"]
        #[doc = " any pins.  This channel cannot be enabled until this method"]
        #[doc = " is called."]
        #[doc = ""]
        #[doc = " The pin is consumed and cannot be returned."]
        pub fn output_to_pa11(self, _p: gpioa::PA11<gpio::AF11>) -> PwmChannel<TIM1_CH4, WithPins> {
            unsafe {
                (*TIM1::ptr())
                    .ccmr2_output()
                    .modify(|_, w| w.oc4m().bits(0b0110).oc4pe().set_bit());
            }
            PwmChannel {
                timx_chy: PhantomData,
                pin_status: PhantomData,
            }
        }
    }
    impl PwmChannel<TIM1_CH4, WithPins> {
        #[doc = " Output to a specific pin from a channel is already configured"]
        #[doc = " with output pins.  There is no limit to the number of pins that"]
        #[doc = " can be used (as long as they are compatible)."]
        #[doc = ""]
        #[doc = " The pin is consumed and cannot be returned."]
        pub fn output_to_pa11(self, _p: gpioa::PA11<gpio::AF11>) -> PwmChannel<TIM1_CH4, WithPins> {
            self
        }
    }
    impl PwmChannel<TIM1_CH1, NoPins> {
        #[doc = " Output to a specific pin from a channel that does not yet have"]
        #[doc = " any pins.  This channel cannot be enabled until this method"]
        #[doc = " is called."]
        #[doc = ""]
        #[doc = " The pin is consumed and cannot be returned."]
        pub fn output_to_pe9(self, _p: gpioe::PE9<gpio::AF2>) -> PwmChannel<TIM1_CH1, WithPins> {
            unsafe {
                (*TIM1::ptr())
                    .ccmr1_output()
                    .modify(|_, w| w.oc1m().bits(0b0110).oc1pe().set_bit());
            }
            PwmChannel {
                timx_chy: PhantomData,
                pin_status: PhantomData,
            }
        }
    }
    impl PwmChannel<TIM1_CH1, WithPins> {
        #[doc = " Output to a specific pin from a channel is already configured"]
        #[doc = " with output pins.  There is no limit to the number of pins that"]
        #[doc = " can be used (as long as they are compatible)."]
        #[doc = ""]
        #[doc = " The pin is consumed and cannot be returned."]
        pub fn output_to_pe9(self, _p: gpioe::PE9<gpio::AF2>) -> PwmChannel<TIM1_CH1, WithPins> {
            self
        }
    }
    impl PwmChannel<TIM1_CH1, NoPins> {
        #[doc = " Output to a specific pin from a channel that does not yet have"]
        #[doc = " any pins.  This channel cannot be enabled until this method"]
        #[doc = " is called."]
        #[doc = ""]
        #[doc = " The pin is consumed and cannot be returned."]
        pub fn output_to_pe8(self, _p: gpioe::PE8<gpio::AF2>) -> PwmChannel<TIM1_CH1, WithNPins> {
            unsafe {
                (*TIM1::ptr())
                    .ccmr1_output()
                    .modify(|_, w| w.oc1m().bits(0b0110).oc1pe().set_bit());
            }
            PwmChannel {
                timx_chy: PhantomData,
                pin_status: PhantomData,
            }
        }
    }
    impl PwmChannel<TIM1_CH1, WithNPins> {
        #[doc = " Output to a specific pin from a channel is already configured"]
        #[doc = " with output pins.  There is no limit to the number of pins that"]
        #[doc = " can be used (as long as they are compatible)."]
        #[doc = ""]
        #[doc = " The pin is consumed and cannot be returned."]
        pub fn output_to_pe8(self, _p: gpioe::PE8<gpio::AF2>) -> PwmChannel<TIM1_CH1, WithNPins> {
            self
        }
    }
    impl PwmChannel<TIM1_CH2, NoPins> {
        #[doc = " Output to a specific pin from a channel that does not yet have"]
        #[doc = " any pins.  This channel cannot be enabled until this method"]
        #[doc = " is called."]
        #[doc = ""]
        #[doc = " The pin is consumed and cannot be returned."]
        pub fn output_to_pe11(self, _p: gpioe::PE11<gpio::AF2>) -> PwmChannel<TIM1_CH2, WithPins> {
            unsafe {
                (*TIM1::ptr())
                    .ccmr1_output()
                    .modify(|_, w| w.oc2m().bits(0b0110).oc2pe().set_bit());
            }
            PwmChannel {
                timx_chy: PhantomData,
                pin_status: PhantomData,
            }
        }
    }
    impl PwmChannel<TIM1_CH2, WithPins> {
        #[doc = " Output to a specific pin from a channel is already configured"]
        #[doc = " with output pins.  There is no limit to the number of pins that"]
        #[doc = " can be used (as long as they are compatible)."]
        #[doc = ""]
        #[doc = " The pin is consumed and cannot be returned."]
        pub fn output_to_pe11(self, _p: gpioe::PE11<gpio::AF2>) -> PwmChannel<TIM1_CH2, WithPins> {
            self
        }
    }
    impl PwmChannel<TIM1_CH2, NoPins> {
        #[doc = " Output to a specific pin from a channel that does not yet have"]
        #[doc = " any pins.  This channel cannot be enabled until this method"]
        #[doc = " is called."]
        #[doc = ""]
        #[doc = " The pin is consumed and cannot be returned."]
        pub fn output_to_pe10(self, _p: gpioe::PE10<gpio::AF2>) -> PwmChannel<TIM1_CH2, WithNPins> {
            unsafe {
                (*TIM1::ptr())
                    .ccmr1_output()
                    .modify(|_, w| w.oc2m().bits(0b0110).oc2pe().set_bit());
            }
            PwmChannel {
                timx_chy: PhantomData,
                pin_status: PhantomData,
            }
        }
    }
    impl PwmChannel<TIM1_CH2, WithNPins> {
        #[doc = " Output to a specific pin from a channel is already configured"]
        #[doc = " with output pins.  There is no limit to the number of pins that"]
        #[doc = " can be used (as long as they are compatible)."]
        #[doc = ""]
        #[doc = " The pin is consumed and cannot be returned."]
        pub fn output_to_pe10(self, _p: gpioe::PE10<gpio::AF2>) -> PwmChannel<TIM1_CH2, WithNPins> {
            self
        }
    }
    impl PwmChannel<TIM1_CH3, NoPins> {
        #[doc = " Output to a specific pin from a channel that does not yet have"]
        #[doc = " any pins.  This channel cannot be enabled until this method"]
        #[doc = " is called."]
        #[doc = ""]
        #[doc = " The pin is consumed and cannot be returned."]
        pub fn output_to_pe13(self, _p: gpioe::PE13<gpio::AF2>) -> PwmChannel<TIM1_CH3, WithPins> {
            unsafe {
                (*TIM1::ptr())
                    .ccmr2_output()
                    .modify(|_, w| w.oc3m().bits(0b0110).oc3pe().set_bit());
            }
            PwmChannel {
                timx_chy: PhantomData,
                pin_status: PhantomData,
            }
        }
    }
    impl PwmChannel<TIM1_CH3, WithPins> {
        #[doc = " Output to a specific pin from a channel is already configured"]
        #[doc = " with output pins.  There is no limit to the number of pins that"]
        #[doc = " can be used (as long as they are compatible)."]
        #[doc = ""]
        #[doc = " The pin is consumed and cannot be returned."]
        pub fn output_to_pe13(self, _p: gpioe::PE13<gpio::AF2>) -> PwmChannel<TIM1_CH3, WithPins> {
            self
        }
    }
    impl PwmChannel<TIM1_CH3, NoPins> {
        #[doc = " Output to a specific pin from a channel that does not yet have"]
        #[doc = " any pins.  This channel cannot be enabled until this method"]
        #[doc = " is called."]
        #[doc = ""]
        #[doc = " The pin is consumed and cannot be returned."]
        pub fn output_to_pe12(self, _p: gpioe::PE12<gpio::AF2>) -> PwmChannel<TIM1_CH3, WithNPins> {
            unsafe {
                (*TIM1::ptr())
                    .ccmr2_output()
                    .modify(|_, w| w.oc3m().bits(0b0110).oc3pe().set_bit());
            }
            PwmChannel {
                timx_chy: PhantomData,
                pin_status: PhantomData,
            }
        }
    }
    impl PwmChannel<TIM1_CH3, WithNPins> {
        #[doc = " Output to a specific pin from a channel is already configured"]
        #[doc = " with output pins.  There is no limit to the number of pins that"]
        #[doc = " can be used (as long as they are compatible)."]
        #[doc = ""]
        #[doc = " The pin is consumed and cannot be returned."]
        pub fn output_to_pe12(self, _p: gpioe::PE12<gpio::AF2>) -> PwmChannel<TIM1_CH3, WithNPins> {
            self
        }
    }
    impl PwmChannel<TIM1_CH4, NoPins> {
        #[doc = " Output to a specific pin from a channel that does not yet have"]
        #[doc = " any pins.  This channel cannot be enabled until this method"]
        #[doc = " is called."]
        #[doc = ""]
        #[doc = " The pin is consumed and cannot be returned."]
        pub fn output_to_pe14(self, _p: gpioe::PE14<gpio::AF2>) -> PwmChannel<TIM1_CH4, WithPins> {
            unsafe {
                (*TIM1::ptr())
                    .ccmr2_output()
                    .modify(|_, w| w.oc4m().bits(0b0110).oc4pe().set_bit());
            }
            PwmChannel {
                timx_chy: PhantomData,
                pin_status: PhantomData,
            }
        }
    }
    impl PwmChannel<TIM1_CH4, WithPins> {
        #[doc = " Output to a specific pin from a channel is already configured"]
        #[doc = " with output pins.  There is no limit to the number of pins that"]
        #[doc = " can be used (as long as they are compatible)."]
        #[doc = ""]
        #[doc = " The pin is consumed and cannot be returned."]
        pub fn output_to_pe14(self, _p: gpioe::PE14<gpio::AF2>) -> PwmChannel<TIM1_CH4, WithPins> {
            self
        }
    }
    #[doc = " Create one or more output channels from a TIM Peripheral"]
    #[doc = " This function requires the maximum resolution of the duty cycle,"]
    #[doc = " the period of the PWM signal and the frozen clock configuration."]
    #[doc = ""]
    #[doc = " The resolution should be chosen to offer sufficient steps against"]
    #[doc = " your target peripheral.  For example, a servo that can turn from"]
    #[doc = " 0 degrees (2% duty cycle) to 180 degrees (4% duty cycle) might choose"]
    #[doc = " a resolution of 9000.  This allows the servo to be set in increments"]
    #[doc = " of exactly one degree."]
    #[allow(unused_parens)]
    pub fn tim2(
        tim: TIM2,
        res: u32,
        freq: Hertz,
        clocks: &Clocks,
    ) -> (
        PwmChannel<TIM2_CH1, NoPins>,
        PwmChannel<TIM2_CH2, NoPins>,
        PwmChannel<TIM2_CH3, NoPins>,
        PwmChannel<TIM2_CH4, NoPins>,
    ) {
        unsafe {
            (*RCC::ptr()).apb1enr.modify(|_, w| w.tim2en().set_bit());
            (*RCC::ptr()).apb1rstr.modify(|_, w| w.tim2rst().set_bit());
            (*RCC::ptr())
                .apb1rstr
                .modify(|_, w| w.tim2rst().clear_bit());
        }
        tim.cr1.modify(|_, w| w.arpe().set_bit());
        #[allow(unused_unsafe)]
        tim.arr.write(|w| unsafe { w.arr().bits(res) });
        let clock_freq = clocks.pclk1().0 * if clocks.ppre1() == 1 { 1 } else { 2 };
        let prescale_factor = clock_freq / res as u32 / freq.0;
        tim.psc.write(|w| w.psc().bits(prescale_factor as u16 - 1));
        tim.egr.write(|w| w.ug().set_bit());
        (|_| ())(&tim);
        tim.cr1.modify(|_, w| w.cen().set_bit());
        (
            PwmChannel {
                timx_chy: PhantomData,
                pin_status: PhantomData,
            },
            PwmChannel {
                timx_chy: PhantomData,
                pin_status: PhantomData,
            },
            PwmChannel {
                timx_chy: PhantomData,
                pin_status: PhantomData,
            },
            PwmChannel {
                timx_chy: PhantomData,
                pin_status: PhantomData,
            },
        )
    }
    impl PwmPin for PwmChannel<TIM2_CH1, WithPins> {
        type Duty = u32;
        fn disable(&mut self) {
            unsafe {
                (*TIM2::ptr()).ccer.modify(|_, w| w.cc1e().clear_bit());
            }
        }
        fn enable(&mut self) {
            unsafe {
                (*TIM2::ptr()).ccer.modify(|_, w| w.cc1e().set_bit());
            }
        }
        fn get_max_duty(&self) -> Self::Duty {
            unsafe { (*TIM2::ptr()).arr.read().arr().bits() }
        }
        fn get_duty(&self) -> Self::Duty {
            unsafe { (*TIM2::ptr()).ccr1.read().ccr().bits() }
        }
        fn set_duty(&mut self, duty: Self::Duty) -> () {
            unsafe {
                (*TIM2::ptr()).ccr1.modify(|_, w| w.ccr().bits(duty));
            }
        }
    }
    impl PwmPin for PwmChannel<TIM2_CH2, WithPins> {
        type Duty = u32;
        fn disable(&mut self) {
            unsafe {
                (*TIM2::ptr()).ccer.modify(|_, w| w.cc2e().clear_bit());
            }
        }
        fn enable(&mut self) {
            unsafe {
                (*TIM2::ptr()).ccer.modify(|_, w| w.cc2e().set_bit());
            }
        }
        fn get_max_duty(&self) -> Self::Duty {
            unsafe { (*TIM2::ptr()).arr.read().arr().bits() }
        }
        fn get_duty(&self) -> Self::Duty {
            unsafe { (*TIM2::ptr()).ccr2.read().ccr().bits() }
        }
        fn set_duty(&mut self, duty: Self::Duty) -> () {
            unsafe {
                (*TIM2::ptr()).ccr2.modify(|_, w| w.ccr().bits(duty));
            }
        }
    }
    impl PwmPin for PwmChannel<TIM2_CH3, WithPins> {
        type Duty = u32;
        fn disable(&mut self) {
            unsafe {
                (*TIM2::ptr()).ccer.modify(|_, w| w.cc3e().clear_bit());
            }
        }
        fn enable(&mut self) {
            unsafe {
                (*TIM2::ptr()).ccer.modify(|_, w| w.cc3e().set_bit());
            }
        }
        fn get_max_duty(&self) -> Self::Duty {
            unsafe { (*TIM2::ptr()).arr.read().arr().bits() }
        }
        fn get_duty(&self) -> Self::Duty {
            unsafe { (*TIM2::ptr()).ccr3.read().ccr().bits() }
        }
        fn set_duty(&mut self, duty: Self::Duty) -> () {
            unsafe {
                (*TIM2::ptr()).ccr3.modify(|_, w| w.ccr().bits(duty));
            }
        }
    }
    impl PwmPin for PwmChannel<TIM2_CH4, WithPins> {
        type Duty = u32;
        fn disable(&mut self) {
            unsafe {
                (*TIM2::ptr()).ccer.modify(|_, w| w.cc4e().clear_bit());
            }
        }
        fn enable(&mut self) {
            unsafe {
                (*TIM2::ptr()).ccer.modify(|_, w| w.cc4e().set_bit());
            }
        }
        fn get_max_duty(&self) -> Self::Duty {
            unsafe { (*TIM2::ptr()).arr.read().arr().bits() }
        }
        fn get_duty(&self) -> Self::Duty {
            unsafe { (*TIM2::ptr()).ccr4.read().ccr().bits() }
        }
        fn set_duty(&mut self, duty: Self::Duty) -> () {
            unsafe {
                (*TIM2::ptr()).ccr4.modify(|_, w| w.ccr().bits(duty));
            }
        }
    }
    impl PwmChannel<TIM2_CH1, NoPins> {
        #[doc = " Output to a specific pin from a channel that does not yet have"]
        #[doc = " any pins.  This channel cannot be enabled until this method"]
        #[doc = " is called."]
        #[doc = ""]
        #[doc = " The pin is consumed and cannot be returned."]
        pub fn output_to_pa0(self, _p: gpioa::PA0<gpio::AF1>) -> PwmChannel<TIM2_CH1, WithPins> {
            unsafe {
                (*TIM2::ptr())
                    .ccmr1_output()
                    .modify(|_, w| w.oc1m().bits(0b0110).oc1pe().set_bit());
            }
            PwmChannel {
                timx_chy: PhantomData,
                pin_status: PhantomData,
            }
        }
    }
    impl PwmChannel<TIM2_CH1, WithPins> {
        #[doc = " Output to a specific pin from a channel is already configured"]
        #[doc = " with output pins.  There is no limit to the number of pins that"]
        #[doc = " can be used (as long as they are compatible)."]
        #[doc = ""]
        #[doc = " The pin is consumed and cannot be returned."]
        pub fn output_to_pa0(self, _p: gpioa::PA0<gpio::AF1>) -> PwmChannel<TIM2_CH1, WithPins> {
            self
        }
    }
    impl PwmChannel<TIM2_CH1, NoPins> {
        #[doc = " Output to a specific pin from a channel that does not yet have"]
        #[doc = " any pins.  This channel cannot be enabled until this method"]
        #[doc = " is called."]
        #[doc = ""]
        #[doc = " The pin is consumed and cannot be returned."]
        pub fn output_to_pa5(self, _p: gpioa::PA5<gpio::AF1>) -> PwmChannel<TIM2_CH1, WithPins> {
            unsafe {
                (*TIM2::ptr())
                    .ccmr1_output()
                    .modify(|_, w| w.oc1m().bits(0b0110).oc1pe().set_bit());
            }
            PwmChannel {
                timx_chy: PhantomData,
                pin_status: PhantomData,
            }
        }
    }
    impl PwmChannel<TIM2_CH1, WithPins> {
        #[doc = " Output to a specific pin from a channel is already configured"]
        #[doc = " with output pins.  There is no limit to the number of pins that"]
        #[doc = " can be used (as long as they are compatible)."]
        #[doc = ""]
        #[doc = " The pin is consumed and cannot be returned."]
        pub fn output_to_pa5(self, _p: gpioa::PA5<gpio::AF1>) -> PwmChannel<TIM2_CH1, WithPins> {
            self
        }
    }
    impl PwmChannel<TIM2_CH1, NoPins> {
        #[doc = " Output to a specific pin from a channel that does not yet have"]
        #[doc = " any pins.  This channel cannot be enabled until this method"]
        #[doc = " is called."]
        #[doc = ""]
        #[doc = " The pin is consumed and cannot be returned."]
        pub fn output_to_pa15(self, _p: gpioa::PA15<gpio::AF1>) -> PwmChannel<TIM2_CH1, WithPins> {
            unsafe {
                (*TIM2::ptr())
                    .ccmr1_output()
                    .modify(|_, w| w.oc1m().bits(0b0110).oc1pe().set_bit());
            }
            PwmChannel {
                timx_chy: PhantomData,
                pin_status: PhantomData,
            }
        }
    }
    impl PwmChannel<TIM2_CH1, WithPins> {
        #[doc = " Output to a specific pin from a channel is already configured"]
        #[doc = " with output pins.  There is no limit to the number of pins that"]
        #[doc = " can be used (as long as they are compatible)."]
        #[doc = ""]
        #[doc = " The pin is consumed and cannot be returned."]
        pub fn output_to_pa15(self, _p: gpioa::PA15<gpio::AF1>) -> PwmChannel<TIM2_CH1, WithPins> {
            self
        }
    }
    impl PwmChannel<TIM2_CH1, NoPins> {
        #[doc = " Output to a specific pin from a channel that does not yet have"]
        #[doc = " any pins.  This channel cannot be enabled until this method"]
        #[doc = " is called."]
        #[doc = ""]
        #[doc = " The pin is consumed and cannot be returned."]
        pub fn output_to_pd3(self, _p: gpiod::PD3<gpio::AF2>) -> PwmChannel<TIM2_CH1, WithPins> {
            unsafe {
                (*TIM2::ptr())
                    .ccmr1_output()
                    .modify(|_, w| w.oc1m().bits(0b0110).oc1pe().set_bit());
            }
            PwmChannel {
                timx_chy: PhantomData,
                pin_status: PhantomData,
            }
        }
    }
    impl PwmChannel<TIM2_CH1, WithPins> {
        #[doc = " Output to a specific pin from a channel is already configured"]
        #[doc = " with output pins.  There is no limit to the number of pins that"]
        #[doc = " can be used (as long as they are compatible)."]
        #[doc = ""]
        #[doc = " The pin is consumed and cannot be returned."]
        pub fn output_to_pd3(self, _p: gpiod::PD3<gpio::AF2>) -> PwmChannel<TIM2_CH1, WithPins> {
            self
        }
    }
    impl PwmChannel<TIM2_CH2, NoPins> {
        #[doc = " Output to a specific pin from a channel that does not yet have"]
        #[doc = " any pins.  This channel cannot be enabled until this method"]
        #[doc = " is called."]
        #[doc = ""]
        #[doc = " The pin is consumed and cannot be returned."]
        pub fn output_to_pa1(self, _p: gpioa::PA1<gpio::AF1>) -> PwmChannel<TIM2_CH2, WithPins> {
            unsafe {
                (*TIM2::ptr())
                    .ccmr1_output()
                    .modify(|_, w| w.oc2m().bits(0b0110).oc2pe().set_bit());
            }
            PwmChannel {
                timx_chy: PhantomData,
                pin_status: PhantomData,
            }
        }
    }
    impl PwmChannel<TIM2_CH2, WithPins> {
        #[doc = " Output to a specific pin from a channel is already configured"]
        #[doc = " with output pins.  There is no limit to the number of pins that"]
        #[doc = " can be used (as long as they are compatible)."]
        #[doc = ""]
        #[doc = " The pin is consumed and cannot be returned."]
        pub fn output_to_pa1(self, _p: gpioa::PA1<gpio::AF1>) -> PwmChannel<TIM2_CH2, WithPins> {
            self
        }
    }
    impl PwmChannel<TIM2_CH2, NoPins> {
        #[doc = " Output to a specific pin from a channel that does not yet have"]
        #[doc = " any pins.  This channel cannot be enabled until this method"]
        #[doc = " is called."]
        #[doc = ""]
        #[doc = " The pin is consumed and cannot be returned."]
        pub fn output_to_pb3(self, _p: gpiob::PB3<gpio::AF1>) -> PwmChannel<TIM2_CH2, WithPins> {
            unsafe {
                (*TIM2::ptr())
                    .ccmr1_output()
                    .modify(|_, w| w.oc2m().bits(0b0110).oc2pe().set_bit());
            }
            PwmChannel {
                timx_chy: PhantomData,
                pin_status: PhantomData,
            }
        }
    }
    impl PwmChannel<TIM2_CH2, WithPins> {
        #[doc = " Output to a specific pin from a channel is already configured"]
        #[doc = " with output pins.  There is no limit to the number of pins that"]
        #[doc = " can be used (as long as they are compatible)."]
        #[doc = ""]
        #[doc = " The pin is consumed and cannot be returned."]
        pub fn output_to_pb3(self, _p: gpiob::PB3<gpio::AF1>) -> PwmChannel<TIM2_CH2, WithPins> {
            self
        }
    }
    impl PwmChannel<TIM2_CH2, NoPins> {
        #[doc = " Output to a specific pin from a channel that does not yet have"]
        #[doc = " any pins.  This channel cannot be enabled until this method"]
        #[doc = " is called."]
        #[doc = ""]
        #[doc = " The pin is consumed and cannot be returned."]
        pub fn output_to_pd4(self, _p: gpiod::PD4<gpio::AF2>) -> PwmChannel<TIM2_CH2, WithPins> {
            unsafe {
                (*TIM2::ptr())
                    .ccmr1_output()
                    .modify(|_, w| w.oc2m().bits(0b0110).oc2pe().set_bit());
            }
            PwmChannel {
                timx_chy: PhantomData,
                pin_status: PhantomData,
            }
        }
    }
    impl PwmChannel<TIM2_CH2, WithPins> {
        #[doc = " Output to a specific pin from a channel is already configured"]
        #[doc = " with output pins.  There is no limit to the number of pins that"]
        #[doc = " can be used (as long as they are compatible)."]
        #[doc = ""]
        #[doc = " The pin is consumed and cannot be returned."]
        pub fn output_to_pd4(self, _p: gpiod::PD4<gpio::AF2>) -> PwmChannel<TIM2_CH2, WithPins> {
            self
        }
    }
    impl PwmChannel<TIM2_CH3, NoPins> {
        #[doc = " Output to a specific pin from a channel that does not yet have"]
        #[doc = " any pins.  This channel cannot be enabled until this method"]
        #[doc = " is called."]
        #[doc = ""]
        #[doc = " The pin is consumed and cannot be returned."]
        pub fn output_to_pa2(self, _p: gpioa::PA2<gpio::AF1>) -> PwmChannel<TIM2_CH3, WithPins> {
            unsafe {
                (*TIM2::ptr())
                    .ccmr2_output()
                    .modify(|_, w| w.oc3m().bits(0b0110).oc3pe().set_bit());
            }
            PwmChannel {
                timx_chy: PhantomData,
                pin_status: PhantomData,
            }
        }
    }
    impl PwmChannel<TIM2_CH3, WithPins> {
        #[doc = " Output to a specific pin from a channel is already configured"]
        #[doc = " with output pins.  There is no limit to the number of pins that"]
        #[doc = " can be used (as long as they are compatible)."]
        #[doc = ""]
        #[doc = " The pin is consumed and cannot be returned."]
        pub fn output_to_pa2(self, _p: gpioa::PA2<gpio::AF1>) -> PwmChannel<TIM2_CH3, WithPins> {
            self
        }
    }
    impl PwmChannel<TIM2_CH3, NoPins> {
        #[doc = " Output to a specific pin from a channel that does not yet have"]
        #[doc = " any pins.  This channel cannot be enabled until this method"]
        #[doc = " is called."]
        #[doc = ""]
        #[doc = " The pin is consumed and cannot be returned."]
        pub fn output_to_pa9(self, _p: gpioa::PA9<gpio::AF10>) -> PwmChannel<TIM2_CH3, WithPins> {
            unsafe {
                (*TIM2::ptr())
                    .ccmr2_output()
                    .modify(|_, w| w.oc3m().bits(0b0110).oc3pe().set_bit());
            }
            PwmChannel {
                timx_chy: PhantomData,
                pin_status: PhantomData,
            }
        }
    }
    impl PwmChannel<TIM2_CH3, WithPins> {
        #[doc = " Output to a specific pin from a channel is already configured"]
        #[doc = " with output pins.  There is no limit to the number of pins that"]
        #[doc = " can be used (as long as they are compatible)."]
        #[doc = ""]
        #[doc = " The pin is consumed and cannot be returned."]
        pub fn output_to_pa9(self, _p: gpioa::PA9<gpio::AF10>) -> PwmChannel<TIM2_CH3, WithPins> {
            self
        }
    }
    impl PwmChannel<TIM2_CH3, NoPins> {
        #[doc = " Output to a specific pin from a channel that does not yet have"]
        #[doc = " any pins.  This channel cannot be enabled until this method"]
        #[doc = " is called."]
        #[doc = ""]
        #[doc = " The pin is consumed and cannot be returned."]
        pub fn output_to_pb10(self, _p: gpiob::PB10<gpio::AF1>) -> PwmChannel<TIM2_CH3, WithPins> {
            unsafe {
                (*TIM2::ptr())
                    .ccmr2_output()
                    .modify(|_, w| w.oc3m().bits(0b0110).oc3pe().set_bit());
            }
            PwmChannel {
                timx_chy: PhantomData,
                pin_status: PhantomData,
            }
        }
    }
    impl PwmChannel<TIM2_CH3, WithPins> {
        #[doc = " Output to a specific pin from a channel is already configured"]
        #[doc = " with output pins.  There is no limit to the number of pins that"]
        #[doc = " can be used (as long as they are compatible)."]
        #[doc = ""]
        #[doc = " The pin is consumed and cannot be returned."]
        pub fn output_to_pb10(self, _p: gpiob::PB10<gpio::AF1>) -> PwmChannel<TIM2_CH3, WithPins> {
            self
        }
    }
    impl PwmChannel<TIM2_CH3, NoPins> {
        #[doc = " Output to a specific pin from a channel that does not yet have"]
        #[doc = " any pins.  This channel cannot be enabled until this method"]
        #[doc = " is called."]
        #[doc = ""]
        #[doc = " The pin is consumed and cannot be returned."]
        pub fn output_to_pd7(self, _p: gpiod::PD7<gpio::AF2>) -> PwmChannel<TIM2_CH3, WithPins> {
            unsafe {
                (*TIM2::ptr())
                    .ccmr2_output()
                    .modify(|_, w| w.oc3m().bits(0b0110).oc3pe().set_bit());
            }
            PwmChannel {
                timx_chy: PhantomData,
                pin_status: PhantomData,
            }
        }
    }
    impl PwmChannel<TIM2_CH3, WithPins> {
        #[doc = " Output to a specific pin from a channel is already configured"]
        #[doc = " with output pins.  There is no limit to the number of pins that"]
        #[doc = " can be used (as long as they are compatible)."]
        #[doc = ""]
        #[doc = " The pin is consumed and cannot be returned."]
        pub fn output_to_pd7(self, _p: gpiod::PD7<gpio::AF2>) -> PwmChannel<TIM2_CH3, WithPins> {
            self
        }
    }
    impl PwmChannel<TIM2_CH4, NoPins> {
        #[doc = " Output to a specific pin from a channel that does not yet have"]
        #[doc = " any pins.  This channel cannot be enabled until this method"]
        #[doc = " is called."]
        #[doc = ""]
        #[doc = " The pin is consumed and cannot be returned."]
        pub fn output_to_pa3(self, _p: gpioa::PA3<gpio::AF1>) -> PwmChannel<TIM2_CH4, WithPins> {
            unsafe {
                (*TIM2::ptr())
                    .ccmr2_output()
                    .modify(|_, w| w.oc4m().bits(0b0110).oc4pe().set_bit());
            }
            PwmChannel {
                timx_chy: PhantomData,
                pin_status: PhantomData,
            }
        }
    }
    impl PwmChannel<TIM2_CH4, WithPins> {
        #[doc = " Output to a specific pin from a channel is already configured"]
        #[doc = " with output pins.  There is no limit to the number of pins that"]
        #[doc = " can be used (as long as they are compatible)."]
        #[doc = ""]
        #[doc = " The pin is consumed and cannot be returned."]
        pub fn output_to_pa3(self, _p: gpioa::PA3<gpio::AF1>) -> PwmChannel<TIM2_CH4, WithPins> {
            self
        }
    }
    impl PwmChannel<TIM2_CH4, NoPins> {
        #[doc = " Output to a specific pin from a channel that does not yet have"]
        #[doc = " any pins.  This channel cannot be enabled until this method"]
        #[doc = " is called."]
        #[doc = ""]
        #[doc = " The pin is consumed and cannot be returned."]
        pub fn output_to_pa10(self, _p: gpioa::PA10<gpio::AF1>) -> PwmChannel<TIM2_CH4, WithPins> {
            unsafe {
                (*TIM2::ptr())
                    .ccmr2_output()
                    .modify(|_, w| w.oc4m().bits(0b0110).oc4pe().set_bit());
            }
            PwmChannel {
                timx_chy: PhantomData,
                pin_status: PhantomData,
            }
        }
    }
    impl PwmChannel<TIM2_CH4, WithPins> {
        #[doc = " Output to a specific pin from a channel is already configured"]
        #[doc = " with output pins.  There is no limit to the number of pins that"]
        #[doc = " can be used (as long as they are compatible)."]
        #[doc = ""]
        #[doc = " The pin is consumed and cannot be returned."]
        pub fn output_to_pa10(self, _p: gpioa::PA10<gpio::AF1>) -> PwmChannel<TIM2_CH4, WithPins> {
            self
        }
    }
    impl PwmChannel<TIM2_CH4, NoPins> {
        #[doc = " Output to a specific pin from a channel that does not yet have"]
        #[doc = " any pins.  This channel cannot be enabled until this method"]
        #[doc = " is called."]
        #[doc = ""]
        #[doc = " The pin is consumed and cannot be returned."]
        pub fn output_to_pb11(self, _p: gpiob::PB11<gpio::AF1>) -> PwmChannel<TIM2_CH4, WithPins> {
            unsafe {
                (*TIM2::ptr())
                    .ccmr2_output()
                    .modify(|_, w| w.oc4m().bits(0b0110).oc4pe().set_bit());
            }
            PwmChannel {
                timx_chy: PhantomData,
                pin_status: PhantomData,
            }
        }
    }
    impl PwmChannel<TIM2_CH4, WithPins> {
        #[doc = " Output to a specific pin from a channel is already configured"]
        #[doc = " with output pins.  There is no limit to the number of pins that"]
        #[doc = " can be used (as long as they are compatible)."]
        #[doc = ""]
        #[doc = " The pin is consumed and cannot be returned."]
        pub fn output_to_pb11(self, _p: gpiob::PB11<gpio::AF1>) -> PwmChannel<TIM2_CH4, WithPins> {
            self
        }
    }
    impl PwmChannel<TIM2_CH4, NoPins> {
        #[doc = " Output to a specific pin from a channel that does not yet have"]
        #[doc = " any pins.  This channel cannot be enabled until this method"]
        #[doc = " is called."]
        #[doc = ""]
        #[doc = " The pin is consumed and cannot be returned."]
        pub fn output_to_pd6(self, _p: gpiod::PD6<gpio::AF2>) -> PwmChannel<TIM2_CH4, WithPins> {
            unsafe {
                (*TIM2::ptr())
                    .ccmr2_output()
                    .modify(|_, w| w.oc4m().bits(0b0110).oc4pe().set_bit());
            }
            PwmChannel {
                timx_chy: PhantomData,
                pin_status: PhantomData,
            }
        }
    }
    impl PwmChannel<TIM2_CH4, WithPins> {
        #[doc = " Output to a specific pin from a channel is already configured"]
        #[doc = " with output pins.  There is no limit to the number of pins that"]
        #[doc = " can be used (as long as they are compatible)."]
        #[doc = ""]
        #[doc = " The pin is consumed and cannot be returned."]
        pub fn output_to_pd6(self, _p: gpiod::PD6<gpio::AF2>) -> PwmChannel<TIM2_CH4, WithPins> {
            self
        }
    }
    use crate::pac::TIM3;
    #[doc = " Output Compare Channel 1 of Timer 3 (type state)"]
    pub struct TIM3_CH1 {}
    #[doc = " Output Compare Channel 2 of Timer 3 (type state)"]
    pub struct TIM3_CH2 {}
    #[doc = " Output Compare Channel 3 of Timer 3 (type state)"]
    pub struct TIM3_CH3 {}
    #[doc = " Output Compare Channel 4 of Timer 3 (type state)"]
    pub struct TIM3_CH4 {}
    #[doc = " Create one or more output channels from a TIM Peripheral"]
    #[doc = " This function requires the maximum resolution of the duty cycle,"]
    #[doc = " the period of the PWM signal and the frozen clock configuration."]
    #[doc = ""]
    #[doc = " The resolution should be chosen to offer sufficient steps against"]
    #[doc = " your target peripheral.  For example, a servo that can turn from"]
    #[doc = " 0 degrees (2% duty cycle) to 180 degrees (4% duty cycle) might choose"]
    #[doc = " a resolution of 9000.  This allows the servo to be set in increments"]
    #[doc = " of exactly one degree."]
    #[allow(unused_parens)]
    pub fn tim3(
        tim: TIM3,
        res: u16,
        freq: Hertz,
        clocks: &Clocks,
    ) -> (
        PwmChannel<TIM3_CH1, NoPins>,
        PwmChannel<TIM3_CH2, NoPins>,
        PwmChannel<TIM3_CH3, NoPins>,
        PwmChannel<TIM3_CH4, NoPins>,
    ) {
        unsafe {
            (*RCC::ptr()).apb1enr.modify(|_, w| w.tim3en().set_bit());
            (*RCC::ptr()).apb1rstr.modify(|_, w| w.tim3rst().set_bit());
            (*RCC::ptr())
                .apb1rstr
                .modify(|_, w| w.tim3rst().clear_bit());
        }
        tim.cr1.modify(|_, w| w.arpe().set_bit());
        #[allow(unused_unsafe)]
        tim.arr.write(|w| unsafe { w.arr().bits(res) });
        let clock_freq = clocks.pclk1().0 * if clocks.ppre1() == 1 { 1 } else { 2 };
        let prescale_factor = clock_freq / res as u32 / freq.0;
        tim.psc.write(|w| w.psc().bits(prescale_factor as u16 - 1));
        tim.egr.write(|w| w.ug().set_bit());
        (|_| ())(&tim);
        tim.cr1.modify(|_, w| w.cen().set_bit());
        (
            PwmChannel {
                timx_chy: PhantomData,
                pin_status: PhantomData,
            },
            PwmChannel {
                timx_chy: PhantomData,
                pin_status: PhantomData,
            },
            PwmChannel {
                timx_chy: PhantomData,
                pin_status: PhantomData,
            },
            PwmChannel {
                timx_chy: PhantomData,
                pin_status: PhantomData,
            },
        )
    }
    impl PwmPin for PwmChannel<TIM3_CH1, WithPins> {
        type Duty = u16;
        fn disable(&mut self) {
            unsafe {
                (*TIM3::ptr()).ccer.modify(|_, w| w.cc1e().clear_bit());
            }
        }
        fn enable(&mut self) {
            unsafe {
                (*TIM3::ptr()).ccer.modify(|_, w| w.cc1e().set_bit());
            }
        }
        fn get_max_duty(&self) -> Self::Duty {
            unsafe { (*TIM3::ptr()).arr.read().arr().bits() }
        }
        fn get_duty(&self) -> Self::Duty {
            unsafe { (*TIM3::ptr()).ccr1.read().ccr().bits() }
        }
        fn set_duty(&mut self, duty: Self::Duty) -> () {
            unsafe {
                (*TIM3::ptr()).ccr1.modify(|_, w| w.ccr().bits(duty));
            }
        }
    }
    impl PwmPin for PwmChannel<TIM3_CH2, WithPins> {
        type Duty = u16;
        fn disable(&mut self) {
            unsafe {
                (*TIM3::ptr()).ccer.modify(|_, w| w.cc2e().clear_bit());
            }
        }
        fn enable(&mut self) {
            unsafe {
                (*TIM3::ptr()).ccer.modify(|_, w| w.cc2e().set_bit());
            }
        }
        fn get_max_duty(&self) -> Self::Duty {
            unsafe { (*TIM3::ptr()).arr.read().arr().bits() }
        }
        fn get_duty(&self) -> Self::Duty {
            unsafe { (*TIM3::ptr()).ccr2.read().ccr().bits() }
        }
        fn set_duty(&mut self, duty: Self::Duty) -> () {
            unsafe {
                (*TIM3::ptr()).ccr2.modify(|_, w| w.ccr().bits(duty));
            }
        }
    }
    impl PwmPin for PwmChannel<TIM3_CH3, WithPins> {
        type Duty = u16;
        fn disable(&mut self) {
            unsafe {
                (*TIM3::ptr()).ccer.modify(|_, w| w.cc3e().clear_bit());
            }
        }
        fn enable(&mut self) {
            unsafe {
                (*TIM3::ptr()).ccer.modify(|_, w| w.cc3e().set_bit());
            }
        }
        fn get_max_duty(&self) -> Self::Duty {
            unsafe { (*TIM3::ptr()).arr.read().arr().bits() }
        }
        fn get_duty(&self) -> Self::Duty {
            unsafe { (*TIM3::ptr()).ccr3.read().ccr().bits() }
        }
        fn set_duty(&mut self, duty: Self::Duty) -> () {
            unsafe {
                (*TIM3::ptr()).ccr3.modify(|_, w| w.ccr().bits(duty));
            }
        }
    }
    impl PwmPin for PwmChannel<TIM3_CH4, WithPins> {
        type Duty = u16;
        fn disable(&mut self) {
            unsafe {
                (*TIM3::ptr()).ccer.modify(|_, w| w.cc4e().clear_bit());
            }
        }
        fn enable(&mut self) {
            unsafe {
                (*TIM3::ptr()).ccer.modify(|_, w| w.cc4e().set_bit());
            }
        }
        fn get_max_duty(&self) -> Self::Duty {
            unsafe { (*TIM3::ptr()).arr.read().arr().bits() }
        }
        fn get_duty(&self) -> Self::Duty {
            unsafe { (*TIM3::ptr()).ccr4.read().ccr().bits() }
        }
        fn set_duty(&mut self, duty: Self::Duty) -> () {
            unsafe {
                (*TIM3::ptr()).ccr4.modify(|_, w| w.ccr().bits(duty));
            }
        }
    }
    impl PwmChannel<TIM3_CH1, NoPins> {
        #[doc = " Output to a specific pin from a channel that does not yet have"]
        #[doc = " any pins.  This channel cannot be enabled until this method"]
        #[doc = " is called."]
        #[doc = ""]
        #[doc = " The pin is consumed and cannot be returned."]
        pub fn output_to_pa6(self, _p: gpioa::PA6<gpio::AF2>) -> PwmChannel<TIM3_CH1, WithPins> {
            unsafe {
                (*TIM3::ptr())
                    .ccmr1_output()
                    .modify(|_, w| w.oc1m().bits(0b0110).oc1pe().set_bit());
            }
            PwmChannel {
                timx_chy: PhantomData,
                pin_status: PhantomData,
            }
        }
    }
    impl PwmChannel<TIM3_CH1, WithPins> {
        #[doc = " Output to a specific pin from a channel is already configured"]
        #[doc = " with output pins.  There is no limit to the number of pins that"]
        #[doc = " can be used (as long as they are compatible)."]
        #[doc = ""]
        #[doc = " The pin is consumed and cannot be returned."]
        pub fn output_to_pa6(self, _p: gpioa::PA6<gpio::AF2>) -> PwmChannel<TIM3_CH1, WithPins> {
            self
        }
    }
    impl PwmChannel<TIM3_CH1, NoPins> {
        #[doc = " Output to a specific pin from a channel that does not yet have"]
        #[doc = " any pins.  This channel cannot be enabled until this method"]
        #[doc = " is called."]
        #[doc = ""]
        #[doc = " The pin is consumed and cannot be returned."]
        pub fn output_to_pb4(self, _p: gpiob::PB4<gpio::AF2>) -> PwmChannel<TIM3_CH1, WithPins> {
            unsafe {
                (*TIM3::ptr())
                    .ccmr1_output()
                    .modify(|_, w| w.oc1m().bits(0b0110).oc1pe().set_bit());
            }
            PwmChannel {
                timx_chy: PhantomData,
                pin_status: PhantomData,
            }
        }
    }
    impl PwmChannel<TIM3_CH1, WithPins> {
        #[doc = " Output to a specific pin from a channel is already configured"]
        #[doc = " with output pins.  There is no limit to the number of pins that"]
        #[doc = " can be used (as long as they are compatible)."]
        #[doc = ""]
        #[doc = " The pin is consumed and cannot be returned."]
        pub fn output_to_pb4(self, _p: gpiob::PB4<gpio::AF2>) -> PwmChannel<TIM3_CH1, WithPins> {
            self
        }
    }
    impl PwmChannel<TIM3_CH2, NoPins> {
        #[doc = " Output to a specific pin from a channel that does not yet have"]
        #[doc = " any pins.  This channel cannot be enabled until this method"]
        #[doc = " is called."]
        #[doc = ""]
        #[doc = " The pin is consumed and cannot be returned."]
        pub fn output_to_pa4(self, _p: gpioa::PA4<gpio::AF2>) -> PwmChannel<TIM3_CH2, WithPins> {
            unsafe {
                (*TIM3::ptr())
                    .ccmr1_output()
                    .modify(|_, w| w.oc2m().bits(0b0110).oc2pe().set_bit());
            }
            PwmChannel {
                timx_chy: PhantomData,
                pin_status: PhantomData,
            }
        }
    }
    impl PwmChannel<TIM3_CH2, WithPins> {
        #[doc = " Output to a specific pin from a channel is already configured"]
        #[doc = " with output pins.  There is no limit to the number of pins that"]
        #[doc = " can be used (as long as they are compatible)."]
        #[doc = ""]
        #[doc = " The pin is consumed and cannot be returned."]
        pub fn output_to_pa4(self, _p: gpioa::PA4<gpio::AF2>) -> PwmChannel<TIM3_CH2, WithPins> {
            self
        }
    }
    impl PwmChannel<TIM3_CH2, NoPins> {
        #[doc = " Output to a specific pin from a channel that does not yet have"]
        #[doc = " any pins.  This channel cannot be enabled until this method"]
        #[doc = " is called."]
        #[doc = ""]
        #[doc = " The pin is consumed and cannot be returned."]
        pub fn output_to_pa7(self, _p: gpioa::PA7<gpio::AF2>) -> PwmChannel<TIM3_CH2, WithPins> {
            unsafe {
                (*TIM3::ptr())
                    .ccmr1_output()
                    .modify(|_, w| w.oc2m().bits(0b0110).oc2pe().set_bit());
            }
            PwmChannel {
                timx_chy: PhantomData,
                pin_status: PhantomData,
            }
        }
    }
    impl PwmChannel<TIM3_CH2, WithPins> {
        #[doc = " Output to a specific pin from a channel is already configured"]
        #[doc = " with output pins.  There is no limit to the number of pins that"]
        #[doc = " can be used (as long as they are compatible)."]
        #[doc = ""]
        #[doc = " The pin is consumed and cannot be returned."]
        pub fn output_to_pa7(self, _p: gpioa::PA7<gpio::AF2>) -> PwmChannel<TIM3_CH2, WithPins> {
            self
        }
    }
    impl PwmChannel<TIM3_CH2, NoPins> {
        #[doc = " Output to a specific pin from a channel that does not yet have"]
        #[doc = " any pins.  This channel cannot be enabled until this method"]
        #[doc = " is called."]
        #[doc = ""]
        #[doc = " The pin is consumed and cannot be returned."]
        pub fn output_to_pb5(self, _p: gpiob::PB5<gpio::AF2>) -> PwmChannel<TIM3_CH2, WithPins> {
            unsafe {
                (*TIM3::ptr())
                    .ccmr1_output()
                    .modify(|_, w| w.oc2m().bits(0b0110).oc2pe().set_bit());
            }
            PwmChannel {
                timx_chy: PhantomData,
                pin_status: PhantomData,
            }
        }
    }
    impl PwmChannel<TIM3_CH2, WithPins> {
        #[doc = " Output to a specific pin from a channel is already configured"]
        #[doc = " with output pins.  There is no limit to the number of pins that"]
        #[doc = " can be used (as long as they are compatible)."]
        #[doc = ""]
        #[doc = " The pin is consumed and cannot be returned."]
        pub fn output_to_pb5(self, _p: gpiob::PB5<gpio::AF2>) -> PwmChannel<TIM3_CH2, WithPins> {
            self
        }
    }
    impl PwmChannel<TIM3_CH3, NoPins> {
        #[doc = " Output to a specific pin from a channel that does not yet have"]
        #[doc = " any pins.  This channel cannot be enabled until this method"]
        #[doc = " is called."]
        #[doc = ""]
        #[doc = " The pin is consumed and cannot be returned."]
        pub fn output_to_pb0(self, _p: gpiob::PB0<gpio::AF2>) -> PwmChannel<TIM3_CH3, WithPins> {
            unsafe {
                (*TIM3::ptr())
                    .ccmr2_output()
                    .modify(|_, w| w.oc3m().bits(0b0110).oc3pe().set_bit());
            }
            PwmChannel {
                timx_chy: PhantomData,
                pin_status: PhantomData,
            }
        }
    }
    impl PwmChannel<TIM3_CH3, WithPins> {
        #[doc = " Output to a specific pin from a channel is already configured"]
        #[doc = " with output pins.  There is no limit to the number of pins that"]
        #[doc = " can be used (as long as they are compatible)."]
        #[doc = ""]
        #[doc = " The pin is consumed and cannot be returned."]
        pub fn output_to_pb0(self, _p: gpiob::PB0<gpio::AF2>) -> PwmChannel<TIM3_CH3, WithPins> {
            self
        }
    }
    impl PwmChannel<TIM3_CH4, NoPins> {
        #[doc = " Output to a specific pin from a channel that does not yet have"]
        #[doc = " any pins.  This channel cannot be enabled until this method"]
        #[doc = " is called."]
        #[doc = ""]
        #[doc = " The pin is consumed and cannot be returned."]
        pub fn output_to_pb1(self, _p: gpiob::PB1<gpio::AF2>) -> PwmChannel<TIM3_CH4, WithPins> {
            unsafe {
                (*TIM3::ptr())
                    .ccmr2_output()
                    .modify(|_, w| w.oc4m().bits(0b0110).oc4pe().set_bit());
            }
            PwmChannel {
                timx_chy: PhantomData,
                pin_status: PhantomData,
            }
        }
    }
    impl PwmChannel<TIM3_CH4, WithPins> {
        #[doc = " Output to a specific pin from a channel is already configured"]
        #[doc = " with output pins.  There is no limit to the number of pins that"]
        #[doc = " can be used (as long as they are compatible)."]
        #[doc = ""]
        #[doc = " The pin is consumed and cannot be returned."]
        pub fn output_to_pb1(self, _p: gpiob::PB1<gpio::AF2>) -> PwmChannel<TIM3_CH4, WithPins> {
            self
        }
    }
    impl PwmChannel<TIM3_CH4, NoPins> {
        #[doc = " Output to a specific pin from a channel that does not yet have"]
        #[doc = " any pins.  This channel cannot be enabled until this method"]
        #[doc = " is called."]
        #[doc = ""]
        #[doc = " The pin is consumed and cannot be returned."]
        pub fn output_to_pb7(self, _p: gpiob::PB7<gpio::AF10>) -> PwmChannel<TIM3_CH4, WithPins> {
            unsafe {
                (*TIM3::ptr())
                    .ccmr2_output()
                    .modify(|_, w| w.oc4m().bits(0b0110).oc4pe().set_bit());
            }
            PwmChannel {
                timx_chy: PhantomData,
                pin_status: PhantomData,
            }
        }
    }
    impl PwmChannel<TIM3_CH4, WithPins> {
        #[doc = " Output to a specific pin from a channel is already configured"]
        #[doc = " with output pins.  There is no limit to the number of pins that"]
        #[doc = " can be used (as long as they are compatible)."]
        #[doc = ""]
        #[doc = " The pin is consumed and cannot be returned."]
        pub fn output_to_pb7(self, _p: gpiob::PB7<gpio::AF10>) -> PwmChannel<TIM3_CH4, WithPins> {
            self
        }
    }
    impl PwmChannel<TIM3_CH1, NoPins> {
        #[doc = " Output to a specific pin from a channel that does not yet have"]
        #[doc = " any pins.  This channel cannot be enabled until this method"]
        #[doc = " is called."]
        #[doc = ""]
        #[doc = " The pin is consumed and cannot be returned."]
        pub fn output_to_pc6(self, _p: gpioc::PC6<gpio::AF2>) -> PwmChannel<TIM3_CH1, WithPins> {
            unsafe {
                (*TIM3::ptr())
                    .ccmr1_output()
                    .modify(|_, w| w.oc1m().bits(0b0110).oc1pe().set_bit());
            }
            PwmChannel {
                timx_chy: PhantomData,
                pin_status: PhantomData,
            }
        }
    }
    impl PwmChannel<TIM3_CH1, WithPins> {
        #[doc = " Output to a specific pin from a channel is already configured"]
        #[doc = " with output pins.  There is no limit to the number of pins that"]
        #[doc = " can be used (as long as they are compatible)."]
        #[doc = ""]
        #[doc = " The pin is consumed and cannot be returned."]
        pub fn output_to_pc6(self, _p: gpioc::PC6<gpio::AF2>) -> PwmChannel<TIM3_CH1, WithPins> {
            self
        }
    }
    impl PwmChannel<TIM3_CH2, NoPins> {
        #[doc = " Output to a specific pin from a channel that does not yet have"]
        #[doc = " any pins.  This channel cannot be enabled until this method"]
        #[doc = " is called."]
        #[doc = ""]
        #[doc = " The pin is consumed and cannot be returned."]
        pub fn output_to_pc7(self, _p: gpioc::PC7<gpio::AF2>) -> PwmChannel<TIM3_CH2, WithPins> {
            unsafe {
                (*TIM3::ptr())
                    .ccmr1_output()
                    .modify(|_, w| w.oc2m().bits(0b0110).oc2pe().set_bit());
            }
            PwmChannel {
                timx_chy: PhantomData,
                pin_status: PhantomData,
            }
        }
    }
    impl PwmChannel<TIM3_CH2, WithPins> {
        #[doc = " Output to a specific pin from a channel is already configured"]
        #[doc = " with output pins.  There is no limit to the number of pins that"]
        #[doc = " can be used (as long as they are compatible)."]
        #[doc = ""]
        #[doc = " The pin is consumed and cannot be returned."]
        pub fn output_to_pc7(self, _p: gpioc::PC7<gpio::AF2>) -> PwmChannel<TIM3_CH2, WithPins> {
            self
        }
    }
    impl PwmChannel<TIM3_CH3, NoPins> {
        #[doc = " Output to a specific pin from a channel that does not yet have"]
        #[doc = " any pins.  This channel cannot be enabled until this method"]
        #[doc = " is called."]
        #[doc = ""]
        #[doc = " The pin is consumed and cannot be returned."]
        pub fn output_to_pc8(self, _p: gpioc::PC8<gpio::AF2>) -> PwmChannel<TIM3_CH3, WithPins> {
            unsafe {
                (*TIM3::ptr())
                    .ccmr2_output()
                    .modify(|_, w| w.oc3m().bits(0b0110).oc3pe().set_bit());
            }
            PwmChannel {
                timx_chy: PhantomData,
                pin_status: PhantomData,
            }
        }
    }
    impl PwmChannel<TIM3_CH3, WithPins> {
        #[doc = " Output to a specific pin from a channel is already configured"]
        #[doc = " with output pins.  There is no limit to the number of pins that"]
        #[doc = " can be used (as long as they are compatible)."]
        #[doc = ""]
        #[doc = " The pin is consumed and cannot be returned."]
        pub fn output_to_pc8(self, _p: gpioc::PC8<gpio::AF2>) -> PwmChannel<TIM3_CH3, WithPins> {
            self
        }
    }
    impl PwmChannel<TIM3_CH4, NoPins> {
        #[doc = " Output to a specific pin from a channel that does not yet have"]
        #[doc = " any pins.  This channel cannot be enabled until this method"]
        #[doc = " is called."]
        #[doc = ""]
        #[doc = " The pin is consumed and cannot be returned."]
        pub fn output_to_pc9(self, _p: gpioc::PC9<gpio::AF2>) -> PwmChannel<TIM3_CH4, WithPins> {
            unsafe {
                (*TIM3::ptr())
                    .ccmr2_output()
                    .modify(|_, w| w.oc4m().bits(0b0110).oc4pe().set_bit());
            }
            PwmChannel {
                timx_chy: PhantomData,
                pin_status: PhantomData,
            }
        }
    }
    impl PwmChannel<TIM3_CH4, WithPins> {
        #[doc = " Output to a specific pin from a channel is already configured"]
        #[doc = " with output pins.  There is no limit to the number of pins that"]
        #[doc = " can be used (as long as they are compatible)."]
        #[doc = ""]
        #[doc = " The pin is consumed and cannot be returned."]
        pub fn output_to_pc9(self, _p: gpioc::PC9<gpio::AF2>) -> PwmChannel<TIM3_CH4, WithPins> {
            self
        }
    }
    impl PwmChannel<TIM3_CH1, NoPins> {
        #[doc = " Output to a specific pin from a channel that does not yet have"]
        #[doc = " any pins.  This channel cannot be enabled until this method"]
        #[doc = " is called."]
        #[doc = ""]
        #[doc = " The pin is consumed and cannot be returned."]
        pub fn output_to_pe2(self, _p: gpioe::PE6<gpio::AF2>) -> PwmChannel<TIM3_CH1, WithPins> {
            unsafe {
                (*TIM3::ptr())
                    .ccmr1_output()
                    .modify(|_, w| w.oc1m().bits(0b0110).oc1pe().set_bit());
            }
            PwmChannel {
                timx_chy: PhantomData,
                pin_status: PhantomData,
            }
        }
    }
    impl PwmChannel<TIM3_CH1, WithPins> {
        #[doc = " Output to a specific pin from a channel is already configured"]
        #[doc = " with output pins.  There is no limit to the number of pins that"]
        #[doc = " can be used (as long as they are compatible)."]
        #[doc = ""]
        #[doc = " The pin is consumed and cannot be returned."]
        pub fn output_to_pe2(self, _p: gpioe::PE6<gpio::AF2>) -> PwmChannel<TIM3_CH1, WithPins> {
            self
        }
    }
    impl PwmChannel<TIM3_CH2, NoPins> {
        #[doc = " Output to a specific pin from a channel that does not yet have"]
        #[doc = " any pins.  This channel cannot be enabled until this method"]
        #[doc = " is called."]
        #[doc = ""]
        #[doc = " The pin is consumed and cannot be returned."]
        pub fn output_to_pe3(self, _p: gpioe::PE7<gpio::AF2>) -> PwmChannel<TIM3_CH2, WithPins> {
            unsafe {
                (*TIM3::ptr())
                    .ccmr1_output()
                    .modify(|_, w| w.oc2m().bits(0b0110).oc2pe().set_bit());
            }
            PwmChannel {
                timx_chy: PhantomData,
                pin_status: PhantomData,
            }
        }
    }
    impl PwmChannel<TIM3_CH2, WithPins> {
        #[doc = " Output to a specific pin from a channel is already configured"]
        #[doc = " with output pins.  There is no limit to the number of pins that"]
        #[doc = " can be used (as long as they are compatible)."]
        #[doc = ""]
        #[doc = " The pin is consumed and cannot be returned."]
        pub fn output_to_pe3(self, _p: gpioe::PE7<gpio::AF2>) -> PwmChannel<TIM3_CH2, WithPins> {
            self
        }
    }
    impl PwmChannel<TIM3_CH3, NoPins> {
        #[doc = " Output to a specific pin from a channel that does not yet have"]
        #[doc = " any pins.  This channel cannot be enabled until this method"]
        #[doc = " is called."]
        #[doc = ""]
        #[doc = " The pin is consumed and cannot be returned."]
        pub fn output_to_pe4(self, _p: gpioe::PE8<gpio::AF2>) -> PwmChannel<TIM3_CH3, WithPins> {
            unsafe {
                (*TIM3::ptr())
                    .ccmr2_output()
                    .modify(|_, w| w.oc3m().bits(0b0110).oc3pe().set_bit());
            }
            PwmChannel {
                timx_chy: PhantomData,
                pin_status: PhantomData,
            }
        }
    }
    impl PwmChannel<TIM3_CH3, WithPins> {
        #[doc = " Output to a specific pin from a channel is already configured"]
        #[doc = " with output pins.  There is no limit to the number of pins that"]
        #[doc = " can be used (as long as they are compatible)."]
        #[doc = ""]
        #[doc = " The pin is consumed and cannot be returned."]
        pub fn output_to_pe4(self, _p: gpioe::PE8<gpio::AF2>) -> PwmChannel<TIM3_CH3, WithPins> {
            self
        }
    }
    impl PwmChannel<TIM3_CH4, NoPins> {
        #[doc = " Output to a specific pin from a channel that does not yet have"]
        #[doc = " any pins.  This channel cannot be enabled until this method"]
        #[doc = " is called."]
        #[doc = ""]
        #[doc = " The pin is consumed and cannot be returned."]
        pub fn output_to_pe5(self, _p: gpioe::PE9<gpio::AF2>) -> PwmChannel<TIM3_CH4, WithPins> {
            unsafe {
                (*TIM3::ptr())
                    .ccmr2_output()
                    .modify(|_, w| w.oc4m().bits(0b0110).oc4pe().set_bit());
            }
            PwmChannel {
                timx_chy: PhantomData,
                pin_status: PhantomData,
            }
        }
    }
    impl PwmChannel<TIM3_CH4, WithPins> {
        #[doc = " Output to a specific pin from a channel is already configured"]
        #[doc = " with output pins.  There is no limit to the number of pins that"]
        #[doc = " can be used (as long as they are compatible)."]
        #[doc = ""]
        #[doc = " The pin is consumed and cannot be returned."]
        pub fn output_to_pe5(self, _p: gpioe::PE9<gpio::AF2>) -> PwmChannel<TIM3_CH4, WithPins> {
            self
        }
    }
    use crate::pac::TIM4;
    #[doc = " Output Compare Channel 1 of Timer 4 (type state)"]
    pub struct TIM4_CH1 {}
    #[doc = " Output Compare Channel 2 of Timer 4 (type state)"]
    pub struct TIM4_CH2 {}
    #[doc = " Output Compare Channel 3 of Timer 4 (type state)"]
    pub struct TIM4_CH3 {}
    #[doc = " Output Compare Channel 4 of Timer 4 (type state)"]
    pub struct TIM4_CH4 {}
    #[doc = " Create one or more output channels from a TIM Peripheral"]
    #[doc = " This function requires the maximum resolution of the duty cycle,"]
    #[doc = " the period of the PWM signal and the frozen clock configuration."]
    #[doc = ""]
    #[doc = " The resolution should be chosen to offer sufficient steps against"]
    #[doc = " your target peripheral.  For example, a servo that can turn from"]
    #[doc = " 0 degrees (2% duty cycle) to 180 degrees (4% duty cycle) might choose"]
    #[doc = " a resolution of 9000.  This allows the servo to be set in increments"]
    #[doc = " of exactly one degree."]
    #[allow(unused_parens)]
    pub fn tim4(
        tim: TIM4,
        res: u16,
        freq: Hertz,
        clocks: &Clocks,
    ) -> (
        PwmChannel<TIM4_CH1, NoPins>,
        PwmChannel<TIM4_CH2, NoPins>,
        PwmChannel<TIM4_CH3, NoPins>,
        PwmChannel<TIM4_CH4, NoPins>,
    ) {
        unsafe {
            (*RCC::ptr()).apb1enr.modify(|_, w| w.tim4en().set_bit());
            (*RCC::ptr()).apb1rstr.modify(|_, w| w.tim4rst().set_bit());
            (*RCC::ptr())
                .apb1rstr
                .modify(|_, w| w.tim4rst().clear_bit());
        }
        tim.cr1.modify(|_, w| w.arpe().set_bit());
        #[allow(unused_unsafe)]
        tim.arr.write(|w| unsafe { w.arr().bits(res) });
        let clock_freq = clocks.pclk1().0 * if clocks.ppre1() == 1 { 1 } else { 2 };
        let prescale_factor = clock_freq / res as u32 / freq.0;
        tim.psc.write(|w| w.psc().bits(prescale_factor as u16 - 1));
        tim.egr.write(|w| w.ug().set_bit());
        (|_| ())(&tim);
        tim.cr1.modify(|_, w| w.cen().set_bit());
        (
            PwmChannel {
                timx_chy: PhantomData,
                pin_status: PhantomData,
            },
            PwmChannel {
                timx_chy: PhantomData,
                pin_status: PhantomData,
            },
            PwmChannel {
                timx_chy: PhantomData,
                pin_status: PhantomData,
            },
            PwmChannel {
                timx_chy: PhantomData,
                pin_status: PhantomData,
            },
        )
    }
    impl PwmPin for PwmChannel<TIM4_CH1, WithPins> {
        type Duty = u16;
        fn disable(&mut self) {
            unsafe {
                (*TIM4::ptr()).ccer.modify(|_, w| w.cc1e().clear_bit());
            }
        }
        fn enable(&mut self) {
            unsafe {
                (*TIM4::ptr()).ccer.modify(|_, w| w.cc1e().set_bit());
            }
        }
        fn get_max_duty(&self) -> Self::Duty {
            unsafe { (*TIM4::ptr()).arr.read().arr().bits() }
        }
        fn get_duty(&self) -> Self::Duty {
            unsafe { (*TIM4::ptr()).ccr1.read().ccr().bits() }
        }
        fn set_duty(&mut self, duty: Self::Duty) -> () {
            unsafe {
                (*TIM4::ptr()).ccr1.modify(|_, w| w.ccr().bits(duty));
            }
        }
    }
    impl PwmPin for PwmChannel<TIM4_CH2, WithPins> {
        type Duty = u16;
        fn disable(&mut self) {
            unsafe {
                (*TIM4::ptr()).ccer.modify(|_, w| w.cc2e().clear_bit());
            }
        }
        fn enable(&mut self) {
            unsafe {
                (*TIM4::ptr()).ccer.modify(|_, w| w.cc2e().set_bit());
            }
        }
        fn get_max_duty(&self) -> Self::Duty {
            unsafe { (*TIM4::ptr()).arr.read().arr().bits() }
        }
        fn get_duty(&self) -> Self::Duty {
            unsafe { (*TIM4::ptr()).ccr2.read().ccr().bits() }
        }
        fn set_duty(&mut self, duty: Self::Duty) -> () {
            unsafe {
                (*TIM4::ptr()).ccr2.modify(|_, w| w.ccr().bits(duty));
            }
        }
    }
    impl PwmPin for PwmChannel<TIM4_CH3, WithPins> {
        type Duty = u16;
        fn disable(&mut self) {
            unsafe {
                (*TIM4::ptr()).ccer.modify(|_, w| w.cc3e().clear_bit());
            }
        }
        fn enable(&mut self) {
            unsafe {
                (*TIM4::ptr()).ccer.modify(|_, w| w.cc3e().set_bit());
            }
        }
        fn get_max_duty(&self) -> Self::Duty {
            unsafe { (*TIM4::ptr()).arr.read().arr().bits() }
        }
        fn get_duty(&self) -> Self::Duty {
            unsafe { (*TIM4::ptr()).ccr3.read().ccr().bits() }
        }
        fn set_duty(&mut self, duty: Self::Duty) -> () {
            unsafe {
                (*TIM4::ptr()).ccr3.modify(|_, w| w.ccr().bits(duty));
            }
        }
    }
    impl PwmPin for PwmChannel<TIM4_CH4, WithPins> {
        type Duty = u16;
        fn disable(&mut self) {
            unsafe {
                (*TIM4::ptr()).ccer.modify(|_, w| w.cc4e().clear_bit());
            }
        }
        fn enable(&mut self) {
            unsafe {
                (*TIM4::ptr()).ccer.modify(|_, w| w.cc4e().set_bit());
            }
        }
        fn get_max_duty(&self) -> Self::Duty {
            unsafe { (*TIM4::ptr()).arr.read().arr().bits() }
        }
        fn get_duty(&self) -> Self::Duty {
            unsafe { (*TIM4::ptr()).ccr4.read().ccr().bits() }
        }
        fn set_duty(&mut self, duty: Self::Duty) -> () {
            unsafe {
                (*TIM4::ptr()).ccr4.modify(|_, w| w.ccr().bits(duty));
            }
        }
    }
    impl PwmChannel<TIM4_CH1, NoPins> {
        #[doc = " Output to a specific pin from a channel that does not yet have"]
        #[doc = " any pins.  This channel cannot be enabled until this method"]
        #[doc = " is called."]
        #[doc = ""]
        #[doc = " The pin is consumed and cannot be returned."]
        pub fn output_to_pa11(self, _p: gpioa::PA11<gpio::AF10>) -> PwmChannel<TIM4_CH1, WithPins> {
            unsafe {
                (*TIM4::ptr())
                    .ccmr1_output()
                    .modify(|_, w| w.oc1m().bits(0b0110).oc1pe().set_bit());
            }
            PwmChannel {
                timx_chy: PhantomData,
                pin_status: PhantomData,
            }
        }
    }
    impl PwmChannel<TIM4_CH1, WithPins> {
        #[doc = " Output to a specific pin from a channel is already configured"]
        #[doc = " with output pins.  There is no limit to the number of pins that"]
        #[doc = " can be used (as long as they are compatible)."]
        #[doc = ""]
        #[doc = " The pin is consumed and cannot be returned."]
        pub fn output_to_pa11(self, _p: gpioa::PA11<gpio::AF10>) -> PwmChannel<TIM4_CH1, WithPins> {
            self
        }
    }
    impl PwmChannel<TIM4_CH1, NoPins> {
        #[doc = " Output to a specific pin from a channel that does not yet have"]
        #[doc = " any pins.  This channel cannot be enabled until this method"]
        #[doc = " is called."]
        #[doc = ""]
        #[doc = " The pin is consumed and cannot be returned."]
        pub fn output_to_pb6(self, _p: gpiob::PB6<gpio::AF2>) -> PwmChannel<TIM4_CH1, WithPins> {
            unsafe {
                (*TIM4::ptr())
                    .ccmr1_output()
                    .modify(|_, w| w.oc1m().bits(0b0110).oc1pe().set_bit());
            }
            PwmChannel {
                timx_chy: PhantomData,
                pin_status: PhantomData,
            }
        }
    }
    impl PwmChannel<TIM4_CH1, WithPins> {
        #[doc = " Output to a specific pin from a channel is already configured"]
        #[doc = " with output pins.  There is no limit to the number of pins that"]
        #[doc = " can be used (as long as they are compatible)."]
        #[doc = ""]
        #[doc = " The pin is consumed and cannot be returned."]
        pub fn output_to_pb6(self, _p: gpiob::PB6<gpio::AF2>) -> PwmChannel<TIM4_CH1, WithPins> {
            self
        }
    }
    impl PwmChannel<TIM4_CH2, NoPins> {
        #[doc = " Output to a specific pin from a channel that does not yet have"]
        #[doc = " any pins.  This channel cannot be enabled until this method"]
        #[doc = " is called."]
        #[doc = ""]
        #[doc = " The pin is consumed and cannot be returned."]
        pub fn output_to_pa12(self, _p: gpioa::PA12<gpio::AF10>) -> PwmChannel<TIM4_CH2, WithPins> {
            unsafe {
                (*TIM4::ptr())
                    .ccmr1_output()
                    .modify(|_, w| w.oc2m().bits(0b0110).oc2pe().set_bit());
            }
            PwmChannel {
                timx_chy: PhantomData,
                pin_status: PhantomData,
            }
        }
    }
    impl PwmChannel<TIM4_CH2, WithPins> {
        #[doc = " Output to a specific pin from a channel is already configured"]
        #[doc = " with output pins.  There is no limit to the number of pins that"]
        #[doc = " can be used (as long as they are compatible)."]
        #[doc = ""]
        #[doc = " The pin is consumed and cannot be returned."]
        pub fn output_to_pa12(self, _p: gpioa::PA12<gpio::AF10>) -> PwmChannel<TIM4_CH2, WithPins> {
            self
        }
    }
    impl PwmChannel<TIM4_CH2, NoPins> {
        #[doc = " Output to a specific pin from a channel that does not yet have"]
        #[doc = " any pins.  This channel cannot be enabled until this method"]
        #[doc = " is called."]
        #[doc = ""]
        #[doc = " The pin is consumed and cannot be returned."]
        pub fn output_to_pb7(self, _p: gpiob::PB7<gpio::AF2>) -> PwmChannel<TIM4_CH2, WithPins> {
            unsafe {
                (*TIM4::ptr())
                    .ccmr1_output()
                    .modify(|_, w| w.oc2m().bits(0b0110).oc2pe().set_bit());
            }
            PwmChannel {
                timx_chy: PhantomData,
                pin_status: PhantomData,
            }
        }
    }
    impl PwmChannel<TIM4_CH2, WithPins> {
        #[doc = " Output to a specific pin from a channel is already configured"]
        #[doc = " with output pins.  There is no limit to the number of pins that"]
        #[doc = " can be used (as long as they are compatible)."]
        #[doc = ""]
        #[doc = " The pin is consumed and cannot be returned."]
        pub fn output_to_pb7(self, _p: gpiob::PB7<gpio::AF2>) -> PwmChannel<TIM4_CH2, WithPins> {
            self
        }
    }
    impl PwmChannel<TIM4_CH3, NoPins> {
        #[doc = " Output to a specific pin from a channel that does not yet have"]
        #[doc = " any pins.  This channel cannot be enabled until this method"]
        #[doc = " is called."]
        #[doc = ""]
        #[doc = " The pin is consumed and cannot be returned."]
        pub fn output_to_pa13(self, _p: gpioa::PA13<gpio::AF10>) -> PwmChannel<TIM4_CH3, WithPins> {
            unsafe {
                (*TIM4::ptr())
                    .ccmr2_output()
                    .modify(|_, w| w.oc3m().bits(0b0110).oc3pe().set_bit());
            }
            PwmChannel {
                timx_chy: PhantomData,
                pin_status: PhantomData,
            }
        }
    }
    impl PwmChannel<TIM4_CH3, WithPins> {
        #[doc = " Output to a specific pin from a channel is already configured"]
        #[doc = " with output pins.  There is no limit to the number of pins that"]
        #[doc = " can be used (as long as they are compatible)."]
        #[doc = ""]
        #[doc = " The pin is consumed and cannot be returned."]
        pub fn output_to_pa13(self, _p: gpioa::PA13<gpio::AF10>) -> PwmChannel<TIM4_CH3, WithPins> {
            self
        }
    }
    impl PwmChannel<TIM4_CH3, NoPins> {
        #[doc = " Output to a specific pin from a channel that does not yet have"]
        #[doc = " any pins.  This channel cannot be enabled until this method"]
        #[doc = " is called."]
        #[doc = ""]
        #[doc = " The pin is consumed and cannot be returned."]
        pub fn output_to_pb8(self, _p: gpiob::PB8<gpio::AF2>) -> PwmChannel<TIM4_CH3, WithPins> {
            unsafe {
                (*TIM4::ptr())
                    .ccmr2_output()
                    .modify(|_, w| w.oc3m().bits(0b0110).oc3pe().set_bit());
            }
            PwmChannel {
                timx_chy: PhantomData,
                pin_status: PhantomData,
            }
        }
    }
    impl PwmChannel<TIM4_CH3, WithPins> {
        #[doc = " Output to a specific pin from a channel is already configured"]
        #[doc = " with output pins.  There is no limit to the number of pins that"]
        #[doc = " can be used (as long as they are compatible)."]
        #[doc = ""]
        #[doc = " The pin is consumed and cannot be returned."]
        pub fn output_to_pb8(self, _p: gpiob::PB8<gpio::AF2>) -> PwmChannel<TIM4_CH3, WithPins> {
            self
        }
    }
    impl PwmChannel<TIM4_CH4, NoPins> {
        #[doc = " Output to a specific pin from a channel that does not yet have"]
        #[doc = " any pins.  This channel cannot be enabled until this method"]
        #[doc = " is called."]
        #[doc = ""]
        #[doc = " The pin is consumed and cannot be returned."]
        pub fn output_to_pb9(self, _p: gpiob::PB9<gpio::AF2>) -> PwmChannel<TIM4_CH4, WithPins> {
            unsafe {
                (*TIM4::ptr())
                    .ccmr2_output()
                    .modify(|_, w| w.oc4m().bits(0b0110).oc4pe().set_bit());
            }
            PwmChannel {
                timx_chy: PhantomData,
                pin_status: PhantomData,
            }
        }
    }
    impl PwmChannel<TIM4_CH4, WithPins> {
        #[doc = " Output to a specific pin from a channel is already configured"]
        #[doc = " with output pins.  There is no limit to the number of pins that"]
        #[doc = " can be used (as long as they are compatible)."]
        #[doc = ""]
        #[doc = " The pin is consumed and cannot be returned."]
        pub fn output_to_pb9(self, _p: gpiob::PB9<gpio::AF2>) -> PwmChannel<TIM4_CH4, WithPins> {
            self
        }
    }
    impl PwmChannel<TIM4_CH1, NoPins> {
        #[doc = " Output to a specific pin from a channel that does not yet have"]
        #[doc = " any pins.  This channel cannot be enabled until this method"]
        #[doc = " is called."]
        #[doc = ""]
        #[doc = " The pin is consumed and cannot be returned."]
        pub fn output_to_pd12(self, _p: gpiod::PD12<gpio::AF2>) -> PwmChannel<TIM4_CH1, WithPins> {
            unsafe {
                (*TIM4::ptr())
                    .ccmr1_output()
                    .modify(|_, w| w.oc1m().bits(0b0110).oc1pe().set_bit());
            }
            PwmChannel {
                timx_chy: PhantomData,
                pin_status: PhantomData,
            }
        }
    }
    impl PwmChannel<TIM4_CH1, WithPins> {
        #[doc = " Output to a specific pin from a channel is already configured"]
        #[doc = " with output pins.  There is no limit to the number of pins that"]
        #[doc = " can be used (as long as they are compatible)."]
        #[doc = ""]
        #[doc = " The pin is consumed and cannot be returned."]
        pub fn output_to_pd12(self, _p: gpiod::PD12<gpio::AF2>) -> PwmChannel<TIM4_CH1, WithPins> {
            self
        }
    }
    impl PwmChannel<TIM4_CH2, NoPins> {
        #[doc = " Output to a specific pin from a channel that does not yet have"]
        #[doc = " any pins.  This channel cannot be enabled until this method"]
        #[doc = " is called."]
        #[doc = ""]
        #[doc = " The pin is consumed and cannot be returned."]
        pub fn output_to_pd13(self, _p: gpiod::PD13<gpio::AF2>) -> PwmChannel<TIM4_CH2, WithPins> {
            unsafe {
                (*TIM4::ptr())
                    .ccmr1_output()
                    .modify(|_, w| w.oc2m().bits(0b0110).oc2pe().set_bit());
            }
            PwmChannel {
                timx_chy: PhantomData,
                pin_status: PhantomData,
            }
        }
    }
    impl PwmChannel<TIM4_CH2, WithPins> {
        #[doc = " Output to a specific pin from a channel is already configured"]
        #[doc = " with output pins.  There is no limit to the number of pins that"]
        #[doc = " can be used (as long as they are compatible)."]
        #[doc = ""]
        #[doc = " The pin is consumed and cannot be returned."]
        pub fn output_to_pd13(self, _p: gpiod::PD13<gpio::AF2>) -> PwmChannel<TIM4_CH2, WithPins> {
            self
        }
    }
    impl PwmChannel<TIM4_CH3, NoPins> {
        #[doc = " Output to a specific pin from a channel that does not yet have"]
        #[doc = " any pins.  This channel cannot be enabled until this method"]
        #[doc = " is called."]
        #[doc = ""]
        #[doc = " The pin is consumed and cannot be returned."]
        pub fn output_to_pd14(self, _p: gpiod::PD14<gpio::AF2>) -> PwmChannel<TIM4_CH3, WithPins> {
            unsafe {
                (*TIM4::ptr())
                    .ccmr2_output()
                    .modify(|_, w| w.oc3m().bits(0b0110).oc3pe().set_bit());
            }
            PwmChannel {
                timx_chy: PhantomData,
                pin_status: PhantomData,
            }
        }
    }
    impl PwmChannel<TIM4_CH3, WithPins> {
        #[doc = " Output to a specific pin from a channel is already configured"]
        #[doc = " with output pins.  There is no limit to the number of pins that"]
        #[doc = " can be used (as long as they are compatible)."]
        #[doc = ""]
        #[doc = " The pin is consumed and cannot be returned."]
        pub fn output_to_pd14(self, _p: gpiod::PD14<gpio::AF2>) -> PwmChannel<TIM4_CH3, WithPins> {
            self
        }
    }
    impl PwmChannel<TIM4_CH4, NoPins> {
        #[doc = " Output to a specific pin from a channel that does not yet have"]
        #[doc = " any pins.  This channel cannot be enabled until this method"]
        #[doc = " is called."]
        #[doc = ""]
        #[doc = " The pin is consumed and cannot be returned."]
        pub fn output_to_pd15(self, _p: gpiod::PD15<gpio::AF2>) -> PwmChannel<TIM4_CH4, WithPins> {
            unsafe {
                (*TIM4::ptr())
                    .ccmr2_output()
                    .modify(|_, w| w.oc4m().bits(0b0110).oc4pe().set_bit());
            }
            PwmChannel {
                timx_chy: PhantomData,
                pin_status: PhantomData,
            }
        }
    }
    impl PwmChannel<TIM4_CH4, WithPins> {
        #[doc = " Output to a specific pin from a channel is already configured"]
        #[doc = " with output pins.  There is no limit to the number of pins that"]
        #[doc = " can be used (as long as they are compatible)."]
        #[doc = ""]
        #[doc = " The pin is consumed and cannot be returned."]
        pub fn output_to_pd15(self, _p: gpiod::PD15<gpio::AF2>) -> PwmChannel<TIM4_CH4, WithPins> {
            self
        }
    }
    impl PwmChannel<TIM4_CH4, NoPins> {
        #[doc = " Output to a specific pin from a channel that does not yet have"]
        #[doc = " any pins.  This channel cannot be enabled until this method"]
        #[doc = " is called."]
        #[doc = ""]
        #[doc = " The pin is consumed and cannot be returned."]
        pub fn output_to_pf6(self, _p: gpiof::PF6<gpio::AF2>) -> PwmChannel<TIM4_CH4, WithPins> {
            unsafe {
                (*TIM4::ptr())
                    .ccmr2_output()
                    .modify(|_, w| w.oc4m().bits(0b0110).oc4pe().set_bit());
            }
            PwmChannel {
                timx_chy: PhantomData,
                pin_status: PhantomData,
            }
        }
    }
    impl PwmChannel<TIM4_CH4, WithPins> {
        #[doc = " Output to a specific pin from a channel is already configured"]
        #[doc = " with output pins.  There is no limit to the number of pins that"]
        #[doc = " can be used (as long as they are compatible)."]
        #[doc = ""]
        #[doc = " The pin is consumed and cannot be returned."]
        pub fn output_to_pf6(self, _p: gpiof::PF6<gpio::AF2>) -> PwmChannel<TIM4_CH4, WithPins> {
            self
        }
    }
    use crate::pac::TIM8;
    #[doc = " Output Compare Channel 1 of Timer 8 (type state)"]
    pub struct TIM8_CH1 {}
    #[doc = " Output Compare Channel 2 of Timer 8 (type state)"]
    pub struct TIM8_CH2 {}
    #[doc = " Output Compare Channel 3 of Timer 8 (type state)"]
    pub struct TIM8_CH3 {}
    #[doc = " Output Compare Channel 4 of Timer 8 (type state)"]
    pub struct TIM8_CH4 {}
    #[doc = " Create one or more output channels from a TIM Peripheral"]
    #[doc = " This function requires the maximum resolution of the duty cycle,"]
    #[doc = " the period of the PWM signal and the frozen clock configuration."]
    #[doc = ""]
    #[doc = " The resolution should be chosen to offer sufficient steps against"]
    #[doc = " your target peripheral.  For example, a servo that can turn from"]
    #[doc = " 0 degrees (2% duty cycle) to 180 degrees (4% duty cycle) might choose"]
    #[doc = " a resolution of 9000.  This allows the servo to be set in increments"]
    #[doc = " of exactly one degree."]
    #[allow(unused_parens)]
    pub fn tim8(
        tim: TIM8,
        res: u16,
        freq: Hertz,
        clocks: &Clocks,
    ) -> (
        PwmChannel<TIM8_CH1, NoPins>,
        PwmChannel<TIM8_CH2, NoPins>,
        PwmChannel<TIM8_CH3, NoPins>,
        PwmChannel<TIM8_CH4, NoPins>,
    ) {
        unsafe {
            (*RCC::ptr()).apb2enr.modify(|_, w| w.tim8en().set_bit());
            (*RCC::ptr()).apb2rstr.modify(|_, w| w.tim8rst().set_bit());
            (*RCC::ptr())
                .apb2rstr
                .modify(|_, w| w.tim8rst().clear_bit());
        }
        tim.cr1.modify(|_, w| w.arpe().set_bit());
        #[allow(unused_unsafe)]
        tim.arr.write(|w| unsafe { w.arr().bits(res) });
        let clock_freq = clocks.pclk2().0 * if clocks.ppre1() == 1 { 1 } else { 2 };
        let prescale_factor = clock_freq / res as u32 / freq.0;
        tim.psc.write(|w| w.psc().bits(prescale_factor as u16 - 1));
        tim.egr.write(|w| w.ug().set_bit());
        (|tim: &TIM8| tim.bdtr.modify(|_, w| w.moe().set_bit()))(&tim);
        tim.cr1.modify(|_, w| w.cen().set_bit());
        (
            PwmChannel {
                timx_chy: PhantomData,
                pin_status: PhantomData,
            },
            PwmChannel {
                timx_chy: PhantomData,
                pin_status: PhantomData,
            },
            PwmChannel {
                timx_chy: PhantomData,
                pin_status: PhantomData,
            },
            PwmChannel {
                timx_chy: PhantomData,
                pin_status: PhantomData,
            },
        )
    }
    impl PwmPin for PwmChannel<TIM8_CH1, WithPins> {
        type Duty = u16;
        fn disable(&mut self) {
            unsafe {
                (*TIM8::ptr()).ccer.modify(|_, w| w.cc1e().clear_bit());
            }
        }
        fn enable(&mut self) {
            unsafe {
                (*TIM8::ptr()).ccer.modify(|_, w| w.cc1e().set_bit());
            }
        }
        fn get_max_duty(&self) -> Self::Duty {
            unsafe { (*TIM8::ptr()).arr.read().arr().bits() }
        }
        fn get_duty(&self) -> Self::Duty {
            unsafe { (*TIM8::ptr()).ccr1.read().ccr().bits() }
        }
        fn set_duty(&mut self, duty: Self::Duty) -> () {
            unsafe {
                (*TIM8::ptr()).ccr1.modify(|_, w| w.ccr().bits(duty));
            }
        }
    }
    impl PwmPin for PwmChannel<TIM8_CH1, WithNPins> {
        type Duty = u16;
        fn disable(&mut self) {
            unsafe {
                (*TIM8::ptr()).ccer.modify(|_, w| w.cc1ne().clear_bit());
            }
        }
        fn enable(&mut self) {
            unsafe {
                (*TIM8::ptr()).ccer.modify(|_, w| w.cc1ne().set_bit());
            }
        }
        fn get_max_duty(&self) -> Self::Duty {
            unsafe { (*TIM8::ptr()).arr.read().arr().bits() }
        }
        fn get_duty(&self) -> Self::Duty {
            unsafe { (*TIM8::ptr()).ccr1.read().ccr().bits() }
        }
        fn set_duty(&mut self, duty: Self::Duty) -> () {
            unsafe {
                (*TIM8::ptr()).ccr1.modify(|_, w| w.ccr().bits(duty));
            }
        }
    }
    impl PwmPin for PwmChannel<TIM8_CH2, WithPins> {
        type Duty = u16;
        fn disable(&mut self) {
            unsafe {
                (*TIM8::ptr()).ccer.modify(|_, w| w.cc2e().clear_bit());
            }
        }
        fn enable(&mut self) {
            unsafe {
                (*TIM8::ptr()).ccer.modify(|_, w| w.cc2e().set_bit());
            }
        }
        fn get_max_duty(&self) -> Self::Duty {
            unsafe { (*TIM8::ptr()).arr.read().arr().bits() }
        }
        fn get_duty(&self) -> Self::Duty {
            unsafe { (*TIM8::ptr()).ccr2.read().ccr().bits() }
        }
        fn set_duty(&mut self, duty: Self::Duty) -> () {
            unsafe {
                (*TIM8::ptr()).ccr2.modify(|_, w| w.ccr().bits(duty));
            }
        }
    }
    impl PwmPin for PwmChannel<TIM8_CH2, WithNPins> {
        type Duty = u16;
        fn disable(&mut self) {
            unsafe {
                (*TIM8::ptr()).ccer.modify(|_, w| w.cc2ne().clear_bit());
            }
        }
        fn enable(&mut self) {
            unsafe {
                (*TIM8::ptr()).ccer.modify(|_, w| w.cc2ne().set_bit());
            }
        }
        fn get_max_duty(&self) -> Self::Duty {
            unsafe { (*TIM8::ptr()).arr.read().arr().bits() }
        }
        fn get_duty(&self) -> Self::Duty {
            unsafe { (*TIM8::ptr()).ccr2.read().ccr().bits() }
        }
        fn set_duty(&mut self, duty: Self::Duty) -> () {
            unsafe {
                (*TIM8::ptr()).ccr2.modify(|_, w| w.ccr().bits(duty));
            }
        }
    }
    impl PwmPin for PwmChannel<TIM8_CH3, WithPins> {
        type Duty = u16;
        fn disable(&mut self) {
            unsafe {
                (*TIM8::ptr()).ccer.modify(|_, w| w.cc3e().clear_bit());
            }
        }
        fn enable(&mut self) {
            unsafe {
                (*TIM8::ptr()).ccer.modify(|_, w| w.cc3e().set_bit());
            }
        }
        fn get_max_duty(&self) -> Self::Duty {
            unsafe { (*TIM8::ptr()).arr.read().arr().bits() }
        }
        fn get_duty(&self) -> Self::Duty {
            unsafe { (*TIM8::ptr()).ccr3.read().ccr().bits() }
        }
        fn set_duty(&mut self, duty: Self::Duty) -> () {
            unsafe {
                (*TIM8::ptr()).ccr3.modify(|_, w| w.ccr().bits(duty));
            }
        }
    }
    impl PwmPin for PwmChannel<TIM8_CH3, WithNPins> {
        type Duty = u16;
        fn disable(&mut self) {
            unsafe {
                (*TIM8::ptr()).ccer.modify(|_, w| w.cc3ne().clear_bit());
            }
        }
        fn enable(&mut self) {
            unsafe {
                (*TIM8::ptr()).ccer.modify(|_, w| w.cc3ne().set_bit());
            }
        }
        fn get_max_duty(&self) -> Self::Duty {
            unsafe { (*TIM8::ptr()).arr.read().arr().bits() }
        }
        fn get_duty(&self) -> Self::Duty {
            unsafe { (*TIM8::ptr()).ccr3.read().ccr().bits() }
        }
        fn set_duty(&mut self, duty: Self::Duty) -> () {
            unsafe {
                (*TIM8::ptr()).ccr3.modify(|_, w| w.ccr().bits(duty));
            }
        }
    }
    impl PwmPin for PwmChannel<TIM8_CH4, WithPins> {
        type Duty = u16;
        fn disable(&mut self) {
            unsafe {
                (*TIM8::ptr()).ccer.modify(|_, w| w.cc4e().clear_bit());
            }
        }
        fn enable(&mut self) {
            unsafe {
                (*TIM8::ptr()).ccer.modify(|_, w| w.cc4e().set_bit());
            }
        }
        fn get_max_duty(&self) -> Self::Duty {
            unsafe { (*TIM8::ptr()).arr.read().arr().bits() }
        }
        fn get_duty(&self) -> Self::Duty {
            unsafe { (*TIM8::ptr()).ccr4.read().ccr().bits() }
        }
        fn set_duty(&mut self, duty: Self::Duty) -> () {
            unsafe {
                (*TIM8::ptr()).ccr4.modify(|_, w| w.ccr().bits(duty));
            }
        }
    }
    impl PwmChannel<TIM8_CH1, NoPins> {
        #[doc = " Output to a specific pin from a channel that does not yet have"]
        #[doc = " any pins.  This channel cannot be enabled until this method"]
        #[doc = " is called."]
        #[doc = ""]
        #[doc = " The pin is consumed and cannot be returned."]
        pub fn output_to_pa15(self, _p: gpioa::PA15<gpio::AF2>) -> PwmChannel<TIM8_CH1, WithPins> {
            unsafe {
                (*TIM8::ptr())
                    .ccmr1_output()
                    .modify(|_, w| w.oc1m().bits(0b0110).oc1pe().set_bit());
            }
            PwmChannel {
                timx_chy: PhantomData,
                pin_status: PhantomData,
            }
        }
    }
    impl PwmChannel<TIM8_CH1, WithPins> {
        #[doc = " Output to a specific pin from a channel is already configured"]
        #[doc = " with output pins.  There is no limit to the number of pins that"]
        #[doc = " can be used (as long as they are compatible)."]
        #[doc = ""]
        #[doc = " The pin is consumed and cannot be returned."]
        pub fn output_to_pa15(self, _p: gpioa::PA15<gpio::AF2>) -> PwmChannel<TIM8_CH1, WithPins> {
            self
        }
    }
    impl PwmChannel<TIM8_CH1, NoPins> {
        #[doc = " Output to a specific pin from a channel that does not yet have"]
        #[doc = " any pins.  This channel cannot be enabled until this method"]
        #[doc = " is called."]
        #[doc = ""]
        #[doc = " The pin is consumed and cannot be returned."]
        pub fn output_to_pb6(self, _p: gpiob::PB6<gpio::AF2>) -> PwmChannel<TIM8_CH1, WithPins> {
            unsafe {
                (*TIM8::ptr())
                    .ccmr1_output()
                    .modify(|_, w| w.oc1m().bits(0b0110).oc1pe().set_bit());
            }
            PwmChannel {
                timx_chy: PhantomData,
                pin_status: PhantomData,
            }
        }
    }
    impl PwmChannel<TIM8_CH1, WithPins> {
        #[doc = " Output to a specific pin from a channel is already configured"]
        #[doc = " with output pins.  There is no limit to the number of pins that"]
        #[doc = " can be used (as long as they are compatible)."]
        #[doc = ""]
        #[doc = " The pin is consumed and cannot be returned."]
        pub fn output_to_pb6(self, _p: gpiob::PB6<gpio::AF2>) -> PwmChannel<TIM8_CH1, WithPins> {
            self
        }
    }
    impl PwmChannel<TIM8_CH1, NoPins> {
        #[doc = " Output to a specific pin from a channel that does not yet have"]
        #[doc = " any pins.  This channel cannot be enabled until this method"]
        #[doc = " is called."]
        #[doc = ""]
        #[doc = " The pin is consumed and cannot be returned."]
        pub fn output_to_pc6(self, _p: gpioc::PC6<gpio::AF4>) -> PwmChannel<TIM8_CH1, WithPins> {
            unsafe {
                (*TIM8::ptr())
                    .ccmr1_output()
                    .modify(|_, w| w.oc1m().bits(0b0110).oc1pe().set_bit());
            }
            PwmChannel {
                timx_chy: PhantomData,
                pin_status: PhantomData,
            }
        }
    }
    impl PwmChannel<TIM8_CH1, WithPins> {
        #[doc = " Output to a specific pin from a channel is already configured"]
        #[doc = " with output pins.  There is no limit to the number of pins that"]
        #[doc = " can be used (as long as they are compatible)."]
        #[doc = ""]
        #[doc = " The pin is consumed and cannot be returned."]
        pub fn output_to_pc6(self, _p: gpioc::PC6<gpio::AF4>) -> PwmChannel<TIM8_CH1, WithPins> {
            self
        }
    }
    impl PwmChannel<TIM8_CH1, NoPins> {
        #[doc = " Output to a specific pin from a channel that does not yet have"]
        #[doc = " any pins.  This channel cannot be enabled until this method"]
        #[doc = " is called."]
        #[doc = ""]
        #[doc = " The pin is consumed and cannot be returned."]
        pub fn output_to_pa7(self, _p: gpioa::PA7<gpio::AF4>) -> PwmChannel<TIM8_CH1, WithNPins> {
            unsafe {
                (*TIM8::ptr())
                    .ccmr1_output()
                    .modify(|_, w| w.oc1m().bits(0b0110).oc1pe().set_bit());
            }
            PwmChannel {
                timx_chy: PhantomData,
                pin_status: PhantomData,
            }
        }
    }
    impl PwmChannel<TIM8_CH1, WithNPins> {
        #[doc = " Output to a specific pin from a channel is already configured"]
        #[doc = " with output pins.  There is no limit to the number of pins that"]
        #[doc = " can be used (as long as they are compatible)."]
        #[doc = ""]
        #[doc = " The pin is consumed and cannot be returned."]
        pub fn output_to_pa7(self, _p: gpioa::PA7<gpio::AF4>) -> PwmChannel<TIM8_CH1, WithNPins> {
            self
        }
    }
    impl PwmChannel<TIM8_CH1, NoPins> {
        #[doc = " Output to a specific pin from a channel that does not yet have"]
        #[doc = " any pins.  This channel cannot be enabled until this method"]
        #[doc = " is called."]
        #[doc = ""]
        #[doc = " The pin is consumed and cannot be returned."]
        pub fn output_to_pb3(self, _p: gpiob::PB3<gpio::AF4>) -> PwmChannel<TIM8_CH1, WithNPins> {
            unsafe {
                (*TIM8::ptr())
                    .ccmr1_output()
                    .modify(|_, w| w.oc1m().bits(0b0110).oc1pe().set_bit());
            }
            PwmChannel {
                timx_chy: PhantomData,
                pin_status: PhantomData,
            }
        }
    }
    impl PwmChannel<TIM8_CH1, WithNPins> {
        #[doc = " Output to a specific pin from a channel is already configured"]
        #[doc = " with output pins.  There is no limit to the number of pins that"]
        #[doc = " can be used (as long as they are compatible)."]
        #[doc = ""]
        #[doc = " The pin is consumed and cannot be returned."]
        pub fn output_to_pb3(self, _p: gpiob::PB3<gpio::AF4>) -> PwmChannel<TIM8_CH1, WithNPins> {
            self
        }
    }
    impl PwmChannel<TIM8_CH1, NoPins> {
        #[doc = " Output to a specific pin from a channel that does not yet have"]
        #[doc = " any pins.  This channel cannot be enabled until this method"]
        #[doc = " is called."]
        #[doc = ""]
        #[doc = " The pin is consumed and cannot be returned."]
        pub fn output_to_pc10(self, _p: gpioc::PC10<gpio::AF4>) -> PwmChannel<TIM8_CH1, WithNPins> {
            unsafe {
                (*TIM8::ptr())
                    .ccmr1_output()
                    .modify(|_, w| w.oc1m().bits(0b0110).oc1pe().set_bit());
            }
            PwmChannel {
                timx_chy: PhantomData,
                pin_status: PhantomData,
            }
        }
    }
    impl PwmChannel<TIM8_CH1, WithNPins> {
        #[doc = " Output to a specific pin from a channel is already configured"]
        #[doc = " with output pins.  There is no limit to the number of pins that"]
        #[doc = " can be used (as long as they are compatible)."]
        #[doc = ""]
        #[doc = " The pin is consumed and cannot be returned."]
        pub fn output_to_pc10(self, _p: gpioc::PC10<gpio::AF4>) -> PwmChannel<TIM8_CH1, WithNPins> {
            self
        }
    }
    impl PwmChannel<TIM8_CH2, NoPins> {
        #[doc = " Output to a specific pin from a channel that does not yet have"]
        #[doc = " any pins.  This channel cannot be enabled until this method"]
        #[doc = " is called."]
        #[doc = ""]
        #[doc = " The pin is consumed and cannot be returned."]
        pub fn output_to_pa14(self, _p: gpioa::PA14<gpio::AF5>) -> PwmChannel<TIM8_CH2, WithPins> {
            unsafe {
                (*TIM8::ptr())
                    .ccmr1_output()
                    .modify(|_, w| w.oc2m().bits(0b0110).oc2pe().set_bit());
            }
            PwmChannel {
                timx_chy: PhantomData,
                pin_status: PhantomData,
            }
        }
    }
    impl PwmChannel<TIM8_CH2, WithPins> {
        #[doc = " Output to a specific pin from a channel is already configured"]
        #[doc = " with output pins.  There is no limit to the number of pins that"]
        #[doc = " can be used (as long as they are compatible)."]
        #[doc = ""]
        #[doc = " The pin is consumed and cannot be returned."]
        pub fn output_to_pa14(self, _p: gpioa::PA14<gpio::AF5>) -> PwmChannel<TIM8_CH2, WithPins> {
            self
        }
    }
    impl PwmChannel<TIM8_CH2, NoPins> {
        #[doc = " Output to a specific pin from a channel that does not yet have"]
        #[doc = " any pins.  This channel cannot be enabled until this method"]
        #[doc = " is called."]
        #[doc = ""]
        #[doc = " The pin is consumed and cannot be returned."]
        pub fn output_to_pb8(self, _p: gpiob::PB8<gpio::AF10>) -> PwmChannel<TIM8_CH2, WithPins> {
            unsafe {
                (*TIM8::ptr())
                    .ccmr1_output()
                    .modify(|_, w| w.oc2m().bits(0b0110).oc2pe().set_bit());
            }
            PwmChannel {
                timx_chy: PhantomData,
                pin_status: PhantomData,
            }
        }
    }
    impl PwmChannel<TIM8_CH2, WithPins> {
        #[doc = " Output to a specific pin from a channel is already configured"]
        #[doc = " with output pins.  There is no limit to the number of pins that"]
        #[doc = " can be used (as long as they are compatible)."]
        #[doc = ""]
        #[doc = " The pin is consumed and cannot be returned."]
        pub fn output_to_pb8(self, _p: gpiob::PB8<gpio::AF10>) -> PwmChannel<TIM8_CH2, WithPins> {
            self
        }
    }
    impl PwmChannel<TIM8_CH2, NoPins> {
        #[doc = " Output to a specific pin from a channel that does not yet have"]
        #[doc = " any pins.  This channel cannot be enabled until this method"]
        #[doc = " is called."]
        #[doc = ""]
        #[doc = " The pin is consumed and cannot be returned."]
        pub fn output_to_pc7(self, _p: gpioc::PC7<gpio::AF4>) -> PwmChannel<TIM8_CH2, WithPins> {
            unsafe {
                (*TIM8::ptr())
                    .ccmr1_output()
                    .modify(|_, w| w.oc2m().bits(0b0110).oc2pe().set_bit());
            }
            PwmChannel {
                timx_chy: PhantomData,
                pin_status: PhantomData,
            }
        }
    }
    impl PwmChannel<TIM8_CH2, WithPins> {
        #[doc = " Output to a specific pin from a channel is already configured"]
        #[doc = " with output pins.  There is no limit to the number of pins that"]
        #[doc = " can be used (as long as they are compatible)."]
        #[doc = ""]
        #[doc = " The pin is consumed and cannot be returned."]
        pub fn output_to_pc7(self, _p: gpioc::PC7<gpio::AF4>) -> PwmChannel<TIM8_CH2, WithPins> {
            self
        }
    }
    impl PwmChannel<TIM8_CH2, NoPins> {
        #[doc = " Output to a specific pin from a channel that does not yet have"]
        #[doc = " any pins.  This channel cannot be enabled until this method"]
        #[doc = " is called."]
        #[doc = ""]
        #[doc = " The pin is consumed and cannot be returned."]
        pub fn output_to_pb0(self, _p: gpiob::PB0<gpio::AF4>) -> PwmChannel<TIM8_CH2, WithNPins> {
            unsafe {
                (*TIM8::ptr())
                    .ccmr1_output()
                    .modify(|_, w| w.oc2m().bits(0b0110).oc2pe().set_bit());
            }
            PwmChannel {
                timx_chy: PhantomData,
                pin_status: PhantomData,
            }
        }
    }
    impl PwmChannel<TIM8_CH2, WithNPins> {
        #[doc = " Output to a specific pin from a channel is already configured"]
        #[doc = " with output pins.  There is no limit to the number of pins that"]
        #[doc = " can be used (as long as they are compatible)."]
        #[doc = ""]
        #[doc = " The pin is consumed and cannot be returned."]
        pub fn output_to_pb0(self, _p: gpiob::PB0<gpio::AF4>) -> PwmChannel<TIM8_CH2, WithNPins> {
            self
        }
    }
    impl PwmChannel<TIM8_CH2, NoPins> {
        #[doc = " Output to a specific pin from a channel that does not yet have"]
        #[doc = " any pins.  This channel cannot be enabled until this method"]
        #[doc = " is called."]
        #[doc = ""]
        #[doc = " The pin is consumed and cannot be returned."]
        pub fn output_to_pb4(self, _p: gpiob::PB4<gpio::AF4>) -> PwmChannel<TIM8_CH2, WithNPins> {
            unsafe {
                (*TIM8::ptr())
                    .ccmr1_output()
                    .modify(|_, w| w.oc2m().bits(0b0110).oc2pe().set_bit());
            }
            PwmChannel {
                timx_chy: PhantomData,
                pin_status: PhantomData,
            }
        }
    }
    impl PwmChannel<TIM8_CH2, WithNPins> {
        #[doc = " Output to a specific pin from a channel is already configured"]
        #[doc = " with output pins.  There is no limit to the number of pins that"]
        #[doc = " can be used (as long as they are compatible)."]
        #[doc = ""]
        #[doc = " The pin is consumed and cannot be returned."]
        pub fn output_to_pb4(self, _p: gpiob::PB4<gpio::AF4>) -> PwmChannel<TIM8_CH2, WithNPins> {
            self
        }
    }
    impl PwmChannel<TIM8_CH2, NoPins> {
        #[doc = " Output to a specific pin from a channel that does not yet have"]
        #[doc = " any pins.  This channel cannot be enabled until this method"]
        #[doc = " is called."]
        #[doc = ""]
        #[doc = " The pin is consumed and cannot be returned."]
        pub fn output_to_pc11(self, _p: gpioc::PC11<gpio::AF4>) -> PwmChannel<TIM8_CH2, WithNPins> {
            unsafe {
                (*TIM8::ptr())
                    .ccmr1_output()
                    .modify(|_, w| w.oc2m().bits(0b0110).oc2pe().set_bit());
            }
            PwmChannel {
                timx_chy: PhantomData,
                pin_status: PhantomData,
            }
        }
    }
    impl PwmChannel<TIM8_CH2, WithNPins> {
        #[doc = " Output to a specific pin from a channel is already configured"]
        #[doc = " with output pins.  There is no limit to the number of pins that"]
        #[doc = " can be used (as long as they are compatible)."]
        #[doc = ""]
        #[doc = " The pin is consumed and cannot be returned."]
        pub fn output_to_pc11(self, _p: gpioc::PC11<gpio::AF4>) -> PwmChannel<TIM8_CH2, WithNPins> {
            self
        }
    }
    impl PwmChannel<TIM8_CH3, NoPins> {
        #[doc = " Output to a specific pin from a channel that does not yet have"]
        #[doc = " any pins.  This channel cannot be enabled until this method"]
        #[doc = " is called."]
        #[doc = ""]
        #[doc = " The pin is consumed and cannot be returned."]
        pub fn output_to_pb9(self, _p: gpiob::PB9<gpio::AF10>) -> PwmChannel<TIM8_CH3, WithPins> {
            unsafe {
                (*TIM8::ptr())
                    .ccmr2_output()
                    .modify(|_, w| w.oc3m().bits(0b0110).oc3pe().set_bit());
            }
            PwmChannel {
                timx_chy: PhantomData,
                pin_status: PhantomData,
            }
        }
    }
    impl PwmChannel<TIM8_CH3, WithPins> {
        #[doc = " Output to a specific pin from a channel is already configured"]
        #[doc = " with output pins.  There is no limit to the number of pins that"]
        #[doc = " can be used (as long as they are compatible)."]
        #[doc = ""]
        #[doc = " The pin is consumed and cannot be returned."]
        pub fn output_to_pb9(self, _p: gpiob::PB9<gpio::AF10>) -> PwmChannel<TIM8_CH3, WithPins> {
            self
        }
    }
    impl PwmChannel<TIM8_CH3, NoPins> {
        #[doc = " Output to a specific pin from a channel that does not yet have"]
        #[doc = " any pins.  This channel cannot be enabled until this method"]
        #[doc = " is called."]
        #[doc = ""]
        #[doc = " The pin is consumed and cannot be returned."]
        pub fn output_to_pc8(self, _p: gpioc::PC8<gpio::AF4>) -> PwmChannel<TIM8_CH3, WithPins> {
            unsafe {
                (*TIM8::ptr())
                    .ccmr2_output()
                    .modify(|_, w| w.oc3m().bits(0b0110).oc3pe().set_bit());
            }
            PwmChannel {
                timx_chy: PhantomData,
                pin_status: PhantomData,
            }
        }
    }
    impl PwmChannel<TIM8_CH3, WithPins> {
        #[doc = " Output to a specific pin from a channel is already configured"]
        #[doc = " with output pins.  There is no limit to the number of pins that"]
        #[doc = " can be used (as long as they are compatible)."]
        #[doc = ""]
        #[doc = " The pin is consumed and cannot be returned."]
        pub fn output_to_pc8(self, _p: gpioc::PC8<gpio::AF4>) -> PwmChannel<TIM8_CH3, WithPins> {
            self
        }
    }
    impl PwmChannel<TIM8_CH3, NoPins> {
        #[doc = " Output to a specific pin from a channel that does not yet have"]
        #[doc = " any pins.  This channel cannot be enabled until this method"]
        #[doc = " is called."]
        #[doc = ""]
        #[doc = " The pin is consumed and cannot be returned."]
        pub fn output_to_pb1(self, _p: gpiob::PB1<gpio::AF4>) -> PwmChannel<TIM8_CH3, WithNPins> {
            unsafe {
                (*TIM8::ptr())
                    .ccmr2_output()
                    .modify(|_, w| w.oc3m().bits(0b0110).oc3pe().set_bit());
            }
            PwmChannel {
                timx_chy: PhantomData,
                pin_status: PhantomData,
            }
        }
    }
    impl PwmChannel<TIM8_CH3, WithNPins> {
        #[doc = " Output to a specific pin from a channel is already configured"]
        #[doc = " with output pins.  There is no limit to the number of pins that"]
        #[doc = " can be used (as long as they are compatible)."]
        #[doc = ""]
        #[doc = " The pin is consumed and cannot be returned."]
        pub fn output_to_pb1(self, _p: gpiob::PB1<gpio::AF4>) -> PwmChannel<TIM8_CH3, WithNPins> {
            self
        }
    }
    impl PwmChannel<TIM8_CH3, NoPins> {
        #[doc = " Output to a specific pin from a channel that does not yet have"]
        #[doc = " any pins.  This channel cannot be enabled until this method"]
        #[doc = " is called."]
        #[doc = ""]
        #[doc = " The pin is consumed and cannot be returned."]
        pub fn output_to_pb5(self, _p: gpiob::PB5<gpio::AF3>) -> PwmChannel<TIM8_CH3, WithNPins> {
            unsafe {
                (*TIM8::ptr())
                    .ccmr2_output()
                    .modify(|_, w| w.oc3m().bits(0b0110).oc3pe().set_bit());
            }
            PwmChannel {
                timx_chy: PhantomData,
                pin_status: PhantomData,
            }
        }
    }
    impl PwmChannel<TIM8_CH3, WithNPins> {
        #[doc = " Output to a specific pin from a channel is already configured"]
        #[doc = " with output pins.  There is no limit to the number of pins that"]
        #[doc = " can be used (as long as they are compatible)."]
        #[doc = ""]
        #[doc = " The pin is consumed and cannot be returned."]
        pub fn output_to_pb5(self, _p: gpiob::PB5<gpio::AF3>) -> PwmChannel<TIM8_CH3, WithNPins> {
            self
        }
    }
    impl PwmChannel<TIM8_CH3, NoPins> {
        #[doc = " Output to a specific pin from a channel that does not yet have"]
        #[doc = " any pins.  This channel cannot be enabled until this method"]
        #[doc = " is called."]
        #[doc = ""]
        #[doc = " The pin is consumed and cannot be returned."]
        pub fn output_to_pc12(self, _p: gpioc::PC12<gpio::AF4>) -> PwmChannel<TIM8_CH3, WithNPins> {
            unsafe {
                (*TIM8::ptr())
                    .ccmr2_output()
                    .modify(|_, w| w.oc3m().bits(0b0110).oc3pe().set_bit());
            }
            PwmChannel {
                timx_chy: PhantomData,
                pin_status: PhantomData,
            }
        }
    }
    impl PwmChannel<TIM8_CH3, WithNPins> {
        #[doc = " Output to a specific pin from a channel is already configured"]
        #[doc = " with output pins.  There is no limit to the number of pins that"]
        #[doc = " can be used (as long as they are compatible)."]
        #[doc = ""]
        #[doc = " The pin is consumed and cannot be returned."]
        pub fn output_to_pc12(self, _p: gpioc::PC12<gpio::AF4>) -> PwmChannel<TIM8_CH3, WithNPins> {
            self
        }
    }
    impl PwmChannel<TIM8_CH4, NoPins> {
        #[doc = " Output to a specific pin from a channel that does not yet have"]
        #[doc = " any pins.  This channel cannot be enabled until this method"]
        #[doc = " is called."]
        #[doc = ""]
        #[doc = " The pin is consumed and cannot be returned."]
        pub fn output_to_pc9(self, _p: gpioc::PC9<gpio::AF4>) -> PwmChannel<TIM8_CH4, WithPins> {
            unsafe {
                (*TIM8::ptr())
                    .ccmr2_output()
                    .modify(|_, w| w.oc4m().bits(0b0110).oc4pe().set_bit());
            }
            PwmChannel {
                timx_chy: PhantomData,
                pin_status: PhantomData,
            }
        }
    }
    impl PwmChannel<TIM8_CH4, WithPins> {
        #[doc = " Output to a specific pin from a channel is already configured"]
        #[doc = " with output pins.  There is no limit to the number of pins that"]
        #[doc = " can be used (as long as they are compatible)."]
        #[doc = ""]
        #[doc = " The pin is consumed and cannot be returned."]
        pub fn output_to_pc9(self, _p: gpioc::PC9<gpio::AF4>) -> PwmChannel<TIM8_CH4, WithPins> {
            self
        }
    }
    impl PwmChannel<TIM8_CH4, NoPins> {
        #[doc = " Output to a specific pin from a channel that does not yet have"]
        #[doc = " any pins.  This channel cannot be enabled until this method"]
        #[doc = " is called."]
        #[doc = ""]
        #[doc = " The pin is consumed and cannot be returned."]
        pub fn output_to_pd1(self, _p: gpiod::PD1<gpio::AF4>) -> PwmChannel<TIM8_CH4, WithPins> {
            unsafe {
                (*TIM8::ptr())
                    .ccmr2_output()
                    .modify(|_, w| w.oc4m().bits(0b0110).oc4pe().set_bit());
            }
            PwmChannel {
                timx_chy: PhantomData,
                pin_status: PhantomData,
            }
        }
    }
    impl PwmChannel<TIM8_CH4, WithPins> {
        #[doc = " Output to a specific pin from a channel is already configured"]
        #[doc = " with output pins.  There is no limit to the number of pins that"]
        #[doc = " can be used (as long as they are compatible)."]
        #[doc = ""]
        #[doc = " The pin is consumed and cannot be returned."]
        pub fn output_to_pd1(self, _p: gpiod::PD1<gpio::AF4>) -> PwmChannel<TIM8_CH4, WithPins> {
            self
        }
    }
    #[doc = " Create one or more output channels from a TIM Peripheral"]
    #[doc = " This function requires the maximum resolution of the duty cycle,"]
    #[doc = " the period of the PWM signal and the frozen clock configuration."]
    #[doc = ""]
    #[doc = " The resolution should be chosen to offer sufficient steps against"]
    #[doc = " your target peripheral.  For example, a servo that can turn from"]
    #[doc = " 0 degrees (2% duty cycle) to 180 degrees (4% duty cycle) might choose"]
    #[doc = " a resolution of 9000.  This allows the servo to be set in increments"]
    #[doc = " of exactly one degree."]
    #[allow(unused_parens)]
    pub fn tim15(
        tim: TIM15,
        res: u16,
        freq: Hertz,
        clocks: &Clocks,
    ) -> (PwmChannel<TIM15_CH1, NoPins>, PwmChannel<TIM15_CH2, NoPins>) {
        unsafe {
            (*RCC::ptr()).apb2enr.modify(|_, w| w.tim15en().set_bit());
            (*RCC::ptr()).apb2rstr.modify(|_, w| w.tim15rst().set_bit());
            (*RCC::ptr())
                .apb2rstr
                .modify(|_, w| w.tim15rst().clear_bit());
        }
        tim.cr1.modify(|_, w| w.arpe().set_bit());
        #[allow(unused_unsafe)]
        tim.arr.write(|w| unsafe { w.arr().bits(res) });
        let clock_freq = clocks.pclk2().0 * if clocks.ppre1() == 1 { 1 } else { 2 };
        let prescale_factor = clock_freq / res as u32 / freq.0;
        tim.psc.write(|w| w.psc().bits(prescale_factor as u16 - 1));
        tim.egr.write(|w| w.ug().set_bit());
        (|tim: &TIM15| tim.bdtr.modify(|_, w| w.moe().set_bit()))(&tim);
        tim.cr1.modify(|_, w| w.cen().set_bit());
        (
            PwmChannel {
                timx_chy: PhantomData,
                pin_status: PhantomData,
            },
            PwmChannel {
                timx_chy: PhantomData,
                pin_status: PhantomData,
            },
        )
    }
    impl PwmPin for PwmChannel<TIM15_CH1, WithPins> {
        type Duty = u16;
        fn disable(&mut self) {
            unsafe {
                (*TIM15::ptr()).ccer.modify(|_, w| w.cc1e().clear_bit());
            }
        }
        fn enable(&mut self) {
            unsafe {
                (*TIM15::ptr()).ccer.modify(|_, w| w.cc1e().set_bit());
            }
        }
        fn get_max_duty(&self) -> Self::Duty {
            unsafe { (*TIM15::ptr()).arr.read().arr().bits() }
        }
        fn get_duty(&self) -> Self::Duty {
            unsafe { (*TIM15::ptr()).ccr1.read().ccr1().bits() }
        }
        fn set_duty(&mut self, duty: Self::Duty) -> () {
            unsafe {
                (*TIM15::ptr()).ccr1.modify(|_, w| w.ccr1().bits(duty));
            }
        }
    }
    impl PwmPin for PwmChannel<TIM15_CH1, WithNPins> {
        type Duty = u16;
        fn disable(&mut self) {
            unsafe {
                (*TIM15::ptr()).ccer.modify(|_, w| w.cc1ne().clear_bit());
            }
        }
        fn enable(&mut self) {
            unsafe {
                (*TIM15::ptr()).ccer.modify(|_, w| w.cc1ne().set_bit());
            }
        }
        fn get_max_duty(&self) -> Self::Duty {
            unsafe { (*TIM15::ptr()).arr.read().arr().bits() }
        }
        fn get_duty(&self) -> Self::Duty {
            unsafe { (*TIM15::ptr()).ccr1.read().ccr1().bits() }
        }
        fn set_duty(&mut self, duty: Self::Duty) -> () {
            unsafe {
                (*TIM15::ptr()).ccr1.modify(|_, w| w.ccr1().bits(duty));
            }
        }
    }
    impl PwmPin for PwmChannel<TIM15_CH2, WithPins> {
        type Duty = u16;
        fn disable(&mut self) {
            unsafe {
                (*TIM15::ptr()).ccer.modify(|_, w| w.cc2e().clear_bit());
            }
        }
        fn enable(&mut self) {
            unsafe {
                (*TIM15::ptr()).ccer.modify(|_, w| w.cc2e().set_bit());
            }
        }
        fn get_max_duty(&self) -> Self::Duty {
            unsafe { (*TIM15::ptr()).arr.read().arr().bits() }
        }
        fn get_duty(&self) -> Self::Duty {
            unsafe { (*TIM15::ptr()).ccr2.read().ccr2().bits() }
        }
        fn set_duty(&mut self, duty: Self::Duty) -> () {
            unsafe {
                (*TIM15::ptr()).ccr2.modify(|_, w| w.ccr2().bits(duty));
            }
        }
    }
    impl PwmChannel<TIM15_CH1, NoPins> {
        #[doc = " Output to a specific pin from a channel that does not yet have"]
        #[doc = " any pins.  This channel cannot be enabled until this method"]
        #[doc = " is called."]
        #[doc = ""]
        #[doc = " The pin is consumed and cannot be returned."]
        pub fn output_to_pa2(self, _p: gpioa::PA2<gpio::AF9>) -> PwmChannel<TIM15_CH1, WithPins> {
            unsafe {
                (*TIM15::ptr())
                    .ccmr1_output()
                    .modify(|_, w| w.oc1m().bits(0b0110).oc1pe().set_bit());
            }
            PwmChannel {
                timx_chy: PhantomData,
                pin_status: PhantomData,
            }
        }
    }
    impl PwmChannel<TIM15_CH1, WithPins> {
        #[doc = " Output to a specific pin from a channel is already configured"]
        #[doc = " with output pins.  There is no limit to the number of pins that"]
        #[doc = " can be used (as long as they are compatible)."]
        #[doc = ""]
        #[doc = " The pin is consumed and cannot be returned."]
        pub fn output_to_pa2(self, _p: gpioa::PA2<gpio::AF9>) -> PwmChannel<TIM15_CH1, WithPins> {
            self
        }
    }
    impl PwmChannel<TIM15_CH1, NoPins> {
        #[doc = " Output to a specific pin from a channel that does not yet have"]
        #[doc = " any pins.  This channel cannot be enabled until this method"]
        #[doc = " is called."]
        #[doc = ""]
        #[doc = " The pin is consumed and cannot be returned."]
        pub fn output_to_pb14(self, _p: gpiob::PB14<gpio::AF1>) -> PwmChannel<TIM15_CH1, WithPins> {
            unsafe {
                (*TIM15::ptr())
                    .ccmr1_output()
                    .modify(|_, w| w.oc1m().bits(0b0110).oc1pe().set_bit());
            }
            PwmChannel {
                timx_chy: PhantomData,
                pin_status: PhantomData,
            }
        }
    }
    impl PwmChannel<TIM15_CH1, WithPins> {
        #[doc = " Output to a specific pin from a channel is already configured"]
        #[doc = " with output pins.  There is no limit to the number of pins that"]
        #[doc = " can be used (as long as they are compatible)."]
        #[doc = ""]
        #[doc = " The pin is consumed and cannot be returned."]
        pub fn output_to_pb14(self, _p: gpiob::PB14<gpio::AF1>) -> PwmChannel<TIM15_CH1, WithPins> {
            self
        }
    }
    impl PwmChannel<TIM15_CH1, NoPins> {
        #[doc = " Output to a specific pin from a channel that does not yet have"]
        #[doc = " any pins.  This channel cannot be enabled until this method"]
        #[doc = " is called."]
        #[doc = ""]
        #[doc = " The pin is consumed and cannot be returned."]
        pub fn output_to_pf9(self, _p: gpiof::PF9<gpio::AF3>) -> PwmChannel<TIM15_CH1, WithPins> {
            unsafe {
                (*TIM15::ptr())
                    .ccmr1_output()
                    .modify(|_, w| w.oc1m().bits(0b0110).oc1pe().set_bit());
            }
            PwmChannel {
                timx_chy: PhantomData,
                pin_status: PhantomData,
            }
        }
    }
    impl PwmChannel<TIM15_CH1, WithPins> {
        #[doc = " Output to a specific pin from a channel is already configured"]
        #[doc = " with output pins.  There is no limit to the number of pins that"]
        #[doc = " can be used (as long as they are compatible)."]
        #[doc = ""]
        #[doc = " The pin is consumed and cannot be returned."]
        pub fn output_to_pf9(self, _p: gpiof::PF9<gpio::AF3>) -> PwmChannel<TIM15_CH1, WithPins> {
            self
        }
    }
    impl PwmChannel<TIM15_CH1, NoPins> {
        #[doc = " Output to a specific pin from a channel that does not yet have"]
        #[doc = " any pins.  This channel cannot be enabled until this method"]
        #[doc = " is called."]
        #[doc = ""]
        #[doc = " The pin is consumed and cannot be returned."]
        pub fn output_to_pa1(self, _p: gpioa::PA1<gpio::AF9>) -> PwmChannel<TIM15_CH1, WithNPins> {
            unsafe {
                (*TIM15::ptr())
                    .ccmr1_output()
                    .modify(|_, w| w.oc1m().bits(0b0110).oc1pe().set_bit());
            }
            PwmChannel {
                timx_chy: PhantomData,
                pin_status: PhantomData,
            }
        }
    }
    impl PwmChannel<TIM15_CH1, WithNPins> {
        #[doc = " Output to a specific pin from a channel is already configured"]
        #[doc = " with output pins.  There is no limit to the number of pins that"]
        #[doc = " can be used (as long as they are compatible)."]
        #[doc = ""]
        #[doc = " The pin is consumed and cannot be returned."]
        pub fn output_to_pa1(self, _p: gpioa::PA1<gpio::AF9>) -> PwmChannel<TIM15_CH1, WithNPins> {
            self
        }
    }
    impl PwmChannel<TIM15_CH1, NoPins> {
        #[doc = " Output to a specific pin from a channel that does not yet have"]
        #[doc = " any pins.  This channel cannot be enabled until this method"]
        #[doc = " is called."]
        #[doc = ""]
        #[doc = " The pin is consumed and cannot be returned."]
        pub fn output_to_pb15(
            self,
            _p: gpiob::PB15<gpio::AF2>,
        ) -> PwmChannel<TIM15_CH1, WithNPins> {
            unsafe {
                (*TIM15::ptr())
                    .ccmr1_output()
                    .modify(|_, w| w.oc1m().bits(0b0110).oc1pe().set_bit());
            }
            PwmChannel {
                timx_chy: PhantomData,
                pin_status: PhantomData,
            }
        }
    }
    impl PwmChannel<TIM15_CH1, WithNPins> {
        #[doc = " Output to a specific pin from a channel is already configured"]
        #[doc = " with output pins.  There is no limit to the number of pins that"]
        #[doc = " can be used (as long as they are compatible)."]
        #[doc = ""]
        #[doc = " The pin is consumed and cannot be returned."]
        pub fn output_to_pb15(
            self,
            _p: gpiob::PB15<gpio::AF2>,
        ) -> PwmChannel<TIM15_CH1, WithNPins> {
            self
        }
    }
    impl PwmChannel<TIM15_CH2, NoPins> {
        #[doc = " Output to a specific pin from a channel that does not yet have"]
        #[doc = " any pins.  This channel cannot be enabled until this method"]
        #[doc = " is called."]
        #[doc = ""]
        #[doc = " The pin is consumed and cannot be returned."]
        pub fn output_to_pa3(self, _p: gpioa::PA3<gpio::AF9>) -> PwmChannel<TIM15_CH2, WithPins> {
            unsafe {
                (*TIM15::ptr())
                    .ccmr1_output()
                    .modify(|_, w| w.oc2m().bits(0b0110).oc2pe().set_bit());
            }
            PwmChannel {
                timx_chy: PhantomData,
                pin_status: PhantomData,
            }
        }
    }
    impl PwmChannel<TIM15_CH2, WithPins> {
        #[doc = " Output to a specific pin from a channel is already configured"]
        #[doc = " with output pins.  There is no limit to the number of pins that"]
        #[doc = " can be used (as long as they are compatible)."]
        #[doc = ""]
        #[doc = " The pin is consumed and cannot be returned."]
        pub fn output_to_pa3(self, _p: gpioa::PA3<gpio::AF9>) -> PwmChannel<TIM15_CH2, WithPins> {
            self
        }
    }
    impl PwmChannel<TIM15_CH2, NoPins> {
        #[doc = " Output to a specific pin from a channel that does not yet have"]
        #[doc = " any pins.  This channel cannot be enabled until this method"]
        #[doc = " is called."]
        #[doc = ""]
        #[doc = " The pin is consumed and cannot be returned."]
        pub fn output_to_pb15(self, _p: gpiob::PB15<gpio::AF2>) -> PwmChannel<TIM15_CH2, WithPins> {
            unsafe {
                (*TIM15::ptr())
                    .ccmr1_output()
                    .modify(|_, w| w.oc2m().bits(0b0110).oc2pe().set_bit());
            }
            PwmChannel {
                timx_chy: PhantomData,
                pin_status: PhantomData,
            }
        }
    }
    impl PwmChannel<TIM15_CH2, WithPins> {
        #[doc = " Output to a specific pin from a channel is already configured"]
        #[doc = " with output pins.  There is no limit to the number of pins that"]
        #[doc = " can be used (as long as they are compatible)."]
        #[doc = ""]
        #[doc = " The pin is consumed and cannot be returned."]
        pub fn output_to_pb15(self, _p: gpiob::PB15<gpio::AF2>) -> PwmChannel<TIM15_CH2, WithPins> {
            self
        }
    }
    impl PwmChannel<TIM15_CH2, NoPins> {
        #[doc = " Output to a specific pin from a channel that does not yet have"]
        #[doc = " any pins.  This channel cannot be enabled until this method"]
        #[doc = " is called."]
        #[doc = ""]
        #[doc = " The pin is consumed and cannot be returned."]
        pub fn output_to_pf10(self, _p: gpiof::PF10<gpio::AF3>) -> PwmChannel<TIM15_CH2, WithPins> {
            unsafe {
                (*TIM15::ptr())
                    .ccmr1_output()
                    .modify(|_, w| w.oc2m().bits(0b0110).oc2pe().set_bit());
            }
            PwmChannel {
                timx_chy: PhantomData,
                pin_status: PhantomData,
            }
        }
    }
    impl PwmChannel<TIM15_CH2, WithPins> {
        #[doc = " Output to a specific pin from a channel is already configured"]
        #[doc = " with output pins.  There is no limit to the number of pins that"]
        #[doc = " can be used (as long as they are compatible)."]
        #[doc = ""]
        #[doc = " The pin is consumed and cannot be returned."]
        pub fn output_to_pf10(self, _p: gpiof::PF10<gpio::AF3>) -> PwmChannel<TIM15_CH2, WithPins> {
            self
        }
    }
    #[doc = " Create one or more output channels from a TIM Peripheral"]
    #[doc = " This function requires the maximum resolution of the duty cycle,"]
    #[doc = " the period of the PWM signal and the frozen clock configuration."]
    #[doc = ""]
    #[doc = " The resolution should be chosen to offer sufficient steps against"]
    #[doc = " your target peripheral.  For example, a servo that can turn from"]
    #[doc = " 0 degrees (2% duty cycle) to 180 degrees (4% duty cycle) might choose"]
    #[doc = " a resolution of 9000.  This allows the servo to be set in increments"]
    #[doc = " of exactly one degree."]
    #[allow(unused_parens)]
    pub fn tim16(
        tim: TIM16,
        res: u16,
        freq: Hertz,
        clocks: &Clocks,
    ) -> (PwmChannel<TIM16_CH1, NoPins>) {
        unsafe {
            (*RCC::ptr()).apb2enr.modify(|_, w| w.tim16en().set_bit());
            (*RCC::ptr()).apb2rstr.modify(|_, w| w.tim16rst().set_bit());
            (*RCC::ptr())
                .apb2rstr
                .modify(|_, w| w.tim16rst().clear_bit());
        }
        tim.cr1.modify(|_, w| w.arpe().set_bit());
        #[allow(unused_unsafe)]
        tim.arr.write(|w| unsafe { w.arr().bits(res) });
        let clock_freq = clocks.pclk2().0 * if clocks.ppre1() == 1 { 1 } else { 2 };
        let prescale_factor = clock_freq / res as u32 / freq.0;
        tim.psc.write(|w| w.psc().bits(prescale_factor as u16 - 1));
        tim.egr.write(|w| w.ug().set_bit());
        (|tim: &TIM16| tim.bdtr.modify(|_, w| w.moe().set_bit()))(&tim);
        tim.cr1.modify(|_, w| w.cen().set_bit());
        (PwmChannel {
            timx_chy: PhantomData,
            pin_status: PhantomData,
        })
    }
    impl PwmPin for PwmChannel<TIM16_CH1, WithPins> {
        type Duty = u16;
        fn disable(&mut self) {
            unsafe {
                (*TIM16::ptr()).ccer.modify(|_, w| w.cc1e().clear_bit());
            }
        }
        fn enable(&mut self) {
            unsafe {
                (*TIM16::ptr()).ccer.modify(|_, w| w.cc1e().set_bit());
            }
        }
        fn get_max_duty(&self) -> Self::Duty {
            unsafe { (*TIM16::ptr()).arr.read().arr().bits() }
        }
        fn get_duty(&self) -> Self::Duty {
            unsafe { (*TIM16::ptr()).ccr1.read().ccr1().bits() }
        }
        fn set_duty(&mut self, duty: Self::Duty) -> () {
            unsafe {
                (*TIM16::ptr()).ccr1.modify(|_, w| w.ccr1().bits(duty));
            }
        }
    }
    impl PwmPin for PwmChannel<TIM16_CH1, WithNPins> {
        type Duty = u16;
        fn disable(&mut self) {
            unsafe {
                (*TIM16::ptr()).ccer.modify(|_, w| w.cc1ne().clear_bit());
            }
        }
        fn enable(&mut self) {
            unsafe {
                (*TIM16::ptr()).ccer.modify(|_, w| w.cc1ne().set_bit());
            }
        }
        fn get_max_duty(&self) -> Self::Duty {
            unsafe { (*TIM16::ptr()).arr.read().arr().bits() }
        }
        fn get_duty(&self) -> Self::Duty {
            unsafe { (*TIM16::ptr()).ccr1.read().ccr1().bits() }
        }
        fn set_duty(&mut self, duty: Self::Duty) -> () {
            unsafe {
                (*TIM16::ptr()).ccr1.modify(|_, w| w.ccr1().bits(duty));
            }
        }
    }
    impl PwmChannel<TIM16_CH1, NoPins> {
        #[doc = " Output to a specific pin from a channel that does not yet have"]
        #[doc = " any pins.  This channel cannot be enabled until this method"]
        #[doc = " is called."]
        #[doc = ""]
        #[doc = " The pin is consumed and cannot be returned."]
        pub fn output_to_pa9(self, _p: gpioa::PA6<gpio::AF1>) -> PwmChannel<TIM16_CH1, WithPins> {
            unsafe {
                (*TIM16::ptr())
                    .ccmr1_output()
                    .modify(|_, w| w.oc1m().bits(0b0110).oc1pe().set_bit());
            }
            PwmChannel {
                timx_chy: PhantomData,
                pin_status: PhantomData,
            }
        }
    }
    impl PwmChannel<TIM16_CH1, WithPins> {
        #[doc = " Output to a specific pin from a channel is already configured"]
        #[doc = " with output pins.  There is no limit to the number of pins that"]
        #[doc = " can be used (as long as they are compatible)."]
        #[doc = ""]
        #[doc = " The pin is consumed and cannot be returned."]
        pub fn output_to_pa9(self, _p: gpioa::PA6<gpio::AF1>) -> PwmChannel<TIM16_CH1, WithPins> {
            self
        }
    }
    impl PwmChannel<TIM16_CH1, NoPins> {
        #[doc = " Output to a specific pin from a channel that does not yet have"]
        #[doc = " any pins.  This channel cannot be enabled until this method"]
        #[doc = " is called."]
        #[doc = ""]
        #[doc = " The pin is consumed and cannot be returned."]
        pub fn output_to_pa12(self, _p: gpioa::PA12<gpio::AF1>) -> PwmChannel<TIM16_CH1, WithPins> {
            unsafe {
                (*TIM16::ptr())
                    .ccmr1_output()
                    .modify(|_, w| w.oc1m().bits(0b0110).oc1pe().set_bit());
            }
            PwmChannel {
                timx_chy: PhantomData,
                pin_status: PhantomData,
            }
        }
    }
    impl PwmChannel<TIM16_CH1, WithPins> {
        #[doc = " Output to a specific pin from a channel is already configured"]
        #[doc = " with output pins.  There is no limit to the number of pins that"]
        #[doc = " can be used (as long as they are compatible)."]
        #[doc = ""]
        #[doc = " The pin is consumed and cannot be returned."]
        pub fn output_to_pa12(self, _p: gpioa::PA12<gpio::AF1>) -> PwmChannel<TIM16_CH1, WithPins> {
            self
        }
    }
    impl PwmChannel<TIM16_CH1, NoPins> {
        #[doc = " Output to a specific pin from a channel that does not yet have"]
        #[doc = " any pins.  This channel cannot be enabled until this method"]
        #[doc = " is called."]
        #[doc = ""]
        #[doc = " The pin is consumed and cannot be returned."]
        pub fn output_to_pb4(self, _p: gpiob::PB4<gpio::AF1>) -> PwmChannel<TIM16_CH1, WithPins> {
            unsafe {
                (*TIM16::ptr())
                    .ccmr1_output()
                    .modify(|_, w| w.oc1m().bits(0b0110).oc1pe().set_bit());
            }
            PwmChannel {
                timx_chy: PhantomData,
                pin_status: PhantomData,
            }
        }
    }
    impl PwmChannel<TIM16_CH1, WithPins> {
        #[doc = " Output to a specific pin from a channel is already configured"]
        #[doc = " with output pins.  There is no limit to the number of pins that"]
        #[doc = " can be used (as long as they are compatible)."]
        #[doc = ""]
        #[doc = " The pin is consumed and cannot be returned."]
        pub fn output_to_pb4(self, _p: gpiob::PB4<gpio::AF1>) -> PwmChannel<TIM16_CH1, WithPins> {
            self
        }
    }
    impl PwmChannel<TIM16_CH1, NoPins> {
        #[doc = " Output to a specific pin from a channel that does not yet have"]
        #[doc = " any pins.  This channel cannot be enabled until this method"]
        #[doc = " is called."]
        #[doc = ""]
        #[doc = " The pin is consumed and cannot be returned."]
        pub fn output_to_pb8(self, _p: gpiob::PB8<gpio::AF1>) -> PwmChannel<TIM16_CH1, WithPins> {
            unsafe {
                (*TIM16::ptr())
                    .ccmr1_output()
                    .modify(|_, w| w.oc1m().bits(0b0110).oc1pe().set_bit());
            }
            PwmChannel {
                timx_chy: PhantomData,
                pin_status: PhantomData,
            }
        }
    }
    impl PwmChannel<TIM16_CH1, WithPins> {
        #[doc = " Output to a specific pin from a channel is already configured"]
        #[doc = " with output pins.  There is no limit to the number of pins that"]
        #[doc = " can be used (as long as they are compatible)."]
        #[doc = ""]
        #[doc = " The pin is consumed and cannot be returned."]
        pub fn output_to_pb8(self, _p: gpiob::PB8<gpio::AF1>) -> PwmChannel<TIM16_CH1, WithPins> {
            self
        }
    }
    impl PwmChannel<TIM16_CH1, NoPins> {
        #[doc = " Output to a specific pin from a channel that does not yet have"]
        #[doc = " any pins.  This channel cannot be enabled until this method"]
        #[doc = " is called."]
        #[doc = ""]
        #[doc = " The pin is consumed and cannot be returned."]
        pub fn output_to_pe0(self, _p: gpioe::PE0<gpio::AF4>) -> PwmChannel<TIM16_CH1, WithPins> {
            unsafe {
                (*TIM16::ptr())
                    .ccmr1_output()
                    .modify(|_, w| w.oc1m().bits(0b0110).oc1pe().set_bit());
            }
            PwmChannel {
                timx_chy: PhantomData,
                pin_status: PhantomData,
            }
        }
    }
    impl PwmChannel<TIM16_CH1, WithPins> {
        #[doc = " Output to a specific pin from a channel is already configured"]
        #[doc = " with output pins.  There is no limit to the number of pins that"]
        #[doc = " can be used (as long as they are compatible)."]
        #[doc = ""]
        #[doc = " The pin is consumed and cannot be returned."]
        pub fn output_to_pe0(self, _p: gpioe::PE0<gpio::AF4>) -> PwmChannel<TIM16_CH1, WithPins> {
            self
        }
    }
    impl PwmChannel<TIM16_CH1, NoPins> {
        #[doc = " Output to a specific pin from a channel that does not yet have"]
        #[doc = " any pins.  This channel cannot be enabled until this method"]
        #[doc = " is called."]
        #[doc = ""]
        #[doc = " The pin is consumed and cannot be returned."]
        pub fn output_to_pa13(
            self,
            _p: gpioa::PA13<gpio::AF1>,
        ) -> PwmChannel<TIM16_CH1, WithNPins> {
            unsafe {
                (*TIM16::ptr())
                    .ccmr1_output()
                    .modify(|_, w| w.oc1m().bits(0b0110).oc1pe().set_bit());
            }
            PwmChannel {
                timx_chy: PhantomData,
                pin_status: PhantomData,
            }
        }
    }
    impl PwmChannel<TIM16_CH1, WithNPins> {
        #[doc = " Output to a specific pin from a channel is already configured"]
        #[doc = " with output pins.  There is no limit to the number of pins that"]
        #[doc = " can be used (as long as they are compatible)."]
        #[doc = ""]
        #[doc = " The pin is consumed and cannot be returned."]
        pub fn output_to_pa13(
            self,
            _p: gpioa::PA13<gpio::AF1>,
        ) -> PwmChannel<TIM16_CH1, WithNPins> {
            self
        }
    }
    impl PwmChannel<TIM16_CH1, NoPins> {
        #[doc = " Output to a specific pin from a channel that does not yet have"]
        #[doc = " any pins.  This channel cannot be enabled until this method"]
        #[doc = " is called."]
        #[doc = ""]
        #[doc = " The pin is consumed and cannot be returned."]
        pub fn output_to_pb6(self, _p: gpiob::PB6<gpio::AF1>) -> PwmChannel<TIM16_CH1, WithNPins> {
            unsafe {
                (*TIM16::ptr())
                    .ccmr1_output()
                    .modify(|_, w| w.oc1m().bits(0b0110).oc1pe().set_bit());
            }
            PwmChannel {
                timx_chy: PhantomData,
                pin_status: PhantomData,
            }
        }
    }
    impl PwmChannel<TIM16_CH1, WithNPins> {
        #[doc = " Output to a specific pin from a channel is already configured"]
        #[doc = " with output pins.  There is no limit to the number of pins that"]
        #[doc = " can be used (as long as they are compatible)."]
        #[doc = ""]
        #[doc = " The pin is consumed and cannot be returned."]
        pub fn output_to_pb6(self, _p: gpiob::PB6<gpio::AF1>) -> PwmChannel<TIM16_CH1, WithNPins> {
            self
        }
    }
    #[doc = " Create one or more output channels from a TIM Peripheral"]
    #[doc = " This function requires the maximum resolution of the duty cycle,"]
    #[doc = " the period of the PWM signal and the frozen clock configuration."]
    #[doc = ""]
    #[doc = " The resolution should be chosen to offer sufficient steps against"]
    #[doc = " your target peripheral.  For example, a servo that can turn from"]
    #[doc = " 0 degrees (2% duty cycle) to 180 degrees (4% duty cycle) might choose"]
    #[doc = " a resolution of 9000.  This allows the servo to be set in increments"]
    #[doc = " of exactly one degree."]
    #[allow(unused_parens)]
    pub fn tim17(
        tim: TIM17,
        res: u16,
        freq: Hertz,
        clocks: &Clocks,
    ) -> (PwmChannel<TIM17_CH1, NoPins>) {
        unsafe {
            (*RCC::ptr()).apb2enr.modify(|_, w| w.tim17en().set_bit());
            (*RCC::ptr()).apb2rstr.modify(|_, w| w.tim17rst().set_bit());
            (*RCC::ptr())
                .apb2rstr
                .modify(|_, w| w.tim17rst().clear_bit());
        }
        tim.cr1.modify(|_, w| w.arpe().set_bit());
        #[allow(unused_unsafe)]
        tim.arr.write(|w| unsafe { w.arr().bits(res) });
        let clock_freq = clocks.pclk2().0 * if clocks.ppre1() == 1 { 1 } else { 2 };
        let prescale_factor = clock_freq / res as u32 / freq.0;
        tim.psc.write(|w| w.psc().bits(prescale_factor as u16 - 1));
        tim.egr.write(|w| w.ug().set_bit());
        (|tim: &TIM17| tim.bdtr.modify(|_, w| w.moe().set_bit()))(&tim);
        tim.cr1.modify(|_, w| w.cen().set_bit());
        (PwmChannel {
            timx_chy: PhantomData,
            pin_status: PhantomData,
        })
    }
    impl PwmPin for PwmChannel<TIM17_CH1, WithPins> {
        type Duty = u16;
        fn disable(&mut self) {
            unsafe {
                (*TIM17::ptr()).ccer.modify(|_, w| w.cc1e().clear_bit());
            }
        }
        fn enable(&mut self) {
            unsafe {
                (*TIM17::ptr()).ccer.modify(|_, w| w.cc1e().set_bit());
            }
        }
        fn get_max_duty(&self) -> Self::Duty {
            unsafe { (*TIM17::ptr()).arr.read().arr().bits() }
        }
        fn get_duty(&self) -> Self::Duty {
            unsafe { (*TIM17::ptr()).ccr1.read().ccr1().bits() }
        }
        fn set_duty(&mut self, duty: Self::Duty) -> () {
            unsafe {
                (*TIM17::ptr()).ccr1.modify(|_, w| w.ccr1().bits(duty));
            }
        }
    }
    impl PwmPin for PwmChannel<TIM17_CH1, WithNPins> {
        type Duty = u16;
        fn disable(&mut self) {
            unsafe {
                (*TIM17::ptr()).ccer.modify(|_, w| w.cc1ne().clear_bit());
            }
        }
        fn enable(&mut self) {
            unsafe {
                (*TIM17::ptr()).ccer.modify(|_, w| w.cc1ne().set_bit());
            }
        }
        fn get_max_duty(&self) -> Self::Duty {
            unsafe { (*TIM17::ptr()).arr.read().arr().bits() }
        }
        fn get_duty(&self) -> Self::Duty {
            unsafe { (*TIM17::ptr()).ccr1.read().ccr1().bits() }
        }
        fn set_duty(&mut self, duty: Self::Duty) -> () {
            unsafe {
                (*TIM17::ptr()).ccr1.modify(|_, w| w.ccr1().bits(duty));
            }
        }
    }
    impl PwmChannel<TIM17_CH1, NoPins> {
        #[doc = " Output to a specific pin from a channel that does not yet have"]
        #[doc = " any pins.  This channel cannot be enabled until this method"]
        #[doc = " is called."]
        #[doc = ""]
        #[doc = " The pin is consumed and cannot be returned."]
        pub fn output_to_pa7(self, _p: gpioa::PA7<gpio::AF1>) -> PwmChannel<TIM17_CH1, WithPins> {
            unsafe {
                (*TIM17::ptr())
                    .ccmr1_output()
                    .modify(|_, w| w.oc1m().bits(0b0110).oc1pe().set_bit());
            }
            PwmChannel {
                timx_chy: PhantomData,
                pin_status: PhantomData,
            }
        }
    }
    impl PwmChannel<TIM17_CH1, WithPins> {
        #[doc = " Output to a specific pin from a channel is already configured"]
        #[doc = " with output pins.  There is no limit to the number of pins that"]
        #[doc = " can be used (as long as they are compatible)."]
        #[doc = ""]
        #[doc = " The pin is consumed and cannot be returned."]
        pub fn output_to_pa7(self, _p: gpioa::PA7<gpio::AF1>) -> PwmChannel<TIM17_CH1, WithPins> {
            self
        }
    }
    impl PwmChannel<TIM17_CH1, NoPins> {
        #[doc = " Output to a specific pin from a channel that does not yet have"]
        #[doc = " any pins.  This channel cannot be enabled until this method"]
        #[doc = " is called."]
        #[doc = ""]
        #[doc = " The pin is consumed and cannot be returned."]
        pub fn output_to_pb5(self, _p: gpiob::PB5<gpio::AF10>) -> PwmChannel<TIM17_CH1, WithPins> {
            unsafe {
                (*TIM17::ptr())
                    .ccmr1_output()
                    .modify(|_, w| w.oc1m().bits(0b0110).oc1pe().set_bit());
            }
            PwmChannel {
                timx_chy: PhantomData,
                pin_status: PhantomData,
            }
        }
    }
    impl PwmChannel<TIM17_CH1, WithPins> {
        #[doc = " Output to a specific pin from a channel is already configured"]
        #[doc = " with output pins.  There is no limit to the number of pins that"]
        #[doc = " can be used (as long as they are compatible)."]
        #[doc = ""]
        #[doc = " The pin is consumed and cannot be returned."]
        pub fn output_to_pb5(self, _p: gpiob::PB5<gpio::AF10>) -> PwmChannel<TIM17_CH1, WithPins> {
            self
        }
    }
    impl PwmChannel<TIM17_CH1, NoPins> {
        #[doc = " Output to a specific pin from a channel that does not yet have"]
        #[doc = " any pins.  This channel cannot be enabled until this method"]
        #[doc = " is called."]
        #[doc = ""]
        #[doc = " The pin is consumed and cannot be returned."]
        pub fn output_to_pb9(self, _p: gpiob::PB9<gpio::AF1>) -> PwmChannel<TIM17_CH1, WithPins> {
            unsafe {
                (*TIM17::ptr())
                    .ccmr1_output()
                    .modify(|_, w| w.oc1m().bits(0b0110).oc1pe().set_bit());
            }
            PwmChannel {
                timx_chy: PhantomData,
                pin_status: PhantomData,
            }
        }
    }
    impl PwmChannel<TIM17_CH1, WithPins> {
        #[doc = " Output to a specific pin from a channel is already configured"]
        #[doc = " with output pins.  There is no limit to the number of pins that"]
        #[doc = " can be used (as long as they are compatible)."]
        #[doc = ""]
        #[doc = " The pin is consumed and cannot be returned."]
        pub fn output_to_pb9(self, _p: gpiob::PB9<gpio::AF1>) -> PwmChannel<TIM17_CH1, WithPins> {
            self
        }
    }
    impl PwmChannel<TIM17_CH1, NoPins> {
        #[doc = " Output to a specific pin from a channel that does not yet have"]
        #[doc = " any pins.  This channel cannot be enabled until this method"]
        #[doc = " is called."]
        #[doc = ""]
        #[doc = " The pin is consumed and cannot be returned."]
        pub fn output_to_pe1(self, _p: gpioe::PE1<gpio::AF4>) -> PwmChannel<TIM17_CH1, WithPins> {
            unsafe {
                (*TIM17::ptr())
                    .ccmr1_output()
                    .modify(|_, w| w.oc1m().bits(0b0110).oc1pe().set_bit());
            }
            PwmChannel {
                timx_chy: PhantomData,
                pin_status: PhantomData,
            }
        }
    }
    impl PwmChannel<TIM17_CH1, WithPins> {
        #[doc = " Output to a specific pin from a channel is already configured"]
        #[doc = " with output pins.  There is no limit to the number of pins that"]
        #[doc = " can be used (as long as they are compatible)."]
        #[doc = ""]
        #[doc = " The pin is consumed and cannot be returned."]
        pub fn output_to_pe1(self, _p: gpioe::PE1<gpio::AF4>) -> PwmChannel<TIM17_CH1, WithPins> {
            self
        }
    }
    impl PwmChannel<TIM17_CH1, NoPins> {
        #[doc = " Output to a specific pin from a channel that does not yet have"]
        #[doc = " any pins.  This channel cannot be enabled until this method"]
        #[doc = " is called."]
        #[doc = ""]
        #[doc = " The pin is consumed and cannot be returned."]
        pub fn output_to_pa13(
            self,
            _p: gpioa::PA13<gpio::AF1>,
        ) -> PwmChannel<TIM17_CH1, WithNPins> {
            unsafe {
                (*TIM17::ptr())
                    .ccmr1_output()
                    .modify(|_, w| w.oc1m().bits(0b0110).oc1pe().set_bit());
            }
            PwmChannel {
                timx_chy: PhantomData,
                pin_status: PhantomData,
            }
        }
    }
    impl PwmChannel<TIM17_CH1, WithNPins> {
        #[doc = " Output to a specific pin from a channel is already configured"]
        #[doc = " with output pins.  There is no limit to the number of pins that"]
        #[doc = " can be used (as long as they are compatible)."]
        #[doc = ""]
        #[doc = " The pin is consumed and cannot be returned."]
        pub fn output_to_pa13(
            self,
            _p: gpioa::PA13<gpio::AF1>,
        ) -> PwmChannel<TIM17_CH1, WithNPins> {
            self
        }
    }
}
pub mod rcc {
    #![doc = " Reset and Clock Control"]
    #![doc = ""]
    #![doc = " The most important function this module"]
    #![doc = " delivers is the clock configuration."]
    #![doc = ""]
    #![doc = " To configure the clock, we first have to obtain the"]
    #![doc = " device peripherals."]
    #![doc = ""]
    #![doc = " ```"]
    #![doc = " # use cortex_m_rt::entry;"]
    #![doc = " # use stm32f3xx_hal::prelude::*;"]
    #![doc = " # #[entry]"]
    #![doc = " # fn main() -> ! {"]
    #![doc = " // Get our peripherals"]
    #![doc = " let dp = pac::Peripherals::take().unwrap();"]
    #![doc = ""]
    #![doc = " let mut flash = dp.FLASH.constrain();"]
    #![doc = " let mut rcc = dp.RCC.constrain();"]
    #![doc = " # }"]
    #![doc = " ```"]
    #![doc = ""]
    #![doc = " After that we can configure the clock"]
    #![doc = ""]
    #![doc = " ```"]
    #![doc = " # use cortex_m_rt::entry;"]
    #![doc = " # use stm32f3xx_hal::prelude::*;"]
    #![doc = " # #[entry]"]
    #![doc = " # fn main() -> ! {"]
    #![doc = " # let dp = pac::Peripherals::take().unwrap();"]
    #![doc = ""]
    #![doc = " # let mut flash = dp.FLASH.constrain();"]
    #![doc = " # let mut rcc = dp.RCC.constrain();"]
    #![doc = " let clocks = rcc.cfgr"]
    #![doc = "     // Using the external oscillator"]
    #![doc = "     // Set the frequency to that of the external oscillator"]
    #![doc = "     .use_hse(8.mhz())"]
    #![doc = "     // Set the frequency for the AHB bus,"]
    #![doc = "     // which the root of every following clock peripheral"]
    #![doc = "     .hclk(48.mhz())"]
    #![doc = "     // The sysclk is equivalent to the core clock"]
    #![doc = "     .sysclk(48.mhz())"]
    #![doc = "     // The following are peripheral clocks, which are both"]
    #![doc = "     // needed to configure specific peripherals."]
    #![doc = "     // Looking at the peripheral function parameters"]
    #![doc = "     // should give more insight, which peripheral clock is needed."]
    #![doc = "     .pclk1(12.mhz())"]
    #![doc = "     .pclk2(12.mhz())"]
    #![doc = "     // Freeze / apply the configuration and setup all clocks"]
    #![doc = "     .freeze(&mut flash.acr);"]
    #![doc = " # }"]
    #![doc = " ```"]
    #![doc = ""]
    #![doc = " All fields can be omitted and will internally be set to a calculated default."]
    #![doc = " For more details read the documentation of the [`CFGR`] methods to"]
    #![doc = " find out how to setup the clock."]
    use crate::pac::{
        rcc::{self, cfgr, cfgr2},
        RCC,
    };
    use crate::flash::ACR;
    use crate::time::Hertz;
    #[doc = " Extension trait that constrains the `RCC` peripheral"]
    pub trait RccExt {
        #[doc = " Constrains the `RCC` peripheral so it plays nicely with the other abstractions"]
        fn constrain(self) -> Rcc;
    }
    impl RccExt for RCC {
        fn constrain(self) -> Rcc {
            Rcc {
                ahb: AHB { _0: () },
                apb1: APB1 { _0: () },
                apb2: APB2 { _0: () },
                bdcr: BDCR { _0: () },
                cfgr: CFGR::default(),
            }
        }
    }
    #[doc = " Constrained RCC peripheral"]
    #[doc = ""]
    #[doc = " An instance of this struct is acquired by calling the"]
    #[doc = " [`constrain`](RccExt::constrain) function on the"]
    #[doc = " [`RCC`](crate::pac::RCC) struct."]
    #[doc = ""]
    #[doc = " ```"]
    #[doc = " let dp = pac::Peripherals::take().unwrap();"]
    #[doc = " let rcc = dp.RCC.constrain();"]
    #[doc = " ```"]
    pub struct Rcc {
        #[doc = " AMBA High-performance Bus (AHB) registers"]
        pub ahb: AHB,
        #[doc = " Advanced Peripheral Bus 1 (APB1) registers"]
        pub apb1: APB1,
        #[doc = " Advanced Peripheral Bus 2 (APB2) registers"]
        pub apb2: APB2,
        #[doc = " RCC Backup Domain"]
        pub bdcr: BDCR,
        #[doc = " Clock configuration"]
        pub cfgr: CFGR,
    }
    #[doc = " AMBA High-performance Bus (AHB) registers"]
    #[doc = ""]
    #[doc = " An instance of this struct is acquired from the [`RCC`](crate::pac::RCC) struct."]
    #[doc = ""]
    #[doc = " ```"]
    #[doc = " let dp = pac::Peripherals::take().unwrap();"]
    #[doc = " let rcc = dp.RCC.constrain();"]
    #[doc = " use_ahb(&mut rcc.ahb)"]
    #[doc = " ```"]
    pub struct AHB {
        _0: (),
    }
    impl AHB {
        pub(crate) fn enr(&mut self) -> &rcc::AHBENR {
            unsafe { &(*RCC::ptr()).ahbenr }
        }
        pub(crate) fn rstr(&mut self) -> &rcc::AHBRSTR {
            unsafe { &(*RCC::ptr()).ahbrstr }
        }
    }
    #[doc = " Advanced Peripheral Bus 1 (APB1) registers"]
    #[doc = ""]
    #[doc = " An instance of this struct is acquired from the [`RCC`](crate::pac::RCC) struct."]
    #[doc = ""]
    #[doc = " ```"]
    #[doc = " let dp = pac::Peripherals::take().unwrap();"]
    #[doc = " let rcc = dp.RCC.constrain();"]
    #[doc = " use_apb1(&mut rcc.apb1)"]
    #[doc = " ```"]
    pub struct APB1 {
        _0: (),
    }
    impl APB1 {
        pub(crate) fn enr(&mut self) -> &rcc::APB1ENR {
            unsafe { &(*RCC::ptr()).apb1enr }
        }
        pub(crate) fn rstr(&mut self) -> &rcc::APB1RSTR {
            unsafe { &(*RCC::ptr()).apb1rstr }
        }
    }
    #[doc = " Advanced Peripheral Bus 2 (APB2) registers"]
    #[doc = ""]
    #[doc = " An instance of this struct is acquired from the [`RCC`](crate::pac::RCC) struct."]
    #[doc = ""]
    #[doc = " ```"]
    #[doc = " let dp = pac::Peripherals::take().unwrap();"]
    #[doc = " let rcc = dp.RCC.constrain();"]
    #[doc = " use_apb2(&mut rcc.apb2)"]
    #[doc = " ```"]
    pub struct APB2 {
        _0: (),
    }
    impl APB2 {
        pub(crate) fn enr(&mut self) -> &rcc::APB2ENR {
            unsafe { &(*RCC::ptr()).apb2enr }
        }
        pub(crate) fn rstr(&mut self) -> &rcc::APB2RSTR {
            unsafe { &(*RCC::ptr()).apb2rstr }
        }
    }
    const HSI: u32 = 8_000_000;
    #[cfg(not(any(feature = "stm32f301", feature = "stm32f318", feature = "stm32f334",)))]
    mod usb_clocking {
        use crate::pac::rcc::cfgr;
        use crate::rcc::PllConfig;
        #[doc = " Check for all clock options to be"]
        pub(crate) fn is_valid(
            sysclk: u32,
            hse: Option<u32>,
            pclk1: u32,
            pll_config: &Option<PllConfig>,
        ) -> (cfgr::USBPRE_A, bool) {
            let usb_ok = hse.is_some() && pll_config.is_some();
            if pclk1 >= 10_000_000 {
                match (usb_ok, sysclk) {
                    (true, 72_000_000) => (cfgr::USBPRE_A::DIV1_5, true),
                    (true, 48_000_000) => (cfgr::USBPRE_A::DIV1, true),
                    _ => (cfgr::USBPRE_A::DIV1, false),
                }
            } else {
                (cfgr::USBPRE_A::DIV1, false)
            }
        }
        pub(crate) fn set_usbpre(w: &mut cfgr::W, usb_prescale: cfgr::USBPRE_A) -> &mut cfgr::W {
            w.usbpre().variant(usb_prescale)
        }
    }
    #[doc = " Backup Domain Control register (RCC_BDCR)"]
    pub struct BDCR {
        _0: (),
    }
    impl BDCR {
        pub(crate) fn bdcr(&mut self) -> &rcc::BDCR {
            unsafe { &(*RCC::ptr()).bdcr }
        }
    }
    #[doc = " Clock configuration"]
    #[doc = ""]
    #[doc = " An instance of this struct is acquired from the [`RCC`](crate::pac::RCC) struct."]
    #[doc = ""]
    #[doc = " ```"]
    #[doc = " let dp = pac::Peripherals::take().unwrap();"]
    #[doc = " let rcc = dp.RCC.constrain();"]
    #[doc = " use_cfgr(&mut rcc.cfgr)"]
    #[doc = " ```"]
    pub struct CFGR {
        hse: Option<u32>,
        hse_bypass: bool,
        css: bool,
        hclk: Option<u32>,
        pclk1: Option<u32>,
        pclk2: Option<u32>,
        sysclk: Option<u32>,
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::default::Default for CFGR {
        #[inline]
        fn default() -> CFGR {
            CFGR {
                hse: ::core::default::Default::default(),
                hse_bypass: ::core::default::Default::default(),
                css: ::core::default::Default::default(),
                hclk: ::core::default::Default::default(),
                pclk1: ::core::default::Default::default(),
                pclk2: ::core::default::Default::default(),
                sysclk: ::core::default::Default::default(),
            }
        }
    }
    pub(crate) struct PllConfig {
        src: cfgr::PLLSRC_A,
        mul: cfgr::PLLMUL_A,
        div: Option<cfgr2::PREDIV_A>,
    }
    #[doc = " Determine the [greatest common divisor](https://en.wikipedia.org/wiki/Greatest_common_divisor)"]
    #[doc = ""]
    #[doc = " This function is based on the [Euclidean algorithm](https://en.wikipedia.org/wiki/Euclidean_algorithm)."]
    fn gcd(mut a: u32, mut b: u32) -> u32 {
        while b != 0 {
            let r = a % b;
            a = b;
            b = r;
        }
        a
    }
    #[doc = " Convert pll multiplier into equivalent register field type"]
    fn into_pll_mul(mul: u8) -> cfgr::PLLMUL_A {
        match mul {
            2 => cfgr::PLLMUL_A::MUL2,
            3 => cfgr::PLLMUL_A::MUL3,
            4 => cfgr::PLLMUL_A::MUL4,
            5 => cfgr::PLLMUL_A::MUL5,
            6 => cfgr::PLLMUL_A::MUL6,
            7 => cfgr::PLLMUL_A::MUL7,
            8 => cfgr::PLLMUL_A::MUL8,
            9 => cfgr::PLLMUL_A::MUL9,
            10 => cfgr::PLLMUL_A::MUL10,
            11 => cfgr::PLLMUL_A::MUL11,
            12 => cfgr::PLLMUL_A::MUL12,
            13 => cfgr::PLLMUL_A::MUL13,
            14 => cfgr::PLLMUL_A::MUL14,
            15 => cfgr::PLLMUL_A::MUL15,
            16 => cfgr::PLLMUL_A::MUL16,
            _ => ::core::panicking::panic("internal error: entered unreachable code"),
        }
    }
    #[doc = " Convert pll divisor into equivalent register field type"]
    fn into_pre_div(div: u8) -> cfgr2::PREDIV_A {
        match div {
            1 => cfgr2::PREDIV_A::DIV1,
            2 => cfgr2::PREDIV_A::DIV2,
            3 => cfgr2::PREDIV_A::DIV3,
            4 => cfgr2::PREDIV_A::DIV4,
            5 => cfgr2::PREDIV_A::DIV5,
            6 => cfgr2::PREDIV_A::DIV6,
            7 => cfgr2::PREDIV_A::DIV7,
            8 => cfgr2::PREDIV_A::DIV8,
            9 => cfgr2::PREDIV_A::DIV9,
            10 => cfgr2::PREDIV_A::DIV10,
            11 => cfgr2::PREDIV_A::DIV11,
            12 => cfgr2::PREDIV_A::DIV12,
            13 => cfgr2::PREDIV_A::DIV13,
            14 => cfgr2::PREDIV_A::DIV14,
            15 => cfgr2::PREDIV_A::DIV15,
            16 => cfgr2::PREDIV_A::DIV16,
            _ => ::core::panicking::panic("internal error: entered unreachable code"),
        }
    }
    impl CFGR {
        #[doc = " Uses `HSE` (external oscillator) instead of `HSI` (internal RC oscillator) as the clock source."]
        #[doc = ""]
        #[doc = " Will result in a hang if an external oscillator is not connected or it fails to start,"]
        #[doc = " unless [css](CFGR::enable_css) is enabled."]
        pub fn use_hse<F>(mut self, freq: F) -> Self
        where
            F: Into<Hertz>,
        {
            self.hse = Some(freq.into().0);
            self
        }
        #[doc = " Enable `HSE` bypass."]
        #[doc = ""]
        #[doc = " Uses user provided clock signal instead of an external oscillator."]
        #[doc = " `OSC_OUT` pin is free and can be used as GPIO."]
        #[doc = ""]
        #[doc = " No effect if `HSE` is not enabled."]
        pub fn bypass_hse(mut self) -> Self {
            self.hse_bypass = true;
            self
        }
        #[doc = " Enable `CSS` (Clock Security System)."]
        #[doc = ""]
        #[doc = " System clock is automatically switched to `HSI` and an interrupt (`CSSI`) is generated"]
        #[doc = " when `HSE` clock failure is detected."]
        #[doc = ""]
        #[doc = " No effect if `HSE` is not enabled."]
        pub fn enable_css(mut self) -> Self {
            self.css = true;
            self
        }
        #[doc = " Sets a frequency for the AHB bus"]
        pub fn hclk<F>(mut self, freq: F) -> Self
        where
            F: Into<Hertz>,
        {
            self.hclk = Some(freq.into().0);
            self
        }
        #[doc = " Sets a frequency for the `APB1` bus"]
        #[doc = ""]
        #[doc = " - Maximal supported frequency: 36 Mhz"]
        #[doc = ""]
        #[doc = " If not manually set, it will be set to [`CFGR::sysclk`] frequency"]
        #[doc = " or [`CFGR::sysclk`] frequency / 2, if [`CFGR::sysclk`] > 36 Mhz"]
        pub fn pclk1<F>(mut self, freq: F) -> Self
        where
            F: Into<Hertz>,
        {
            self.pclk1 = Some(freq.into().0);
            self
        }
        #[doc = " Sets a frequency for the `APB2` bus"]
        #[doc = ""]
        #[doc = " # Resolution and Limits"]
        #[doc = ""]
        #[doc = " - Maximal supported frequency with HSE: 72 Mhz"]
        #[doc = " - Maximal supported frequency without HSE: 64 Mhz"]
        #[doc = ""]
        #[doc = " This is true for devices **except** the following devices,"]
        #[doc = " as these allow finer resolutions"]
        #[doc = " even when using the internal oscillator:"]
        #[doc = ""]
        #[doc = "     [stm32f302xd,stm32f302xe,stm32f303xd,stm32f303xe,stm32f398]"]
        #[doc = ""]
        pub fn pclk2<F>(mut self, freq: F) -> Self
        where
            F: Into<Hertz>,
        {
            self.pclk2 = Some(freq.into().0);
            self
        }
        #[doc = " Sets the system (core) frequency"]
        #[doc = ""]
        #[doc = " # Resolution and Limits"]
        #[doc = ""]
        #[doc = " - Maximal supported frequency with `HSE`: 72 Mhz"]
        #[doc = " - Maximal supported frequency without `HSE`: 64 Mhz"]
        #[doc = ""]
        #[doc = " If [`CFGR::hse`] is not used, therefor `HSI / 2` is used."]
        #[doc = " Only multiples of (HSI / 2) (4 Mhz) are allowed."]
        #[doc = ""]
        #[doc = " This is true for devices **except** the following devices,"]
        #[doc = " as these allow finer resolutions"]
        #[doc = " even when using the internal oscillator:"]
        #[doc = ""]
        #[doc = "     [stm32f302xd,stm32f302xe,stm32f303xd,stm32f303xe,stm32f398]"]
        pub fn sysclk<F>(mut self, freq: F) -> Self
        where
            F: Into<Hertz>,
        {
            self.sysclk = Some(freq.into().0);
            self
        }
        #[doc = " Calculate the values for the pll multiplier (`PLLMUL`) and the pll divisior (`PLLDIV`)."]
        #[doc = ""]
        #[doc = " These values are chosen depending on the chosen system clock (SYSCLK) and the frequency of the"]
        #[doc = " oscillator clock (`HSE` / `HSI`)."]
        #[doc = ""]
        #[doc = " For these devices, `PLL_SRC` can selected between the internal oscillator (`HSI`) and"]
        #[doc = " the external oscillator (`HSE`)."]
        #[doc = ""]
        #[doc = " HSI is divided by 2 before its transferred to `PLL_SRC`."]
        #[doc = " HSE can be divided between `1..16`, before it is transferred to `PLL_SRC`."]
        #[doc = " After this system clock frequency (`SYSCLK`) can be changed via multiplier."]
        #[doc = " The value can be multiplied with `2..16`."]
        #[doc = ""]
        #[doc = " To determine the optimal values, if `HSE` is chosen as `PLL_SRC`, the greatest common divisor"]
        #[doc = " is calculated and the limitations of the possible values are taken into consideration."]
        #[doc = ""]
        #[doc = " `HSI` is simpler to calculate, but the possible system clocks are less than `HSE`, because the"]
        #[doc = " division is not configurable."]
        #[cfg(not(any(
            feature = "stm32f302xd",
            feature = "stm32f302xe",
            feature = "stm32f303xd",
            feature = "stm32f303xe",
            feature = "stm32f398"
        )))]
        fn calc_pll(&self, sysclk: u32) -> (u32, PllConfig) {
            let pllsrcclk = self.hse.unwrap_or(HSI / 2);
            let (pll_mul, pll_div): (u32, Option<u32>) = if self.hse.is_some() {
                let common_divisor = gcd(sysclk, pllsrcclk);
                let mut multiplier = sysclk / common_divisor;
                let mut divisor = pllsrcclk / common_divisor;
                if multiplier == 1 {
                    multiplier *= 2;
                    divisor *= 2;
                }
                if !(multiplier <= 16) {
                    ::core::panicking::panic("assertion failed: multiplier <= 16")
                };
                if !(divisor <= 16) {
                    ::core::panicking::panic("assertion failed: divisor <= 16")
                };
                (multiplier, Some(divisor))
            } else {
                let pll_mul = sysclk / pllsrcclk;
                if !(pll_mul <= 16) {
                    ::core::panicking::panic("assertion failed: pll_mul <= 16")
                };
                (pll_mul, None)
            };
            let sysclk = (pllsrcclk / pll_div.unwrap_or(1)) * pll_mul;
            if !(sysclk <= 72_000_000) {
                ::core::panicking::panic("assertion failed: sysclk <= 72_000_000")
            };
            let pll_src = if self.hse.is_some() {
                cfgr::PLLSRC_A::HSE_DIV_PREDIV
            } else {
                cfgr::PLLSRC_A::HSI_DIV2
            };
            let pll_mul_bits = into_pll_mul(pll_mul as u8);
            let pll_div_bits = pll_div.map(|pll_div| into_pre_div(pll_div as u8));
            (
                sysclk,
                PllConfig {
                    src: pll_src,
                    mul: pll_mul_bits,
                    div: pll_div_bits,
                },
            )
        }
        #[doc = " Get the system clock, the system clock source and the pll_options, if needed."]
        #[doc = ""]
        #[doc = " The system clock source is determined by the chosen system clock and the provided hardware"]
        #[doc = " clock."]
        #[doc = " This function does only chose the PLL if needed, otherwise it will use the oscillator clock as system clock."]
        #[doc = ""]
        #[doc = " Calls [`CFGR::calc_pll`] internally."]
        fn get_sysclk(&self) -> (u32, cfgr::SW_A, Option<PllConfig>) {
            match (self.sysclk, self.hse) {
                (Some(sysclk), Some(hse)) if sysclk == hse => (hse, cfgr::SW_A::HSE, None),
                (Some(sysclk), None) if sysclk == HSI => (HSI, cfgr::SW_A::HSI, None),
                (Some(sysclk), _) => {
                    let (sysclk, pll_config) = self.calc_pll(sysclk);
                    (sysclk, cfgr::SW_A::PLL, Some(pll_config))
                }
                (None, Some(hse)) => (hse, cfgr::SW_A::HSE, None),
                (None, None) => (HSI, cfgr::SW_A::HSI, None),
            }
        }
        #[doc = " Freezes the clock configuration, making it effective"]
        #[doc = ""]
        #[doc = " This function internally calculates the specific."]
        #[doc = " divisors for the different clock peripheries."]
        #[doc = ""]
        #[doc = " # Panics"]
        #[doc = ""]
        #[doc = " If any of the set frequencies via [`sysclk`](CFGR::sysclk), [`hclk`](CFGR::hclk), [`pclk1`](CFGR::pclk1) or [`pclk2`](CFGR::pclk2)"]
        #[doc = " are invalid or can not be reached because of e.g. to low frequencies"]
        #[doc = " of the former, as [`sysclk`](CFGR::sysclk) depends on the configuration of [`hclk`](CFGR::hclk)"]
        #[doc = " this function will panic."]
        pub fn freeze(self, acr: &mut ACR) -> Clocks {
            let (sysclk, sysclk_source, pll_config) = self.get_sysclk();
            let (hpre_bits, hpre) =
                self.hclk
                    .map_or((cfgr::HPRE_A::DIV1, 1), |hclk| match sysclk / hclk {
                        0 => ::core::panicking::panic("internal error: entered unreachable code"),
                        1 => (cfgr::HPRE_A::DIV1, 1),
                        2 => (cfgr::HPRE_A::DIV2, 2),
                        3..=5 => (cfgr::HPRE_A::DIV4, 4),
                        6..=11 => (cfgr::HPRE_A::DIV8, 8),
                        12..=39 => (cfgr::HPRE_A::DIV16, 16),
                        40..=95 => (cfgr::HPRE_A::DIV64, 64),
                        96..=191 => (cfgr::HPRE_A::DIV128, 128),
                        192..=383 => (cfgr::HPRE_A::DIV256, 256),
                        _ => (cfgr::HPRE_A::DIV512, 512),
                    });
            let hclk: u32 = sysclk / hpre;
            if !(hclk <= 72_000_000) {
                ::core::panicking::panic("assertion failed: hclk <= 72_000_000")
            };
            let (mut ppre1_bits, mut ppre1) =
                self.pclk1
                    .map_or((cfgr::PPRE1_A::DIV1, 1), |pclk1| match hclk / pclk1 {
                        0 => ::core::panicking::panic("internal error: entered unreachable code"),
                        1 => (cfgr::PPRE1_A::DIV1, 1),
                        2 => (cfgr::PPRE1_A::DIV2, 2),
                        3..=5 => (cfgr::PPRE1_A::DIV4, 4),
                        6..=11 => (cfgr::PPRE1_A::DIV8, 8),
                        _ => (cfgr::PPRE1_A::DIV16, 16),
                    });
            let mut pclk1 = hclk / u32::from(ppre1);
            if self.pclk1.is_none() && pclk1 > 36_000_000 {
                ppre1_bits = cfgr::PPRE1_A::DIV2;
                ppre1 = 2;
                pclk1 = hclk / u32::from(ppre1);
            }
            if !(pclk1 <= 36_000_000) {
                ::core::panicking::panic("assertion failed: pclk1 <= 36_000_000")
            };
            let (ppre2_bits, ppre2) =
                self.pclk2
                    .map_or((cfgr::PPRE2_A::DIV1, 1), |pclk2| match hclk / pclk2 {
                        0 => ::core::panicking::panic("internal error: entered unreachable code"),
                        1 => (cfgr::PPRE2_A::DIV1, 1),
                        2 => (cfgr::PPRE2_A::DIV2, 2),
                        3..=5 => (cfgr::PPRE2_A::DIV4, 4),
                        6..=11 => (cfgr::PPRE2_A::DIV8, 8),
                        _ => (cfgr::PPRE2_A::DIV16, 16),
                    });
            let pclk2 = hclk / u32::from(ppre2);
            if !(pclk2 <= 72_000_000) {
                ::core::panicking::panic("assertion failed: pclk2 <= 72_000_000")
            };
            acr.acr().modify(|_, w| {
                if hclk <= 24_000_000 {
                    w.latency().ws0()
                } else if hclk <= 48_000_000 {
                    w.latency().ws1()
                } else {
                    w.latency().ws2()
                }
            });
            let (usbpre, usbclk_valid) =
                usb_clocking::is_valid(sysclk, self.hse, pclk1, &pll_config);
            let rcc = unsafe { &*RCC::ptr() };
            if self.hse.is_some() {
                rcc.cr.modify(|_, w| {
                    w.hsebyp().bit(self.hse_bypass);
                    w.csson().bit(self.css);
                    w.hseon().on()
                });
                while rcc.cr.read().hserdy().is_not_ready() {}
            }
            if let Some(pll_config) = pll_config {
                rcc.cfgr.modify(|_, w| {
                    w.pllmul()
                        .variant(pll_config.mul)
                        .pllsrc()
                        .variant(pll_config.src)
                });
                if let Some(pll_div) = pll_config.div {
                    rcc.cfgr2.modify(|_, w| w.prediv().variant(pll_div));
                };
                rcc.cr.modify(|_, w| w.pllon().on());
                while rcc.cr.read().pllrdy().is_not_ready() {}
            };
            rcc.cfgr.modify(|_, w| {
                usb_clocking::set_usbpre(w, usbpre);
                w.ppre2()
                    .variant(ppre2_bits)
                    .ppre1()
                    .variant(ppre1_bits)
                    .hpre()
                    .variant(hpre_bits)
                    .sw()
                    .variant(sysclk_source)
            });
            Clocks {
                hclk: Hertz(hclk),
                pclk1: Hertz(pclk1),
                pclk2: Hertz(pclk2),
                ppre1,
                ppre2,
                sysclk: Hertz(sysclk),
                usbclk_valid,
            }
        }
    }
    #[doc = " Frozen clock frequencies"]
    #[doc = ""]
    #[doc = " The existence of this value indicates that the clock configuration can no longer be changed."]
    #[doc = " This struct can be obtained via the [freeze](CFGR::freeze) method of the [CFGR](CFGR) struct."]
    pub struct Clocks {
        hclk: Hertz,
        pclk1: Hertz,
        pclk2: Hertz,
        ppre1: u8,
        ppre2: u8,
        sysclk: Hertz,
        usbclk_valid: bool,
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::clone::Clone for Clocks {
        #[inline]
        fn clone(&self) -> Clocks {
            {
                let _: ::core::clone::AssertParamIsClone<Hertz>;
                let _: ::core::clone::AssertParamIsClone<Hertz>;
                let _: ::core::clone::AssertParamIsClone<Hertz>;
                let _: ::core::clone::AssertParamIsClone<u8>;
                let _: ::core::clone::AssertParamIsClone<u8>;
                let _: ::core::clone::AssertParamIsClone<Hertz>;
                let _: ::core::clone::AssertParamIsClone<bool>;
                *self
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::marker::Copy for Clocks {}
    impl Clocks {
        #[doc = " Returns the frequency of the AHB"]
        pub fn hclk(&self) -> Hertz {
            self.hclk
        }
        #[doc = " Returns the frequency of the APB1"]
        pub fn pclk1(&self) -> Hertz {
            self.pclk1
        }
        #[doc = " Returns the frequency of the APB2"]
        pub fn pclk2(&self) -> Hertz {
            self.pclk2
        }
        pub(crate) fn ppre1(&self) -> u8 {
            self.ppre1
        }
        #[allow(dead_code)]
        pub(crate) fn ppre2(&self) -> u8 {
            self.ppre2
        }
        #[doc = " Returns the system (core) frequency"]
        pub fn sysclk(&self) -> Hertz {
            self.sysclk
        }
        #[doc = " Returns whether the USBCLK clock frequency is valid for the USB peripheral"]
        #[doc = ""]
        #[doc = " If the microcontroller does support USB, 48 Mhz or 72 Mhz have to be used"]
        #[doc = " and the [`CFGR::hse`] must be used."]
        #[doc = ""]
        #[doc = " The APB1 / [`CFGR::pclk1`] clock must have a minimum frequency of 10 MHz to avoid data"]
        #[doc = " overrun/underrun problems. [RM0316 32.5.2][RM0316]"]
        #[doc = ""]
        #[doc = " [RM0316]: https://www.st.com/resource/en/reference_manual/dm00043574.pdf"]
        pub fn usbclk_valid(&self) -> bool {
            self.usbclk_valid
        }
    }
}
pub mod rtc {
    #![doc = " Real Time Clock"]
    #![doc = ""]
    #![doc = " Interface to the real time clock. See STM32F303 reference manual, section 27."]
    #![doc = " For more details, see [ST AN4759][]."]
    #![doc = ""]
    #![doc = " [ST AN4759]: https:/www.st.com%2Fresource%2Fen%2Fapplication_note%2Fdm00226326-using-the-hardware-realtime-clock-rtc-and-the-tamper-management-unit-tamp-with-stm32-microcontrollers-stmicroelectronics.pdf&usg=AOvVaw3PzvL2TfYtwS32fw-Uv37h"]
    use crate::pac::{PWR, RTC};
    use crate::rcc::{APB1, BDCR};
    use core::convert::TryInto;
    use rtcc::{Datelike, Hours, NaiveDate, NaiveDateTime, NaiveTime, Rtcc, Timelike};
    #[doc = " RTC error type"]
    pub enum Error {
        #[doc = " Invalid input error"]
        InvalidInputData,
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::fmt::Debug for Error {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            match (&*self,) {
                (&Error::InvalidInputData,) => {
                    let mut debug_trait_builder = f.debug_tuple("InvalidInputData");
                    debug_trait_builder.finish()
                }
            }
        }
    }
    #[doc = " Real Time Clock peripheral"]
    pub struct Rtc {
        #[doc = " RTC Peripheral register definition"]
        pub regs: RTC,
    }
    impl Rtc {
        #[doc = " Create and enable a new RTC, and configure its clock source and prescalers."]
        #[doc = " From AN4759, Table 7, when using the LSE (The only clock source this module"]
        #[doc = " supports currently), set `prediv_s` to 255, and `prediv_a` to 127 to get a"]
        #[doc = " calendar clock of 1Hz."]
        #[doc = " The `bypass` argument is `true` if you're using an external oscillator that"]
        #[doc = " doesn't connect to `OSC32_IN`, such as a MEMS resonator."]
        pub fn new(
            regs: RTC,
            prediv_s: u16,
            prediv_a: u8,
            bypass: bool,
            apb1: &mut APB1,
            bdcr: &mut BDCR,
            pwr: &mut PWR,
        ) -> Self {
            let mut result = Self { regs };
            enable_lse(bdcr, bypass);
            unlock(apb1, pwr);
            enable(bdcr);
            result.set_24h_fmt();
            result.regs.prer.modify(|_, w| {
                w.prediv_s().bits(prediv_s);
                w.prediv_a().bits(prediv_a)
            });
            result
        }
        #[doc = " Sets calendar clock to 24 hr format"]
        pub fn set_24h_fmt(&mut self) {
            self.regs.cr.modify(|_, w| w.fmt().set_bit());
        }
        #[doc = " Sets calendar clock to 12 hr format"]
        pub fn set_12h_fmt(&mut self) {
            self.regs.cr.modify(|_, w| w.fmt().clear_bit());
        }
        #[doc = " Reads current hour format selection"]
        pub fn is_24h_fmt(&self) -> bool {
            self.regs.cr.read().fmt().bit()
        }
        #[doc = " As described in Section 27.3.7 in RM0316,"]
        #[doc = " this function is used to disable write protection"]
        #[doc = " when modifying an RTC register"]
        fn modify<F>(&mut self, mut closure: F)
        where
            F: FnMut(&mut RTC),
        {
            self.regs.wpr.write(|w| unsafe { w.bits(0xCA) });
            self.regs.wpr.write(|w| unsafe { w.bits(0x53) });
            let isr = self.regs.isr.read();
            if isr.initf().bit_is_clear() {
                self.regs.isr.modify(|_, w| w.init().set_bit());
                while self.regs.isr.read().initf().bit_is_clear() {}
            }
            closure(&mut self.regs);
            self.regs.isr.modify(|_, w| w.init().clear_bit());
            while !self.regs.isr.read().initf().bit_is_clear() {}
        }
    }
    impl Rtcc for Rtc {
        type Error = Error;
        #[doc = " set time using NaiveTime (ISO 8601 time without timezone)"]
        #[doc = " Hour format is 24h"]
        fn set_time(&mut self, time: &NaiveTime) -> Result<(), Self::Error> {
            self.set_24h_fmt();
            let (ht, hu) = bcd2_encode(time.hour())?;
            let (mnt, mnu) = bcd2_encode(time.minute())?;
            let (st, su) = bcd2_encode(time.second())?;
            self.regs.tr.write(|w| {
                w.ht().bits(ht);
                w.hu().bits(hu);
                w.mnt().bits(mnt);
                w.mnu().bits(mnu);
                w.st().bits(st);
                w.su().bits(su);
                w.pm().clear_bit()
            });
            Ok(())
        }
        fn set_seconds(&mut self, seconds: u8) -> Result<(), Self::Error> {
            if seconds > 59 {
                return Err(Error::InvalidInputData);
            }
            let (st, su) = bcd2_encode(seconds as u32)?;
            self.modify(|regs| regs.tr.modify(|_, w| w.st().bits(st).su().bits(su)));
            Ok(())
        }
        fn set_minutes(&mut self, minutes: u8) -> Result<(), Self::Error> {
            if minutes > 59 {
                return Err(Error::InvalidInputData);
            }
            let (mnt, mnu) = bcd2_encode(minutes as u32)?;
            self.modify(|regs| regs.tr.modify(|_, w| w.mnt().bits(mnt).mnu().bits(mnu)));
            Ok(())
        }
        fn set_hours(&mut self, hours: Hours) -> Result<(), Self::Error> {
            let (ht, hu) = hours_to_register(hours)?;
            match hours {
                Hours::H24(_h) => self.set_24h_fmt(),
                Hours::AM(_h) | Hours::PM(_h) => self.set_12h_fmt(),
            }
            self.regs.tr.modify(|_, w| w.ht().bits(ht).hu().bits(hu));
            Ok(())
        }
        fn set_weekday(&mut self, weekday: u8) -> Result<(), Self::Error> {
            if !(1..=7).contains(&weekday) {
                return Err(Error::InvalidInputData);
            }
            self.modify(|regs| regs.dr.modify(|_, w| unsafe { w.wdu().bits(weekday) }));
            Ok(())
        }
        fn set_day(&mut self, day: u8) -> Result<(), Self::Error> {
            if !(1..=31).contains(&day) {
                return Err(Error::InvalidInputData);
            }
            let (dt, du) = bcd2_encode(day as u32)?;
            self.modify(|regs| regs.dr.modify(|_, w| w.dt().bits(dt).du().bits(du)));
            Ok(())
        }
        fn set_month(&mut self, month: u8) -> Result<(), Self::Error> {
            if !(1..=12).contains(&month) {
                return Err(Error::InvalidInputData);
            }
            let (mt, mu) = bcd2_encode(month as u32)?;
            self.modify(|regs| regs.dr.modify(|_, w| w.mt().bit(mt > 0).mu().bits(mu)));
            Ok(())
        }
        fn set_year(&mut self, year: u16) -> Result<(), Self::Error> {
            if !(1970..=2038).contains(&year) {
                return Err(Error::InvalidInputData);
            }
            let (yt, yu) = bcd2_encode(year as u32)?;
            self.modify(|regs| regs.dr.modify(|_, w| w.yt().bits(yt).yu().bits(yu)));
            Ok(())
        }
        #[doc = " Set the date using NaiveDate (ISO 8601 calendar date without timezone)."]
        #[doc = " WeekDay is set using the `set_weekday` method"]
        fn set_date(&mut self, date: &NaiveDate) -> Result<(), Self::Error> {
            if date.year() < 1970 {
                return Err(Error::InvalidInputData);
            }
            let (yt, yu) = bcd2_encode((date.year() - 1970) as u32)?;
            let (mt, mu) = bcd2_encode(date.month())?;
            let (dt, du) = bcd2_encode(date.day())?;
            self.regs.dr.write(|w| {
                w.dt().bits(dt);
                w.du().bits(du);
                w.mt().bit(mt > 0);
                w.mu().bits(mu);
                w.yt().bits(yt);
                w.yu().bits(yu)
            });
            Ok(())
        }
        fn set_datetime(&mut self, date: &NaiveDateTime) -> Result<(), Self::Error> {
            if date.year() < 1970 {
                return Err(Error::InvalidInputData);
            }
            self.set_24h_fmt();
            let (yt, yu) = bcd2_encode((date.year() - 1970) as u32)?;
            let (mt, mu) = bcd2_encode(date.month())?;
            let (dt, du) = bcd2_encode(date.day())?;
            let (ht, hu) = bcd2_encode(date.hour())?;
            let (mnt, mnu) = bcd2_encode(date.minute())?;
            let (st, su) = bcd2_encode(date.second())?;
            self.regs.dr.write(|w| {
                w.dt().bits(dt);
                w.du().bits(du);
                w.mt().bit(mt > 0);
                w.mu().bits(mu);
                w.yt().bits(yt);
                w.yu().bits(yu)
            });
            self.regs.tr.write(|w| {
                w.ht().bits(ht);
                w.hu().bits(hu);
                w.mnt().bits(mnt);
                w.mnu().bits(mnu);
                w.st().bits(st);
                w.su().bits(su);
                w.pm().clear_bit()
            });
            Ok(())
        }
        fn get_seconds(&mut self) -> Result<u8, Self::Error> {
            let tr = self.regs.tr.read();
            let seconds = bcd2_decode(tr.st().bits(), tr.su().bits());
            Ok(seconds as u8)
        }
        fn get_minutes(&mut self) -> Result<u8, Self::Error> {
            let tr = self.regs.tr.read();
            let minutes = bcd2_decode(tr.mnt().bits(), tr.mnu().bits());
            Ok(minutes as u8)
        }
        fn get_hours(&mut self) -> Result<Hours, Self::Error> {
            let tr = self.regs.tr.read();
            let hours = bcd2_decode(tr.ht().bits(), tr.hu().bits());
            if self.is_24h_fmt() {
                return Ok(Hours::H24(hours as u8));
            }
            if !tr.pm().bit() {
                return Ok(Hours::AM(hours as u8));
            }
            Ok(Hours::PM(hours as u8))
        }
        fn get_time(&mut self) -> Result<NaiveTime, Self::Error> {
            self.set_24h_fmt();
            let seconds = self.get_seconds()?;
            let minutes = self.get_minutes()?;
            let hours = hours_to_u8(self.get_hours()?)?;
            Ok(NaiveTime::from_hms(
                hours.into(),
                minutes.into(),
                seconds.into(),
            ))
        }
        fn get_weekday(&mut self) -> Result<u8, Self::Error> {
            let dr = self.regs.dr.read();
            let weekday = bcd2_decode(dr.wdu().bits(), 0x00);
            Ok(weekday as u8)
        }
        fn get_day(&mut self) -> Result<u8, Self::Error> {
            let dr = self.regs.dr.read();
            let day = bcd2_decode(dr.dt().bits(), dr.du().bits());
            Ok(day as u8)
        }
        fn get_month(&mut self) -> Result<u8, Self::Error> {
            let dr = self.regs.dr.read();
            let mt: u8 = if dr.mt().bit() { 1 } else { 0 };
            let month = bcd2_decode(mt, dr.mu().bits());
            Ok(month as u8)
        }
        fn get_year(&mut self) -> Result<u16, Self::Error> {
            let dr = self.regs.dr.read();
            let year = bcd2_decode(dr.yt().bits(), dr.yu().bits());
            Ok(year as u16)
        }
        fn get_date(&mut self) -> Result<NaiveDate, Self::Error> {
            let day = self.get_day()?;
            let month = self.get_month()?;
            let year = self.get_year()?;
            Ok(NaiveDate::from_ymd(year.into(), month.into(), day.into()))
        }
        fn get_datetime(&mut self) -> Result<NaiveDateTime, Self::Error> {
            self.set_24h_fmt();
            let day = self.get_day()?;
            let month = self.get_month()?;
            let year = self.get_year()?;
            let seconds = self.get_seconds()?;
            let minutes = self.get_minutes()?;
            let hours = hours_to_u8(self.get_hours()?)?;
            Ok(
                NaiveDate::from_ymd(year.into(), month.into(), day.into()).and_hms(
                    hours.into(),
                    minutes.into(),
                    seconds.into(),
                ),
            )
        }
    }
    fn bcd2_encode(word: u32) -> Result<(u8, u8), Error> {
        let l = match (word / 10).try_into() {
            Ok(v) => v,
            Err(_) => {
                return Err(Error::InvalidInputData);
            }
        };
        let r = match (word % 10).try_into() {
            Ok(v) => v,
            Err(_) => {
                return Err(Error::InvalidInputData);
            }
        };
        Ok((l, r))
    }
    fn bcd2_decode(fst: u8, snd: u8) -> u32 {
        (fst * 10 + snd).into()
    }
    fn hours_to_register(hours: Hours) -> Result<(u8, u8), Error> {
        match hours {
            Hours::H24(h) => Ok(bcd2_encode(h as u32))?,
            Hours::AM(h) => Ok(bcd2_encode((h - 1) as u32))?,
            Hours::PM(h) => Ok(bcd2_encode((h + 11) as u32))?,
        }
    }
    fn hours_to_u8(hours: Hours) -> Result<u8, Error> {
        if let Hours::H24(h) = hours {
            Ok(h)
        } else {
            Err(Error::InvalidInputData)
        }
    }
    #[doc = " Enable the low frequency external oscillator. This is the only mode currently"]
    #[doc = " supported, to avoid exposing the `CR` and `CRS` registers."]
    fn enable_lse(bdcr: &mut BDCR, bypass: bool) {
        bdcr.bdcr()
            .modify(|_, w| w.lseon().set_bit().lsebyp().bit(bypass));
        while bdcr.bdcr().read().lserdy().bit_is_clear() {}
    }
    fn unlock(apb1: &mut APB1, pwr: &mut PWR) {
        apb1.enr().modify(|_, w| w.pwren().set_bit());
        pwr.cr.modify(|_, w| w.dbp().set_bit());
        while pwr.cr.read().dbp().bit_is_clear() {}
    }
    fn enable(bdcr: &mut BDCR) {
        bdcr.bdcr().modify(|_, w| w.bdrst().enabled());
        bdcr.bdcr().modify(|_, w| {
            w.rtcsel().lse();
            w.rtcen().enabled();
            w.bdrst().disabled()
        });
    }
}
pub mod serial {
    #![doc = " Serial"]
    use crate::{
        gpio::{gpioa, gpiob, gpioc, AF7},
        hal::{blocking, serial},
        pac::{USART1, USART2, USART3},
        rcc::{Clocks, APB1, APB2},
        time::Bps,
    };
    use cfg_if::cfg_if;
    use core::{convert::Infallible, marker::PhantomData, ptr};
    use crate::dma;
    use cortex_m::interrupt;
    #[doc = " Interrupt event"]
    pub enum Event {
        #[doc = " New data has been received"]
        Rxne,
        #[doc = " New data can be sent"]
        Txe,
    }
    #[doc = " Serial error"]
    #[non_exhaustive]
    pub enum Error {
        #[doc = " Framing error"]
        Framing,
        #[doc = " Noise error"]
        Noise,
        #[doc = " RX buffer overrun"]
        Overrun,
        #[doc = " Parity check error"]
        Parity,
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::fmt::Debug for Error {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            match (&*self,) {
                (&Error::Framing,) => {
                    let mut debug_trait_builder = f.debug_tuple("Framing");
                    debug_trait_builder.finish()
                }
                (&Error::Noise,) => {
                    let mut debug_trait_builder = f.debug_tuple("Noise");
                    debug_trait_builder.finish()
                }
                (&Error::Overrun,) => {
                    let mut debug_trait_builder = f.debug_tuple("Overrun");
                    debug_trait_builder.finish()
                }
                (&Error::Parity,) => {
                    let mut debug_trait_builder = f.debug_tuple("Parity");
                    debug_trait_builder.finish()
                }
            }
        }
    }
    #[doc = " TX pin - DO NOT IMPLEMENT THIS TRAIT"]
    pub unsafe trait TxPin<USART> {}
    #[doc = " RX pin - DO NOT IMPLEMENT THIS TRAIT"]
    pub unsafe trait RxPin<USART> {}
    unsafe impl TxPin<USART1> for gpioa::PA9<AF7> {}
    unsafe impl TxPin<USART1> for gpiob::PB6<AF7> {}
    unsafe impl TxPin<USART1> for gpioc::PC4<AF7> {}
    unsafe impl RxPin<USART1> for gpioa::PA10<AF7> {}
    unsafe impl RxPin<USART1> for gpiob::PB7<AF7> {}
    unsafe impl RxPin<USART1> for gpioc::PC5<AF7> {}
    unsafe impl TxPin<USART2> for gpioa::PA2<AF7> {}
    unsafe impl TxPin<USART2> for gpiob::PB3<AF7> {}
    unsafe impl RxPin<USART2> for gpioa::PA3<AF7> {}
    unsafe impl RxPin<USART2> for gpiob::PB4<AF7> {}
    unsafe impl TxPin<USART3> for gpiob::PB10<AF7> {}
    unsafe impl TxPin<USART3> for gpioc::PC10<AF7> {}
    unsafe impl RxPin<USART3> for gpioc::PC11<AF7> {}
    use crate::gpio::{gpiod, gpioe};
    unsafe impl TxPin<USART1> for gpioe::PE0<AF7> {}
    unsafe impl RxPin<USART1> for gpioe::PE1<AF7> {}
    unsafe impl TxPin<USART2> for gpiod::PD5<AF7> {}
    unsafe impl RxPin<USART2> for gpiod::PD6<AF7> {}
    unsafe impl TxPin<USART3> for gpiod::PD8<AF7> {}
    unsafe impl RxPin<USART3> for gpiod::PD9<AF7> {}
    unsafe impl RxPin<USART3> for gpioe::PE15<AF7> {}
    unsafe impl TxPin<USART2> for gpioa::PA14<AF7> {}
    unsafe impl RxPin<USART2> for gpioa::PA15<AF7> {}
    unsafe impl RxPin<USART3> for gpiob::PB11<AF7> {}
    #[doc = " Serial abstraction"]
    pub struct Serial<USART, PINS> {
        usart: USART,
        pins: PINS,
    }
    #[doc = " Serial receiver"]
    pub struct Rx<USART> {
        _usart: PhantomData<USART>,
    }
    #[doc = " Serial transmitter"]
    pub struct Tx<USART> {
        _usart: PhantomData<USART>,
    }
    impl<TX, RX> Serial<USART1, (TX, RX)> {
        #[doc = " Configures a USART peripheral to provide serial communication"]
        pub fn usart1(
            usart: USART1,
            pins: (TX, RX),
            baud_rate: Bps,
            clocks: Clocks,
            apb: &mut APB2,
        ) -> Self
        where
            TX: TxPin<USART1>,
            RX: RxPin<USART1>,
        {
            apb.enr().modify(|_, w| w.usart1en().set_bit());
            apb.rstr().modify(|_, w| w.usart1rst().set_bit());
            apb.rstr().modify(|_, w| w.usart1rst().clear_bit());
            let brr = clocks.pclk2().0 / baud_rate.0;
            if !(brr >= 16) {
                ::core::panicking::panic("impossible baud rate")
            };
            usart.brr.write(|w| unsafe { w.bits(brr) });
            usart.cr1.modify(|_, w| {
                w.ue().enabled();
                w.re().enabled();
                w.te().enabled()
            });
            Serial { usart, pins }
        }
        #[doc = " Starts listening for an interrupt event"]
        pub fn listen(&mut self, event: Event) {
            match event {
                Event::Rxne => self.usart.cr1.modify(|_, w| w.rxneie().set_bit()),
                Event::Txe => self.usart.cr1.modify(|_, w| w.txeie().set_bit()),
            }
        }
        #[doc = " Starts listening for an interrupt event"]
        pub fn unlisten(&mut self, event: Event) {
            match event {
                Event::Rxne => self.usart.cr1.modify(|_, w| w.rxneie().clear_bit()),
                Event::Txe => self.usart.cr1.modify(|_, w| w.txeie().clear_bit()),
            }
        }
        #[doc = " Splits the `Serial` abstraction into a transmitter and a receiver half"]
        pub fn split(self) -> (Tx<USART1>, Rx<USART1>) {
            (
                Tx {
                    _usart: PhantomData,
                },
                Rx {
                    _usart: PhantomData,
                },
            )
        }
        #[doc = " Releases the USART peripheral and associated pins"]
        pub fn free(self) -> (USART1, (TX, RX)) {
            (self.usart, self.pins)
        }
    }
    impl serial::Read<u8> for Rx<USART1> {
        type Error = Error;
        fn read(&mut self) -> nb::Result<u8, Error> {
            let isr = unsafe { (*USART1::ptr()).isr.read() };
            let icr = unsafe { &(*USART1::ptr()).icr };
            Err(if isr.pe().bit_is_set() {
                icr.write(|w| w.pecf().clear());
                nb::Error::Other(Error::Parity)
            } else if isr.fe().bit_is_set() {
                icr.write(|w| w.fecf().clear());
                nb::Error::Other(Error::Framing)
            } else if isr.nf().bit_is_set() {
                icr.write(|w| w.ncf().clear());
                nb::Error::Other(Error::Noise)
            } else if isr.ore().bit_is_set() {
                icr.write(|w| w.orecf().clear());
                nb::Error::Other(Error::Overrun)
            } else if isr.rxne().bit_is_set() {
                return Ok(unsafe {
                    ptr::read_volatile(&(*USART1::ptr()).rdr as *const _ as *const _)
                });
            } else {
                nb::Error::WouldBlock
            })
        }
    }
    impl serial::Write<u8> for Tx<USART1> {
        type Error = Infallible;
        fn flush(&mut self) -> nb::Result<(), Infallible> {
            let isr = unsafe { (*USART1::ptr()).isr.read() };
            if isr.tc().bit_is_set() {
                Ok(())
            } else {
                Err(nb::Error::WouldBlock)
            }
        }
        fn write(&mut self, byte: u8) -> nb::Result<(), Infallible> {
            let isr = unsafe { (*USART1::ptr()).isr.read() };
            if isr.txe().bit_is_set() {
                unsafe { ptr::write_volatile(&(*USART1::ptr()).tdr as *const _ as *mut _, byte) }
                Ok(())
            } else {
                Err(nb::Error::WouldBlock)
            }
        }
    }
    impl blocking::serial::write::Default<u8> for Tx<USART1> {}
    #[cfg(any(feature = "stm32f302", feature = "stm32f303"))]
    impl Rx<USART1> {
        #[doc = " Fill the buffer with received data using DMA."]
        pub fn read_exact<B, C>(self, buffer: B, mut channel: C) -> dma::Transfer<B, C, Self>
        where
            Self: dma::OnChannel<C>,
            B: dma::WriteBuffer<Word = u8> + 'static,
            C: dma::Channel,
        {
            let pa = unsafe { &(*USART1::ptr()).rdr } as *const _ as u32;
            unsafe { channel.set_peripheral_address(pa, dma::Increment::Disable) };
            dma::Transfer::start_write(buffer, channel, self)
        }
    }
    #[cfg(any(feature = "stm32f302", feature = "stm32f303"))]
    impl Tx<USART1> {
        #[doc = " Transmit all data in the buffer using DMA."]
        pub fn write_all<B, C>(self, buffer: B, mut channel: C) -> dma::Transfer<B, C, Self>
        where
            Self: dma::OnChannel<C>,
            B: dma::ReadBuffer<Word = u8> + 'static,
            C: dma::Channel,
        {
            let pa = unsafe { &(*USART1::ptr()).tdr } as *const _ as u32;
            unsafe { channel.set_peripheral_address(pa, dma::Increment::Disable) };
            dma::Transfer::start_read(buffer, channel, self)
        }
    }
    #[cfg(any(feature = "stm32f302", feature = "stm32f303"))]
    impl dma::Target for Rx<USART1> {
        fn enable_dma(&mut self) {
            interrupt::free(|_| unsafe {
                let cr3 = &(*USART1::ptr()).cr3;
                cr3.modify(|_, w| w.dmar().enabled());
            });
        }
        fn disable_dma(&mut self) {
            interrupt::free(|_| unsafe {
                let cr3 = &(*USART1::ptr()).cr3;
                cr3.modify(|_, w| w.dmar().disabled());
            });
        }
    }
    #[cfg(any(feature = "stm32f302", feature = "stm32f303"))]
    impl dma::Target for Tx<USART1> {
        fn enable_dma(&mut self) {
            interrupt::free(|_| unsafe {
                let cr3 = &(*USART1::ptr()).cr3;
                cr3.modify(|_, w| w.dmat().enabled());
            });
        }
        fn disable_dma(&mut self) {
            interrupt::free(|_| unsafe {
                let cr3 = &(*USART1::ptr()).cr3;
                cr3.modify(|_, w| w.dmat().disabled());
            });
        }
    }
    impl<TX, RX> Serial<USART2, (TX, RX)> {
        #[doc = " Configures a USART peripheral to provide serial communication"]
        pub fn usart2(
            usart: USART2,
            pins: (TX, RX),
            baud_rate: Bps,
            clocks: Clocks,
            apb: &mut APB1,
        ) -> Self
        where
            TX: TxPin<USART2>,
            RX: RxPin<USART2>,
        {
            apb.enr().modify(|_, w| w.usart2en().set_bit());
            apb.rstr().modify(|_, w| w.usart2rst().set_bit());
            apb.rstr().modify(|_, w| w.usart2rst().clear_bit());
            let brr = clocks.pclk1().0 / baud_rate.0;
            if !(brr >= 16) {
                ::core::panicking::panic("impossible baud rate")
            };
            usart.brr.write(|w| unsafe { w.bits(brr) });
            usart.cr1.modify(|_, w| {
                w.ue().enabled();
                w.re().enabled();
                w.te().enabled()
            });
            Serial { usart, pins }
        }
        #[doc = " Starts listening for an interrupt event"]
        pub fn listen(&mut self, event: Event) {
            match event {
                Event::Rxne => self.usart.cr1.modify(|_, w| w.rxneie().set_bit()),
                Event::Txe => self.usart.cr1.modify(|_, w| w.txeie().set_bit()),
            }
        }
        #[doc = " Starts listening for an interrupt event"]
        pub fn unlisten(&mut self, event: Event) {
            match event {
                Event::Rxne => self.usart.cr1.modify(|_, w| w.rxneie().clear_bit()),
                Event::Txe => self.usart.cr1.modify(|_, w| w.txeie().clear_bit()),
            }
        }
        #[doc = " Splits the `Serial` abstraction into a transmitter and a receiver half"]
        pub fn split(self) -> (Tx<USART2>, Rx<USART2>) {
            (
                Tx {
                    _usart: PhantomData,
                },
                Rx {
                    _usart: PhantomData,
                },
            )
        }
        #[doc = " Releases the USART peripheral and associated pins"]
        pub fn free(self) -> (USART2, (TX, RX)) {
            (self.usart, self.pins)
        }
    }
    impl serial::Read<u8> for Rx<USART2> {
        type Error = Error;
        fn read(&mut self) -> nb::Result<u8, Error> {
            let isr = unsafe { (*USART2::ptr()).isr.read() };
            let icr = unsafe { &(*USART2::ptr()).icr };
            Err(if isr.pe().bit_is_set() {
                icr.write(|w| w.pecf().clear());
                nb::Error::Other(Error::Parity)
            } else if isr.fe().bit_is_set() {
                icr.write(|w| w.fecf().clear());
                nb::Error::Other(Error::Framing)
            } else if isr.nf().bit_is_set() {
                icr.write(|w| w.ncf().clear());
                nb::Error::Other(Error::Noise)
            } else if isr.ore().bit_is_set() {
                icr.write(|w| w.orecf().clear());
                nb::Error::Other(Error::Overrun)
            } else if isr.rxne().bit_is_set() {
                return Ok(unsafe {
                    ptr::read_volatile(&(*USART2::ptr()).rdr as *const _ as *const _)
                });
            } else {
                nb::Error::WouldBlock
            })
        }
    }
    impl serial::Write<u8> for Tx<USART2> {
        type Error = Infallible;
        fn flush(&mut self) -> nb::Result<(), Infallible> {
            let isr = unsafe { (*USART2::ptr()).isr.read() };
            if isr.tc().bit_is_set() {
                Ok(())
            } else {
                Err(nb::Error::WouldBlock)
            }
        }
        fn write(&mut self, byte: u8) -> nb::Result<(), Infallible> {
            let isr = unsafe { (*USART2::ptr()).isr.read() };
            if isr.txe().bit_is_set() {
                unsafe { ptr::write_volatile(&(*USART2::ptr()).tdr as *const _ as *mut _, byte) }
                Ok(())
            } else {
                Err(nb::Error::WouldBlock)
            }
        }
    }
    impl blocking::serial::write::Default<u8> for Tx<USART2> {}
    #[cfg(any(feature = "stm32f302", feature = "stm32f303"))]
    impl Rx<USART2> {
        #[doc = " Fill the buffer with received data using DMA."]
        pub fn read_exact<B, C>(self, buffer: B, mut channel: C) -> dma::Transfer<B, C, Self>
        where
            Self: dma::OnChannel<C>,
            B: dma::WriteBuffer<Word = u8> + 'static,
            C: dma::Channel,
        {
            let pa = unsafe { &(*USART2::ptr()).rdr } as *const _ as u32;
            unsafe { channel.set_peripheral_address(pa, dma::Increment::Disable) };
            dma::Transfer::start_write(buffer, channel, self)
        }
    }
    #[cfg(any(feature = "stm32f302", feature = "stm32f303"))]
    impl Tx<USART2> {
        #[doc = " Transmit all data in the buffer using DMA."]
        pub fn write_all<B, C>(self, buffer: B, mut channel: C) -> dma::Transfer<B, C, Self>
        where
            Self: dma::OnChannel<C>,
            B: dma::ReadBuffer<Word = u8> + 'static,
            C: dma::Channel,
        {
            let pa = unsafe { &(*USART2::ptr()).tdr } as *const _ as u32;
            unsafe { channel.set_peripheral_address(pa, dma::Increment::Disable) };
            dma::Transfer::start_read(buffer, channel, self)
        }
    }
    #[cfg(any(feature = "stm32f302", feature = "stm32f303"))]
    impl dma::Target for Rx<USART2> {
        fn enable_dma(&mut self) {
            interrupt::free(|_| unsafe {
                let cr3 = &(*USART2::ptr()).cr3;
                cr3.modify(|_, w| w.dmar().enabled());
            });
        }
        fn disable_dma(&mut self) {
            interrupt::free(|_| unsafe {
                let cr3 = &(*USART2::ptr()).cr3;
                cr3.modify(|_, w| w.dmar().disabled());
            });
        }
    }
    #[cfg(any(feature = "stm32f302", feature = "stm32f303"))]
    impl dma::Target for Tx<USART2> {
        fn enable_dma(&mut self) {
            interrupt::free(|_| unsafe {
                let cr3 = &(*USART2::ptr()).cr3;
                cr3.modify(|_, w| w.dmat().enabled());
            });
        }
        fn disable_dma(&mut self) {
            interrupt::free(|_| unsafe {
                let cr3 = &(*USART2::ptr()).cr3;
                cr3.modify(|_, w| w.dmat().disabled());
            });
        }
    }
    impl<TX, RX> Serial<USART3, (TX, RX)> {
        #[doc = " Configures a USART peripheral to provide serial communication"]
        pub fn usart3(
            usart: USART3,
            pins: (TX, RX),
            baud_rate: Bps,
            clocks: Clocks,
            apb: &mut APB1,
        ) -> Self
        where
            TX: TxPin<USART3>,
            RX: RxPin<USART3>,
        {
            apb.enr().modify(|_, w| w.usart3en().set_bit());
            apb.rstr().modify(|_, w| w.usart3rst().set_bit());
            apb.rstr().modify(|_, w| w.usart3rst().clear_bit());
            let brr = clocks.pclk1().0 / baud_rate.0;
            if !(brr >= 16) {
                ::core::panicking::panic("impossible baud rate")
            };
            usart.brr.write(|w| unsafe { w.bits(brr) });
            usart.cr1.modify(|_, w| {
                w.ue().enabled();
                w.re().enabled();
                w.te().enabled()
            });
            Serial { usart, pins }
        }
        #[doc = " Starts listening for an interrupt event"]
        pub fn listen(&mut self, event: Event) {
            match event {
                Event::Rxne => self.usart.cr1.modify(|_, w| w.rxneie().set_bit()),
                Event::Txe => self.usart.cr1.modify(|_, w| w.txeie().set_bit()),
            }
        }
        #[doc = " Starts listening for an interrupt event"]
        pub fn unlisten(&mut self, event: Event) {
            match event {
                Event::Rxne => self.usart.cr1.modify(|_, w| w.rxneie().clear_bit()),
                Event::Txe => self.usart.cr1.modify(|_, w| w.txeie().clear_bit()),
            }
        }
        #[doc = " Splits the `Serial` abstraction into a transmitter and a receiver half"]
        pub fn split(self) -> (Tx<USART3>, Rx<USART3>) {
            (
                Tx {
                    _usart: PhantomData,
                },
                Rx {
                    _usart: PhantomData,
                },
            )
        }
        #[doc = " Releases the USART peripheral and associated pins"]
        pub fn free(self) -> (USART3, (TX, RX)) {
            (self.usart, self.pins)
        }
    }
    impl serial::Read<u8> for Rx<USART3> {
        type Error = Error;
        fn read(&mut self) -> nb::Result<u8, Error> {
            let isr = unsafe { (*USART3::ptr()).isr.read() };
            let icr = unsafe { &(*USART3::ptr()).icr };
            Err(if isr.pe().bit_is_set() {
                icr.write(|w| w.pecf().clear());
                nb::Error::Other(Error::Parity)
            } else if isr.fe().bit_is_set() {
                icr.write(|w| w.fecf().clear());
                nb::Error::Other(Error::Framing)
            } else if isr.nf().bit_is_set() {
                icr.write(|w| w.ncf().clear());
                nb::Error::Other(Error::Noise)
            } else if isr.ore().bit_is_set() {
                icr.write(|w| w.orecf().clear());
                nb::Error::Other(Error::Overrun)
            } else if isr.rxne().bit_is_set() {
                return Ok(unsafe {
                    ptr::read_volatile(&(*USART3::ptr()).rdr as *const _ as *const _)
                });
            } else {
                nb::Error::WouldBlock
            })
        }
    }
    impl serial::Write<u8> for Tx<USART3> {
        type Error = Infallible;
        fn flush(&mut self) -> nb::Result<(), Infallible> {
            let isr = unsafe { (*USART3::ptr()).isr.read() };
            if isr.tc().bit_is_set() {
                Ok(())
            } else {
                Err(nb::Error::WouldBlock)
            }
        }
        fn write(&mut self, byte: u8) -> nb::Result<(), Infallible> {
            let isr = unsafe { (*USART3::ptr()).isr.read() };
            if isr.txe().bit_is_set() {
                unsafe { ptr::write_volatile(&(*USART3::ptr()).tdr as *const _ as *mut _, byte) }
                Ok(())
            } else {
                Err(nb::Error::WouldBlock)
            }
        }
    }
    impl blocking::serial::write::Default<u8> for Tx<USART3> {}
    #[cfg(any(feature = "stm32f302", feature = "stm32f303"))]
    impl Rx<USART3> {
        #[doc = " Fill the buffer with received data using DMA."]
        pub fn read_exact<B, C>(self, buffer: B, mut channel: C) -> dma::Transfer<B, C, Self>
        where
            Self: dma::OnChannel<C>,
            B: dma::WriteBuffer<Word = u8> + 'static,
            C: dma::Channel,
        {
            let pa = unsafe { &(*USART3::ptr()).rdr } as *const _ as u32;
            unsafe { channel.set_peripheral_address(pa, dma::Increment::Disable) };
            dma::Transfer::start_write(buffer, channel, self)
        }
    }
    #[cfg(any(feature = "stm32f302", feature = "stm32f303"))]
    impl Tx<USART3> {
        #[doc = " Transmit all data in the buffer using DMA."]
        pub fn write_all<B, C>(self, buffer: B, mut channel: C) -> dma::Transfer<B, C, Self>
        where
            Self: dma::OnChannel<C>,
            B: dma::ReadBuffer<Word = u8> + 'static,
            C: dma::Channel,
        {
            let pa = unsafe { &(*USART3::ptr()).tdr } as *const _ as u32;
            unsafe { channel.set_peripheral_address(pa, dma::Increment::Disable) };
            dma::Transfer::start_read(buffer, channel, self)
        }
    }
    #[cfg(any(feature = "stm32f302", feature = "stm32f303"))]
    impl dma::Target for Rx<USART3> {
        fn enable_dma(&mut self) {
            interrupt::free(|_| unsafe {
                let cr3 = &(*USART3::ptr()).cr3;
                cr3.modify(|_, w| w.dmar().enabled());
            });
        }
        fn disable_dma(&mut self) {
            interrupt::free(|_| unsafe {
                let cr3 = &(*USART3::ptr()).cr3;
                cr3.modify(|_, w| w.dmar().disabled());
            });
        }
    }
    #[cfg(any(feature = "stm32f302", feature = "stm32f303"))]
    impl dma::Target for Tx<USART3> {
        fn enable_dma(&mut self) {
            interrupt::free(|_| unsafe {
                let cr3 = &(*USART3::ptr()).cr3;
                cr3.modify(|_, w| w.dmat().enabled());
            });
        }
        fn disable_dma(&mut self) {
            interrupt::free(|_| unsafe {
                let cr3 = &(*USART3::ptr()).cr3;
                cr3.modify(|_, w| w.dmat().disabled());
            });
        }
    }
}
pub mod spi {
    #![doc = " Serial Peripheral Interface (SPI) bus"]
    #![doc = ""]
    #![doc = " A usage example of the can peripheral can be found at [examples/spi.rs]"]
    #![doc = ""]
    #![doc = " [examples/spi.rs]: https://github.com/stm32-rs/stm32f3xx-hal/blob/v0.6.0/examples/spi.rs"]
    use core::ptr;
    use crate::hal::spi::FullDuplex;
    pub use crate::hal::spi::{Mode, Phase, Polarity};
    use crate::pac::{
        spi1::cr2::{DS_A, FRXTH_A},
        SPI1, SPI2, SPI3,
    };
    use crate::stm32::spi1;
    use crate::gpio::gpioa::{PA5, PA6, PA7};
    #[cfg(any(
        feature = "stm32f301",
        feature = "stm32f302",
        feature = "stm32f303",
        feature = "stm32f318",
        feature = "stm32f334",
        feature = "stm32f358",
        feature = "stm32f398"
    ))]
    use crate::gpio::gpiob::PB13;
    use crate::gpio::gpiob::{PB14, PB15, PB5};
    #[cfg(any(
        feature = "stm32f302",
        feature = "stm32f303",
        feature = "stm32f318",
        feature = "stm32f328",
        feature = "stm32f334",
        feature = "stm32f358",
        feature = "stm32f373",
        feature = "stm32f378",
        feature = "stm32f398",
    ))]
    use crate::gpio::gpiob::{PB3, PB4};
    use crate::gpio::gpioc::{PC10, PC11, PC12};
    #[cfg(any(
        feature = "stm32f302xb",
        feature = "stm32f302xc",
        feature = "stm32f302xd",
        feature = "stm32f302xe",
        feature = "stm32f303xb",
        feature = "stm32f303xc",
        feature = "stm32f303xd",
        feature = "stm32f303xe",
        feature = "stm32f358",
        feature = "stm32f398",
    ))]
    use crate::gpio::gpiof::{PF10, PF9};
    use crate::gpio::{AF5, AF6};
    use crate::rcc::Clocks;
    #[cfg(any(
        feature = "stm32f301",
        feature = "stm32f302",
        feature = "stm32f303xb",
        feature = "stm32f303xc",
        feature = "stm32f303xd",
        feature = "stm32f303xe",
        feature = "stm32f318",
        feature = "stm32f358",
        feature = "stm32f373",
        feature = "stm32f378",
        feature = "stm32f398"
    ))]
    use crate::rcc::APB1;
    #[cfg(any(
        feature = "stm32f302xb",
        feature = "stm32f302xc",
        feature = "stm32f302xd",
        feature = "stm32f302xe",
        feature = "stm32f303",
        feature = "stm32f328",
        feature = "stm32f334",
        feature = "stm32f358",
        feature = "stm32f373",
        feature = "stm32f378",
        feature = "stm32f398"
    ))]
    use crate::rcc::APB2;
    use crate::time::Hertz;
    use core::marker::PhantomData;
    #[doc = " SPI error"]
    #[non_exhaustive]
    pub enum Error {
        #[doc = " Overrun occurred"]
        Overrun,
        #[doc = " Mode fault occurred"]
        ModeFault,
        #[doc = " CRC error"]
        Crc,
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::fmt::Debug for Error {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            match (&*self,) {
                (&Error::Overrun,) => {
                    let mut debug_trait_builder = f.debug_tuple("Overrun");
                    debug_trait_builder.finish()
                }
                (&Error::ModeFault,) => {
                    let mut debug_trait_builder = f.debug_tuple("ModeFault");
                    debug_trait_builder.finish()
                }
                (&Error::Crc,) => {
                    let mut debug_trait_builder = f.debug_tuple("Crc");
                    debug_trait_builder.finish()
                }
            }
        }
    }
    #[doc = " SCK pin -- DO NOT IMPLEMENT THIS TRAIT"]
    pub unsafe trait SckPin<SPI> {}
    #[doc = " MISO pin -- DO NOT IMPLEMENT THIS TRAIT"]
    pub unsafe trait MisoPin<SPI> {}
    #[doc = " MOSI pin -- DO NOT IMPLEMENT THIS TRAIT"]
    pub unsafe trait MosiPin<SPI> {}
    unsafe impl SckPin<SPI1> for PA5<AF5> {}
    #[cfg(any(
        feature = "stm32f302xb",
        feature = "stm32f302xc",
        feature = "stm32f302xd",
        feature = "stm32f302xe",
        feature = "stm32f303",
        feature = "stm32f328",
        feature = "stm32f334",
        feature = "stm32f358",
        feature = "stm32f373",
        feature = "stm32f378",
        feature = "stm32f398",
    ))]
    unsafe impl SckPin<SPI1> for PB3<AF5> {}
    #[cfg(any(
        feature = "stm32f301",
        feature = "stm32f302",
        feature = "stm32f303",
        feature = "stm32f318",
        feature = "stm32f334",
        feature = "stm32f358",
        feature = "stm32f398"
    ))]
    unsafe impl SckPin<SPI2> for PB13<AF5> {}
    #[cfg(any(
        feature = "stm32f302xb",
        feature = "stm32f302xc",
        feature = "stm32f302xd",
        feature = "stm32f302xe",
        feature = "stm32f303xb",
        feature = "stm32f303xc",
        feature = "stm32f303xd",
        feature = "stm32f303xe",
        feature = "stm32f358",
        feature = "stm32f398",
    ))]
    unsafe impl SckPin<SPI2> for PF9<AF5> {}
    #[cfg(any(
        feature = "stm32f302xb",
        feature = "stm32f302xc",
        feature = "stm32f302xd",
        feature = "stm32f302xe",
        feature = "stm32f303xb",
        feature = "stm32f303xc",
        feature = "stm32f303xd",
        feature = "stm32f303xe",
        feature = "stm32f358",
        feature = "stm32f398",
    ))]
    unsafe impl SckPin<SPI2> for PF10<AF5> {}
    unsafe impl SckPin<SPI3> for PC10<AF6> {}
    unsafe impl MisoPin<SPI1> for PA6<AF5> {}
    #[cfg(any(
        feature = "stm32f302xb",
        feature = "stm32f302xc",
        feature = "stm32f302xd",
        feature = "stm32f302xe",
        feature = "stm32f303",
        feature = "stm32f328",
        feature = "stm32f334",
        feature = "stm32f358",
        feature = "stm32f373",
        feature = "stm32f378",
        feature = "stm32f398",
    ))]
    unsafe impl MisoPin<SPI1> for PB4<AF5> {}
    unsafe impl MisoPin<SPI2> for PB14<AF5> {}
    unsafe impl MisoPin<SPI3> for PC11<AF6> {}
    unsafe impl MosiPin<SPI1> for PA7<AF5> {}
    unsafe impl MosiPin<SPI1> for PB5<AF5> {}
    unsafe impl MosiPin<SPI2> for PB15<AF5> {}
    unsafe impl MosiPin<SPI3> for PB5<AF6> {}
    unsafe impl MosiPin<SPI3> for PC12<AF6> {}
    #[doc = " Configuration trait for the Word Size"]
    #[doc = " used by the SPI peripheral"]
    pub trait Word {
        #[doc = " Returns the register configuration"]
        #[doc = " to set the word size"]
        fn register_config() -> (FRXTH_A, DS_A);
    }
    impl Word for u8 {
        fn register_config() -> (FRXTH_A, DS_A) {
            (FRXTH_A::QUARTER, DS_A::EIGHTBIT)
        }
    }
    impl Word for u16 {
        fn register_config() -> (FRXTH_A, DS_A) {
            (FRXTH_A::HALF, DS_A::SIXTEENBIT)
        }
    }
    #[doc = " SPI peripheral operating in full duplex master mode"]
    pub struct Spi<SPI, PINS, WORD = u8> {
        spi: SPI,
        pins: PINS,
        _word: PhantomData<WORD>,
    }
    impl<SCK, MISO, MOSI, WORD> Spi<SPI1, (SCK, MISO, MOSI), WORD> {
        #[doc = " Configures the SPI peripheral to operate in full duplex master mode"]
        pub fn spi1<F>(
            spi: SPI1,
            pins: (SCK, MISO, MOSI),
            mode: Mode,
            freq: F,
            clocks: Clocks,
            apb2: &mut APB2,
        ) -> Self
        where
            F: Into<Hertz>,
            SCK: SckPin<SPI1>,
            MISO: MisoPin<SPI1>,
            MOSI: MosiPin<SPI1>,
            WORD: Word,
        {
            apb2.enr().modify(|_, w| w.spi1en().enabled());
            apb2.rstr().modify(|_, w| w.spi1rst().reset());
            apb2.rstr().modify(|_, w| w.spi1rst().clear_bit());
            let (frxth, ds) = WORD::register_config();
            spi.cr2.write(|w| {
                w.frxth().variant(frxth);
                w.ds().variant(ds);
                w.ssoe().disabled()
            });
            spi.cr1.write(|w| {
                w.mstr().master();
                match mode.phase {
                    Phase::CaptureOnFirstTransition => w.cpha().first_edge(),
                    Phase::CaptureOnSecondTransition => w.cpha().second_edge(),
                };
                match mode.polarity {
                    Polarity::IdleLow => w.cpol().idle_low(),
                    Polarity::IdleHigh => w.cpol().idle_high(),
                };
                w.br()
                    .variant(Self::compute_baud_rate(clocks.pclk2(), freq.into()));
                w.spe()
                    .enabled()
                    .lsbfirst()
                    .msbfirst()
                    .ssi()
                    .slave_not_selected()
                    .ssm()
                    .enabled()
                    .crcen()
                    .disabled()
                    .bidimode()
                    .unidirectional()
            });
            Spi {
                spi,
                pins,
                _word: PhantomData,
            }
        }
        #[doc = " Releases the SPI peripheral and associated pins"]
        pub fn free(self) -> (SPI1, (SCK, MISO, MOSI)) {
            (self.spi, self.pins)
        }
        #[doc = " Change the baud rate of the SPI"]
        pub fn reclock<F>(&mut self, freq: F, clocks: Clocks)
        where
            F: Into<Hertz>,
        {
            self.spi.cr1.modify(|_, w| w.spe().disabled());
            self.spi.cr1.modify(|_, w| {
                w.br()
                    .variant(Self::compute_baud_rate(clocks.pclk2(), freq.into()));
                w.spe().enabled()
            });
        }
        fn compute_baud_rate(clocks: Hertz, freq: Hertz) -> spi1::cr1::BR_A {
            use spi1::cr1::BR_A;
            match clocks.0 / freq.0 {
                0 => ::core::panicking::panic("internal error: entered unreachable code"),
                1..=2 => BR_A::DIV2,
                3..=5 => BR_A::DIV4,
                6..=11 => BR_A::DIV8,
                12..=23 => BR_A::DIV16,
                24..=39 => BR_A::DIV32,
                40..=95 => BR_A::DIV64,
                96..=191 => BR_A::DIV128,
                _ => BR_A::DIV256,
            }
        }
    }
    impl<PINS, WORD> FullDuplex<WORD> for Spi<SPI1, PINS, WORD> {
        type Error = Error;
        fn read(&mut self) -> nb::Result<WORD, Error> {
            let sr = self.spi.sr.read();
            Err(if sr.ovr().is_overrun() {
                nb::Error::Other(Error::Overrun)
            } else if sr.modf().is_fault() {
                nb::Error::Other(Error::ModeFault)
            } else if sr.crcerr().is_no_match() {
                nb::Error::Other(Error::Crc)
            } else if sr.rxne().is_not_empty() {
                let read_ptr = &self.spi.dr as *const _ as *const WORD;
                let value = unsafe { ptr::read_volatile(read_ptr) };
                return Ok(value);
            } else {
                nb::Error::WouldBlock
            })
        }
        fn send(&mut self, word: WORD) -> nb::Result<(), Error> {
            let sr = self.spi.sr.read();
            Err(if sr.ovr().is_overrun() {
                nb::Error::Other(Error::Overrun)
            } else if sr.modf().is_fault() {
                nb::Error::Other(Error::ModeFault)
            } else if sr.crcerr().is_no_match() {
                nb::Error::Other(Error::Crc)
            } else if sr.txe().is_empty() {
                let write_ptr = &self.spi.dr as *const _ as *mut WORD;
                unsafe { ptr::write_volatile(write_ptr, word) };
                return Ok(());
            } else {
                nb::Error::WouldBlock
            })
        }
    }
    impl<PINS, WORD> crate::hal::blocking::spi::transfer::Default<WORD> for Spi<SPI1, PINS, WORD> {}
    impl<PINS, WORD> crate::hal::blocking::spi::write::Default<WORD> for Spi<SPI1, PINS, WORD> {}
    impl<SCK, MISO, MOSI, WORD> Spi<SPI2, (SCK, MISO, MOSI), WORD> {
        #[doc = " Configures the SPI peripheral to operate in full duplex master mode"]
        pub fn spi2<F>(
            spi: SPI2,
            pins: (SCK, MISO, MOSI),
            mode: Mode,
            freq: F,
            clocks: Clocks,
            apb2: &mut APB1,
        ) -> Self
        where
            F: Into<Hertz>,
            SCK: SckPin<SPI2>,
            MISO: MisoPin<SPI2>,
            MOSI: MosiPin<SPI2>,
            WORD: Word,
        {
            apb2.enr().modify(|_, w| w.spi2en().enabled());
            apb2.rstr().modify(|_, w| w.spi2rst().reset());
            apb2.rstr().modify(|_, w| w.spi2rst().clear_bit());
            let (frxth, ds) = WORD::register_config();
            spi.cr2.write(|w| {
                w.frxth().variant(frxth);
                w.ds().variant(ds);
                w.ssoe().disabled()
            });
            spi.cr1.write(|w| {
                w.mstr().master();
                match mode.phase {
                    Phase::CaptureOnFirstTransition => w.cpha().first_edge(),
                    Phase::CaptureOnSecondTransition => w.cpha().second_edge(),
                };
                match mode.polarity {
                    Polarity::IdleLow => w.cpol().idle_low(),
                    Polarity::IdleHigh => w.cpol().idle_high(),
                };
                w.br()
                    .variant(Self::compute_baud_rate(clocks.pclk1(), freq.into()));
                w.spe()
                    .enabled()
                    .lsbfirst()
                    .msbfirst()
                    .ssi()
                    .slave_not_selected()
                    .ssm()
                    .enabled()
                    .crcen()
                    .disabled()
                    .bidimode()
                    .unidirectional()
            });
            Spi {
                spi,
                pins,
                _word: PhantomData,
            }
        }
        #[doc = " Releases the SPI peripheral and associated pins"]
        pub fn free(self) -> (SPI2, (SCK, MISO, MOSI)) {
            (self.spi, self.pins)
        }
        #[doc = " Change the baud rate of the SPI"]
        pub fn reclock<F>(&mut self, freq: F, clocks: Clocks)
        where
            F: Into<Hertz>,
        {
            self.spi.cr1.modify(|_, w| w.spe().disabled());
            self.spi.cr1.modify(|_, w| {
                w.br()
                    .variant(Self::compute_baud_rate(clocks.pclk1(), freq.into()));
                w.spe().enabled()
            });
        }
        fn compute_baud_rate(clocks: Hertz, freq: Hertz) -> spi1::cr1::BR_A {
            use spi1::cr1::BR_A;
            match clocks.0 / freq.0 {
                0 => ::core::panicking::panic("internal error: entered unreachable code"),
                1..=2 => BR_A::DIV2,
                3..=5 => BR_A::DIV4,
                6..=11 => BR_A::DIV8,
                12..=23 => BR_A::DIV16,
                24..=39 => BR_A::DIV32,
                40..=95 => BR_A::DIV64,
                96..=191 => BR_A::DIV128,
                _ => BR_A::DIV256,
            }
        }
    }
    impl<PINS, WORD> FullDuplex<WORD> for Spi<SPI2, PINS, WORD> {
        type Error = Error;
        fn read(&mut self) -> nb::Result<WORD, Error> {
            let sr = self.spi.sr.read();
            Err(if sr.ovr().is_overrun() {
                nb::Error::Other(Error::Overrun)
            } else if sr.modf().is_fault() {
                nb::Error::Other(Error::ModeFault)
            } else if sr.crcerr().is_no_match() {
                nb::Error::Other(Error::Crc)
            } else if sr.rxne().is_not_empty() {
                let read_ptr = &self.spi.dr as *const _ as *const WORD;
                let value = unsafe { ptr::read_volatile(read_ptr) };
                return Ok(value);
            } else {
                nb::Error::WouldBlock
            })
        }
        fn send(&mut self, word: WORD) -> nb::Result<(), Error> {
            let sr = self.spi.sr.read();
            Err(if sr.ovr().is_overrun() {
                nb::Error::Other(Error::Overrun)
            } else if sr.modf().is_fault() {
                nb::Error::Other(Error::ModeFault)
            } else if sr.crcerr().is_no_match() {
                nb::Error::Other(Error::Crc)
            } else if sr.txe().is_empty() {
                let write_ptr = &self.spi.dr as *const _ as *mut WORD;
                unsafe { ptr::write_volatile(write_ptr, word) };
                return Ok(());
            } else {
                nb::Error::WouldBlock
            })
        }
    }
    impl<PINS, WORD> crate::hal::blocking::spi::transfer::Default<WORD> for Spi<SPI2, PINS, WORD> {}
    impl<PINS, WORD> crate::hal::blocking::spi::write::Default<WORD> for Spi<SPI2, PINS, WORD> {}
    impl<SCK, MISO, MOSI, WORD> Spi<SPI3, (SCK, MISO, MOSI), WORD> {
        #[doc = " Configures the SPI peripheral to operate in full duplex master mode"]
        pub fn spi3<F>(
            spi: SPI3,
            pins: (SCK, MISO, MOSI),
            mode: Mode,
            freq: F,
            clocks: Clocks,
            apb2: &mut APB1,
        ) -> Self
        where
            F: Into<Hertz>,
            SCK: SckPin<SPI3>,
            MISO: MisoPin<SPI3>,
            MOSI: MosiPin<SPI3>,
            WORD: Word,
        {
            apb2.enr().modify(|_, w| w.spi3en().enabled());
            apb2.rstr().modify(|_, w| w.spi3rst().reset());
            apb2.rstr().modify(|_, w| w.spi3rst().clear_bit());
            let (frxth, ds) = WORD::register_config();
            spi.cr2.write(|w| {
                w.frxth().variant(frxth);
                w.ds().variant(ds);
                w.ssoe().disabled()
            });
            spi.cr1.write(|w| {
                w.mstr().master();
                match mode.phase {
                    Phase::CaptureOnFirstTransition => w.cpha().first_edge(),
                    Phase::CaptureOnSecondTransition => w.cpha().second_edge(),
                };
                match mode.polarity {
                    Polarity::IdleLow => w.cpol().idle_low(),
                    Polarity::IdleHigh => w.cpol().idle_high(),
                };
                w.br()
                    .variant(Self::compute_baud_rate(clocks.pclk1(), freq.into()));
                w.spe()
                    .enabled()
                    .lsbfirst()
                    .msbfirst()
                    .ssi()
                    .slave_not_selected()
                    .ssm()
                    .enabled()
                    .crcen()
                    .disabled()
                    .bidimode()
                    .unidirectional()
            });
            Spi {
                spi,
                pins,
                _word: PhantomData,
            }
        }
        #[doc = " Releases the SPI peripheral and associated pins"]
        pub fn free(self) -> (SPI3, (SCK, MISO, MOSI)) {
            (self.spi, self.pins)
        }
        #[doc = " Change the baud rate of the SPI"]
        pub fn reclock<F>(&mut self, freq: F, clocks: Clocks)
        where
            F: Into<Hertz>,
        {
            self.spi.cr1.modify(|_, w| w.spe().disabled());
            self.spi.cr1.modify(|_, w| {
                w.br()
                    .variant(Self::compute_baud_rate(clocks.pclk1(), freq.into()));
                w.spe().enabled()
            });
        }
        fn compute_baud_rate(clocks: Hertz, freq: Hertz) -> spi1::cr1::BR_A {
            use spi1::cr1::BR_A;
            match clocks.0 / freq.0 {
                0 => ::core::panicking::panic("internal error: entered unreachable code"),
                1..=2 => BR_A::DIV2,
                3..=5 => BR_A::DIV4,
                6..=11 => BR_A::DIV8,
                12..=23 => BR_A::DIV16,
                24..=39 => BR_A::DIV32,
                40..=95 => BR_A::DIV64,
                96..=191 => BR_A::DIV128,
                _ => BR_A::DIV256,
            }
        }
    }
    impl<PINS, WORD> FullDuplex<WORD> for Spi<SPI3, PINS, WORD> {
        type Error = Error;
        fn read(&mut self) -> nb::Result<WORD, Error> {
            let sr = self.spi.sr.read();
            Err(if sr.ovr().is_overrun() {
                nb::Error::Other(Error::Overrun)
            } else if sr.modf().is_fault() {
                nb::Error::Other(Error::ModeFault)
            } else if sr.crcerr().is_no_match() {
                nb::Error::Other(Error::Crc)
            } else if sr.rxne().is_not_empty() {
                let read_ptr = &self.spi.dr as *const _ as *const WORD;
                let value = unsafe { ptr::read_volatile(read_ptr) };
                return Ok(value);
            } else {
                nb::Error::WouldBlock
            })
        }
        fn send(&mut self, word: WORD) -> nb::Result<(), Error> {
            let sr = self.spi.sr.read();
            Err(if sr.ovr().is_overrun() {
                nb::Error::Other(Error::Overrun)
            } else if sr.modf().is_fault() {
                nb::Error::Other(Error::ModeFault)
            } else if sr.crcerr().is_no_match() {
                nb::Error::Other(Error::Crc)
            } else if sr.txe().is_empty() {
                let write_ptr = &self.spi.dr as *const _ as *mut WORD;
                unsafe { ptr::write_volatile(write_ptr, word) };
                return Ok(());
            } else {
                nb::Error::WouldBlock
            })
        }
    }
    impl<PINS, WORD> crate::hal::blocking::spi::transfer::Default<WORD> for Spi<SPI3, PINS, WORD> {}
    impl<PINS, WORD> crate::hal::blocking::spi::write::Default<WORD> for Spi<SPI3, PINS, WORD> {}
}
pub mod time {
    #![doc = " Time units"]
    use cortex_m::peripheral::DWT;
    use crate::rcc::Clocks;
    #[doc = " Bits per second"]
    pub struct Bps(pub u32);
    impl ::core::marker::StructuralPartialEq for Bps {}
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::cmp::PartialEq for Bps {
        #[inline]
        fn eq(&self, other: &Bps) -> bool {
            match *other {
                Bps(ref __self_1_0) => match *self {
                    Bps(ref __self_0_0) => (*__self_0_0) == (*__self_1_0),
                },
            }
        }
        #[inline]
        fn ne(&self, other: &Bps) -> bool {
            match *other {
                Bps(ref __self_1_0) => match *self {
                    Bps(ref __self_0_0) => (*__self_0_0) != (*__self_1_0),
                },
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::cmp::PartialOrd for Bps {
        #[inline]
        fn partial_cmp(&self, other: &Bps) -> ::core::option::Option<::core::cmp::Ordering> {
            match *other {
                Bps(ref __self_1_0) => match *self {
                    Bps(ref __self_0_0) => {
                        match ::core::cmp::PartialOrd::partial_cmp(&(*__self_0_0), &(*__self_1_0)) {
                            ::core::option::Option::Some(::core::cmp::Ordering::Equal) => {
                                ::core::option::Option::Some(::core::cmp::Ordering::Equal)
                            }
                            cmp => cmp,
                        }
                    }
                },
            }
        }
        #[inline]
        fn lt(&self, other: &Bps) -> bool {
            match *other {
                Bps(ref __self_1_0) => match *self {
                    Bps(ref __self_0_0) => {
                        ::core::option::Option::unwrap_or(
                            ::core::cmp::PartialOrd::partial_cmp(&(*__self_0_0), &(*__self_1_0)),
                            ::core::cmp::Ordering::Greater,
                        ) == ::core::cmp::Ordering::Less
                    }
                },
            }
        }
        #[inline]
        fn le(&self, other: &Bps) -> bool {
            match *other {
                Bps(ref __self_1_0) => match *self {
                    Bps(ref __self_0_0) => {
                        ::core::option::Option::unwrap_or(
                            ::core::cmp::PartialOrd::partial_cmp(&(*__self_0_0), &(*__self_1_0)),
                            ::core::cmp::Ordering::Greater,
                        ) != ::core::cmp::Ordering::Greater
                    }
                },
            }
        }
        #[inline]
        fn gt(&self, other: &Bps) -> bool {
            match *other {
                Bps(ref __self_1_0) => match *self {
                    Bps(ref __self_0_0) => {
                        ::core::option::Option::unwrap_or(
                            ::core::cmp::PartialOrd::partial_cmp(&(*__self_0_0), &(*__self_1_0)),
                            ::core::cmp::Ordering::Less,
                        ) == ::core::cmp::Ordering::Greater
                    }
                },
            }
        }
        #[inline]
        fn ge(&self, other: &Bps) -> bool {
            match *other {
                Bps(ref __self_1_0) => match *self {
                    Bps(ref __self_0_0) => {
                        ::core::option::Option::unwrap_or(
                            ::core::cmp::PartialOrd::partial_cmp(&(*__self_0_0), &(*__self_1_0)),
                            ::core::cmp::Ordering::Less,
                        ) != ::core::cmp::Ordering::Less
                    }
                },
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::clone::Clone for Bps {
        #[inline]
        fn clone(&self) -> Bps {
            {
                let _: ::core::clone::AssertParamIsClone<u32>;
                *self
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::marker::Copy for Bps {}
    #[doc = " Hertz"]
    pub struct Hertz(pub u32);
    impl ::core::marker::StructuralPartialEq for Hertz {}
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::cmp::PartialEq for Hertz {
        #[inline]
        fn eq(&self, other: &Hertz) -> bool {
            match *other {
                Hertz(ref __self_1_0) => match *self {
                    Hertz(ref __self_0_0) => (*__self_0_0) == (*__self_1_0),
                },
            }
        }
        #[inline]
        fn ne(&self, other: &Hertz) -> bool {
            match *other {
                Hertz(ref __self_1_0) => match *self {
                    Hertz(ref __self_0_0) => (*__self_0_0) != (*__self_1_0),
                },
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::cmp::PartialOrd for Hertz {
        #[inline]
        fn partial_cmp(&self, other: &Hertz) -> ::core::option::Option<::core::cmp::Ordering> {
            match *other {
                Hertz(ref __self_1_0) => match *self {
                    Hertz(ref __self_0_0) => {
                        match ::core::cmp::PartialOrd::partial_cmp(&(*__self_0_0), &(*__self_1_0)) {
                            ::core::option::Option::Some(::core::cmp::Ordering::Equal) => {
                                ::core::option::Option::Some(::core::cmp::Ordering::Equal)
                            }
                            cmp => cmp,
                        }
                    }
                },
            }
        }
        #[inline]
        fn lt(&self, other: &Hertz) -> bool {
            match *other {
                Hertz(ref __self_1_0) => match *self {
                    Hertz(ref __self_0_0) => {
                        ::core::option::Option::unwrap_or(
                            ::core::cmp::PartialOrd::partial_cmp(&(*__self_0_0), &(*__self_1_0)),
                            ::core::cmp::Ordering::Greater,
                        ) == ::core::cmp::Ordering::Less
                    }
                },
            }
        }
        #[inline]
        fn le(&self, other: &Hertz) -> bool {
            match *other {
                Hertz(ref __self_1_0) => match *self {
                    Hertz(ref __self_0_0) => {
                        ::core::option::Option::unwrap_or(
                            ::core::cmp::PartialOrd::partial_cmp(&(*__self_0_0), &(*__self_1_0)),
                            ::core::cmp::Ordering::Greater,
                        ) != ::core::cmp::Ordering::Greater
                    }
                },
            }
        }
        #[inline]
        fn gt(&self, other: &Hertz) -> bool {
            match *other {
                Hertz(ref __self_1_0) => match *self {
                    Hertz(ref __self_0_0) => {
                        ::core::option::Option::unwrap_or(
                            ::core::cmp::PartialOrd::partial_cmp(&(*__self_0_0), &(*__self_1_0)),
                            ::core::cmp::Ordering::Less,
                        ) == ::core::cmp::Ordering::Greater
                    }
                },
            }
        }
        #[inline]
        fn ge(&self, other: &Hertz) -> bool {
            match *other {
                Hertz(ref __self_1_0) => match *self {
                    Hertz(ref __self_0_0) => {
                        ::core::option::Option::unwrap_or(
                            ::core::cmp::PartialOrd::partial_cmp(&(*__self_0_0), &(*__self_1_0)),
                            ::core::cmp::Ordering::Less,
                        ) != ::core::cmp::Ordering::Less
                    }
                },
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::clone::Clone for Hertz {
        #[inline]
        fn clone(&self) -> Hertz {
            {
                let _: ::core::clone::AssertParamIsClone<u32>;
                *self
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::marker::Copy for Hertz {}
    #[doc = " KiloHertz"]
    pub struct KiloHertz(pub u32);
    impl ::core::marker::StructuralPartialEq for KiloHertz {}
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::cmp::PartialEq for KiloHertz {
        #[inline]
        fn eq(&self, other: &KiloHertz) -> bool {
            match *other {
                KiloHertz(ref __self_1_0) => match *self {
                    KiloHertz(ref __self_0_0) => (*__self_0_0) == (*__self_1_0),
                },
            }
        }
        #[inline]
        fn ne(&self, other: &KiloHertz) -> bool {
            match *other {
                KiloHertz(ref __self_1_0) => match *self {
                    KiloHertz(ref __self_0_0) => (*__self_0_0) != (*__self_1_0),
                },
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::cmp::PartialOrd for KiloHertz {
        #[inline]
        fn partial_cmp(&self, other: &KiloHertz) -> ::core::option::Option<::core::cmp::Ordering> {
            match *other {
                KiloHertz(ref __self_1_0) => match *self {
                    KiloHertz(ref __self_0_0) => {
                        match ::core::cmp::PartialOrd::partial_cmp(&(*__self_0_0), &(*__self_1_0)) {
                            ::core::option::Option::Some(::core::cmp::Ordering::Equal) => {
                                ::core::option::Option::Some(::core::cmp::Ordering::Equal)
                            }
                            cmp => cmp,
                        }
                    }
                },
            }
        }
        #[inline]
        fn lt(&self, other: &KiloHertz) -> bool {
            match *other {
                KiloHertz(ref __self_1_0) => match *self {
                    KiloHertz(ref __self_0_0) => {
                        ::core::option::Option::unwrap_or(
                            ::core::cmp::PartialOrd::partial_cmp(&(*__self_0_0), &(*__self_1_0)),
                            ::core::cmp::Ordering::Greater,
                        ) == ::core::cmp::Ordering::Less
                    }
                },
            }
        }
        #[inline]
        fn le(&self, other: &KiloHertz) -> bool {
            match *other {
                KiloHertz(ref __self_1_0) => match *self {
                    KiloHertz(ref __self_0_0) => {
                        ::core::option::Option::unwrap_or(
                            ::core::cmp::PartialOrd::partial_cmp(&(*__self_0_0), &(*__self_1_0)),
                            ::core::cmp::Ordering::Greater,
                        ) != ::core::cmp::Ordering::Greater
                    }
                },
            }
        }
        #[inline]
        fn gt(&self, other: &KiloHertz) -> bool {
            match *other {
                KiloHertz(ref __self_1_0) => match *self {
                    KiloHertz(ref __self_0_0) => {
                        ::core::option::Option::unwrap_or(
                            ::core::cmp::PartialOrd::partial_cmp(&(*__self_0_0), &(*__self_1_0)),
                            ::core::cmp::Ordering::Less,
                        ) == ::core::cmp::Ordering::Greater
                    }
                },
            }
        }
        #[inline]
        fn ge(&self, other: &KiloHertz) -> bool {
            match *other {
                KiloHertz(ref __self_1_0) => match *self {
                    KiloHertz(ref __self_0_0) => {
                        ::core::option::Option::unwrap_or(
                            ::core::cmp::PartialOrd::partial_cmp(&(*__self_0_0), &(*__self_1_0)),
                            ::core::cmp::Ordering::Less,
                        ) != ::core::cmp::Ordering::Less
                    }
                },
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::clone::Clone for KiloHertz {
        #[inline]
        fn clone(&self) -> KiloHertz {
            {
                let _: ::core::clone::AssertParamIsClone<u32>;
                *self
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::marker::Copy for KiloHertz {}
    #[doc = " MegaHertz"]
    pub struct MegaHertz(pub u32);
    impl ::core::marker::StructuralPartialEq for MegaHertz {}
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::cmp::PartialEq for MegaHertz {
        #[inline]
        fn eq(&self, other: &MegaHertz) -> bool {
            match *other {
                MegaHertz(ref __self_1_0) => match *self {
                    MegaHertz(ref __self_0_0) => (*__self_0_0) == (*__self_1_0),
                },
            }
        }
        #[inline]
        fn ne(&self, other: &MegaHertz) -> bool {
            match *other {
                MegaHertz(ref __self_1_0) => match *self {
                    MegaHertz(ref __self_0_0) => (*__self_0_0) != (*__self_1_0),
                },
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::cmp::PartialOrd for MegaHertz {
        #[inline]
        fn partial_cmp(&self, other: &MegaHertz) -> ::core::option::Option<::core::cmp::Ordering> {
            match *other {
                MegaHertz(ref __self_1_0) => match *self {
                    MegaHertz(ref __self_0_0) => {
                        match ::core::cmp::PartialOrd::partial_cmp(&(*__self_0_0), &(*__self_1_0)) {
                            ::core::option::Option::Some(::core::cmp::Ordering::Equal) => {
                                ::core::option::Option::Some(::core::cmp::Ordering::Equal)
                            }
                            cmp => cmp,
                        }
                    }
                },
            }
        }
        #[inline]
        fn lt(&self, other: &MegaHertz) -> bool {
            match *other {
                MegaHertz(ref __self_1_0) => match *self {
                    MegaHertz(ref __self_0_0) => {
                        ::core::option::Option::unwrap_or(
                            ::core::cmp::PartialOrd::partial_cmp(&(*__self_0_0), &(*__self_1_0)),
                            ::core::cmp::Ordering::Greater,
                        ) == ::core::cmp::Ordering::Less
                    }
                },
            }
        }
        #[inline]
        fn le(&self, other: &MegaHertz) -> bool {
            match *other {
                MegaHertz(ref __self_1_0) => match *self {
                    MegaHertz(ref __self_0_0) => {
                        ::core::option::Option::unwrap_or(
                            ::core::cmp::PartialOrd::partial_cmp(&(*__self_0_0), &(*__self_1_0)),
                            ::core::cmp::Ordering::Greater,
                        ) != ::core::cmp::Ordering::Greater
                    }
                },
            }
        }
        #[inline]
        fn gt(&self, other: &MegaHertz) -> bool {
            match *other {
                MegaHertz(ref __self_1_0) => match *self {
                    MegaHertz(ref __self_0_0) => {
                        ::core::option::Option::unwrap_or(
                            ::core::cmp::PartialOrd::partial_cmp(&(*__self_0_0), &(*__self_1_0)),
                            ::core::cmp::Ordering::Less,
                        ) == ::core::cmp::Ordering::Greater
                    }
                },
            }
        }
        #[inline]
        fn ge(&self, other: &MegaHertz) -> bool {
            match *other {
                MegaHertz(ref __self_1_0) => match *self {
                    MegaHertz(ref __self_0_0) => {
                        ::core::option::Option::unwrap_or(
                            ::core::cmp::PartialOrd::partial_cmp(&(*__self_0_0), &(*__self_1_0)),
                            ::core::cmp::Ordering::Less,
                        ) != ::core::cmp::Ordering::Less
                    }
                },
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::clone::Clone for MegaHertz {
        #[inline]
        fn clone(&self) -> MegaHertz {
            {
                let _: ::core::clone::AssertParamIsClone<u32>;
                *self
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::marker::Copy for MegaHertz {}
    #[doc = " Time unit"]
    pub struct MilliSeconds(pub u32);
    impl ::core::marker::StructuralPartialEq for MilliSeconds {}
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::cmp::PartialEq for MilliSeconds {
        #[inline]
        fn eq(&self, other: &MilliSeconds) -> bool {
            match *other {
                MilliSeconds(ref __self_1_0) => match *self {
                    MilliSeconds(ref __self_0_0) => (*__self_0_0) == (*__self_1_0),
                },
            }
        }
        #[inline]
        fn ne(&self, other: &MilliSeconds) -> bool {
            match *other {
                MilliSeconds(ref __self_1_0) => match *self {
                    MilliSeconds(ref __self_0_0) => (*__self_0_0) != (*__self_1_0),
                },
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::cmp::PartialOrd for MilliSeconds {
        #[inline]
        fn partial_cmp(
            &self,
            other: &MilliSeconds,
        ) -> ::core::option::Option<::core::cmp::Ordering> {
            match *other {
                MilliSeconds(ref __self_1_0) => match *self {
                    MilliSeconds(ref __self_0_0) => {
                        match ::core::cmp::PartialOrd::partial_cmp(&(*__self_0_0), &(*__self_1_0)) {
                            ::core::option::Option::Some(::core::cmp::Ordering::Equal) => {
                                ::core::option::Option::Some(::core::cmp::Ordering::Equal)
                            }
                            cmp => cmp,
                        }
                    }
                },
            }
        }
        #[inline]
        fn lt(&self, other: &MilliSeconds) -> bool {
            match *other {
                MilliSeconds(ref __self_1_0) => match *self {
                    MilliSeconds(ref __self_0_0) => {
                        ::core::option::Option::unwrap_or(
                            ::core::cmp::PartialOrd::partial_cmp(&(*__self_0_0), &(*__self_1_0)),
                            ::core::cmp::Ordering::Greater,
                        ) == ::core::cmp::Ordering::Less
                    }
                },
            }
        }
        #[inline]
        fn le(&self, other: &MilliSeconds) -> bool {
            match *other {
                MilliSeconds(ref __self_1_0) => match *self {
                    MilliSeconds(ref __self_0_0) => {
                        ::core::option::Option::unwrap_or(
                            ::core::cmp::PartialOrd::partial_cmp(&(*__self_0_0), &(*__self_1_0)),
                            ::core::cmp::Ordering::Greater,
                        ) != ::core::cmp::Ordering::Greater
                    }
                },
            }
        }
        #[inline]
        fn gt(&self, other: &MilliSeconds) -> bool {
            match *other {
                MilliSeconds(ref __self_1_0) => match *self {
                    MilliSeconds(ref __self_0_0) => {
                        ::core::option::Option::unwrap_or(
                            ::core::cmp::PartialOrd::partial_cmp(&(*__self_0_0), &(*__self_1_0)),
                            ::core::cmp::Ordering::Less,
                        ) == ::core::cmp::Ordering::Greater
                    }
                },
            }
        }
        #[inline]
        fn ge(&self, other: &MilliSeconds) -> bool {
            match *other {
                MilliSeconds(ref __self_1_0) => match *self {
                    MilliSeconds(ref __self_0_0) => {
                        ::core::option::Option::unwrap_or(
                            ::core::cmp::PartialOrd::partial_cmp(&(*__self_0_0), &(*__self_1_0)),
                            ::core::cmp::Ordering::Less,
                        ) != ::core::cmp::Ordering::Less
                    }
                },
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::clone::Clone for MilliSeconds {
        #[inline]
        fn clone(&self) -> MilliSeconds {
            {
                let _: ::core::clone::AssertParamIsClone<u32>;
                *self
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::marker::Copy for MilliSeconds {}
    #[doc = " Extension trait that adds convenience methods to the `u32` type"]
    pub trait U32Ext {
        #[doc = " Wrap in `Bps`"]
        fn bps(self) -> Bps;
        #[doc = " Wrap in `Hertz`"]
        fn hz(self) -> Hertz;
        #[doc = " Wrap in `KiloHertz`"]
        fn khz(self) -> KiloHertz;
        #[doc = " Wrap in `MegaHertz`"]
        fn mhz(self) -> MegaHertz;
        #[doc = " Wrap in `MilliSeconds`"]
        fn ms(self) -> MilliSeconds;
    }
    impl U32Ext for u32 {
        fn bps(self) -> Bps {
            Bps(self)
        }
        fn hz(self) -> Hertz {
            Hertz(self)
        }
        fn khz(self) -> KiloHertz {
            KiloHertz(self)
        }
        fn mhz(self) -> MegaHertz {
            MegaHertz(self)
        }
        fn ms(self) -> MilliSeconds {
            MilliSeconds(self)
        }
    }
    impl From<KiloHertz> for Hertz {
        fn from(val: KiloHertz) -> Self {
            Self(val.0 * 1_000)
        }
    }
    impl From<MegaHertz> for Hertz {
        fn from(val: MegaHertz) -> Self {
            Self(val.0 * 1_000_000)
        }
    }
    impl From<MegaHertz> for KiloHertz {
        fn from(val: MegaHertz) -> Self {
            Self(val.0 * 1_000)
        }
    }
    #[doc = " A monotonic nondecreasing timer"]
    pub struct MonoTimer {
        frequency: Hertz,
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::clone::Clone for MonoTimer {
        #[inline]
        fn clone(&self) -> MonoTimer {
            {
                let _: ::core::clone::AssertParamIsClone<Hertz>;
                *self
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::marker::Copy for MonoTimer {}
    impl MonoTimer {
        #[doc = " Creates a new `Monotonic` timer"]
        pub fn new(mut dwt: DWT, clocks: Clocks) -> Self {
            dwt.enable_cycle_counter();
            drop(dwt);
            MonoTimer {
                frequency: clocks.hclk(),
            }
        }
        #[doc = " Returns the frequency at which the monotonic timer is operating at"]
        pub fn frequency(self) -> Hertz {
            self.frequency
        }
        #[doc = " Returns an `Instant` corresponding to \"now\""]
        pub fn now(self) -> Instant {
            Instant {
                now: DWT::get_cycle_count(),
            }
        }
    }
    #[doc = " A measurement of a monotonically nondecreasing clock"]
    pub struct Instant {
        now: u32,
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::clone::Clone for Instant {
        #[inline]
        fn clone(&self) -> Instant {
            {
                let _: ::core::clone::AssertParamIsClone<u32>;
                *self
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::marker::Copy for Instant {}
    impl Instant {
        #[doc = " Ticks elapsed since the `Instant` was created"]
        pub fn elapsed(self) -> u32 {
            DWT::get_cycle_count().wrapping_sub(self.now)
        }
    }
}
pub mod timer {
    #![doc = " Timers"]
    use core::convert::{From, TryFrom};
    use crate::hal::timer::{CountDown, Periodic};
    #[cfg(any(
        feature = "stm32f301",
        feature = "stm32f302",
        feature = "stm32f303",
        feature = "stm32f334",
        feature = "stm32f318",
        feature = "stm32f328",
        feature = "stm32f358",
        feature = "stm32f398",
    ))]
    use crate::pac::TIM1;
    #[cfg(any(
        feature = "stm32f303",
        feature = "stm32f328",
        feature = "stm32f358",
        feature = "stm32f398"
    ))]
    use crate::pac::TIM20;
    #[cfg(any(
        feature = "stm32f303",
        feature = "stm32f328",
        feature = "stm32f358",
        feature = "stm32f373",
        feature = "stm32f378",
        feature = "stm32f398"
    ))]
    use crate::pac::TIM4;
    #[cfg(any(
        feature = "stm32f303",
        feature = "stm32f328",
        feature = "stm32f358",
        feature = "stm32f398",
    ))]
    use crate::pac::TIM8;
    use crate::pac::{TIM15, TIM16, TIM17, TIM2, TIM6};
    #[cfg(any(
        feature = "stm32f303",
        feature = "stm32f328",
        feature = "stm32f334",
        feature = "stm32f358",
        feature = "stm32f373",
        feature = "stm32f378",
        feature = "stm32f398"
    ))]
    use crate::pac::{TIM3, TIM7};
    use void::Void;
    use crate::rcc::{Clocks, APB1, APB2};
    use crate::time::Hertz;
    #[doc = " Associated clocks with timers"]
    pub trait PclkSrc {
        #[doc = " Get the current frequency of the associated clock"]
        fn get_clk(clocks: &Clocks) -> Hertz;
    }
    #[doc = " Hardware timers"]
    pub struct Timer<TIM> {
        clocks: Clocks,
        tim: TIM,
    }
    #[doc = " Interrupt events"]
    pub enum Event {
        #[doc = " Timer timed out / count down ended"]
        Update,
    }
    impl PclkSrc for TIM1 {
        fn get_clk(clocks: &Clocks) -> Hertz {
            clocks.pclk2()
        }
    }
    impl Periodic for Timer<TIM1> {}
    impl CountDown for Timer<TIM1> {
        type Time = Hertz;
        fn start<T>(&mut self, timeout: T)
        where
            T: Into<Hertz>,
        {
            self.stop();
            let frequency = timeout.into().0;
            let timer_clock = TIM1::get_clk(&self.clocks);
            let ticks = timer_clock.0 * if self.clocks.ppre1() == 1 { 1 } else { 2 } / frequency;
            let psc = u16::try_from((ticks - 1) / (1 << 16)).ok().unwrap();
            self.tim.psc.write(|w| w.psc().bits(psc));
            let arr = u16::try_from(ticks / u32::from(psc + 1)).ok().unwrap();
            self.tim.arr.write(|w| unsafe { w.bits(u32::from(arr)) });
            self.tim.egr.write(|w| w.ug().update());
            self.clear_update_interrupt_flag();
            self.tim.cr1.modify(|_, w| w.cen().enabled());
        }
        fn wait(&mut self) -> nb::Result<(), Void> {
            if self.tim.sr.read().uif().is_clear() {
                Err(nb::Error::WouldBlock)
            } else {
                self.clear_update_interrupt_flag();
                Ok(())
            }
        }
    }
    impl Timer<TIM1> {
        #[doc = " Configures a TIM peripheral as a periodic count down timer"]
        pub fn tim1<T>(tim: TIM1, timeout: T, clocks: Clocks, apb2: &mut APB2) -> Self
        where
            T: Into<Hertz>,
        {
            apb2.enr().modify(|_, w| w.tim1en().enabled());
            apb2.rstr().modify(|_, w| w.tim1rst().reset());
            apb2.rstr().modify(|_, w| w.tim1rst().clear_bit());
            let mut timer = Timer { clocks, tim };
            timer.start(timeout);
            timer
        }
        #[doc = " Starts listening for an `event`"]
        pub fn listen(&mut self, event: Event) {
            match event {
                Event::Update => self.tim.dier.write(|w| w.uie().enabled()),
            }
        }
        #[doc = " Stops listening for an `event`"]
        pub fn unlisten(&mut self, event: Event) {
            match event {
                Event::Update => self.tim.dier.write(|w| w.uie().disabled()),
            }
        }
        #[doc = " Stops the timer"]
        pub fn stop(&mut self) {
            self.tim.cr1.modify(|_, w| w.cen().disabled());
        }
        #[doc = " Clears Update Interrupt Flag"]
        pub fn clear_update_interrupt_flag(&mut self) {
            self.tim.sr.modify(|_, w| w.uif().clear());
        }
        #[doc = " Releases the TIM peripheral"]
        pub fn release(mut self) -> TIM1 {
            self.stop();
            self.tim
        }
    }
    impl PclkSrc for TIM2 {
        fn get_clk(clocks: &Clocks) -> Hertz {
            clocks.pclk1()
        }
    }
    impl Periodic for Timer<TIM2> {}
    impl CountDown for Timer<TIM2> {
        type Time = Hertz;
        fn start<T>(&mut self, timeout: T)
        where
            T: Into<Hertz>,
        {
            self.stop();
            let frequency = timeout.into().0;
            let timer_clock = TIM2::get_clk(&self.clocks);
            let ticks = timer_clock.0 * if self.clocks.ppre1() == 1 { 1 } else { 2 } / frequency;
            let psc = u16::try_from((ticks - 1) / (1 << 16)).ok().unwrap();
            self.tim.psc.write(|w| w.psc().bits(psc));
            let arr = u16::try_from(ticks / u32::from(psc + 1)).ok().unwrap();
            self.tim.arr.write(|w| unsafe { w.bits(u32::from(arr)) });
            self.tim.egr.write(|w| w.ug().update());
            self.clear_update_interrupt_flag();
            self.tim.cr1.modify(|_, w| w.cen().enabled());
        }
        fn wait(&mut self) -> nb::Result<(), Void> {
            if self.tim.sr.read().uif().is_clear() {
                Err(nb::Error::WouldBlock)
            } else {
                self.clear_update_interrupt_flag();
                Ok(())
            }
        }
    }
    impl Timer<TIM2> {
        #[doc = " Configures a TIM peripheral as a periodic count down timer"]
        pub fn tim2<T>(tim: TIM2, timeout: T, clocks: Clocks, apb1: &mut APB1) -> Self
        where
            T: Into<Hertz>,
        {
            apb1.enr().modify(|_, w| w.tim2en().enabled());
            apb1.rstr().modify(|_, w| w.tim2rst().reset());
            apb1.rstr().modify(|_, w| w.tim2rst().clear_bit());
            let mut timer = Timer { clocks, tim };
            timer.start(timeout);
            timer
        }
        #[doc = " Starts listening for an `event`"]
        pub fn listen(&mut self, event: Event) {
            match event {
                Event::Update => self.tim.dier.write(|w| w.uie().enabled()),
            }
        }
        #[doc = " Stops listening for an `event`"]
        pub fn unlisten(&mut self, event: Event) {
            match event {
                Event::Update => self.tim.dier.write(|w| w.uie().disabled()),
            }
        }
        #[doc = " Stops the timer"]
        pub fn stop(&mut self) {
            self.tim.cr1.modify(|_, w| w.cen().disabled());
        }
        #[doc = " Clears Update Interrupt Flag"]
        pub fn clear_update_interrupt_flag(&mut self) {
            self.tim.sr.modify(|_, w| w.uif().clear());
        }
        #[doc = " Releases the TIM peripheral"]
        pub fn release(mut self) -> TIM2 {
            self.stop();
            self.tim
        }
    }
    impl PclkSrc for TIM3 {
        fn get_clk(clocks: &Clocks) -> Hertz {
            clocks.pclk1()
        }
    }
    impl Periodic for Timer<TIM3> {}
    impl CountDown for Timer<TIM3> {
        type Time = Hertz;
        fn start<T>(&mut self, timeout: T)
        where
            T: Into<Hertz>,
        {
            self.stop();
            let frequency = timeout.into().0;
            let timer_clock = TIM3::get_clk(&self.clocks);
            let ticks = timer_clock.0 * if self.clocks.ppre1() == 1 { 1 } else { 2 } / frequency;
            let psc = u16::try_from((ticks - 1) / (1 << 16)).ok().unwrap();
            self.tim.psc.write(|w| w.psc().bits(psc));
            let arr = u16::try_from(ticks / u32::from(psc + 1)).ok().unwrap();
            self.tim.arr.write(|w| unsafe { w.bits(u32::from(arr)) });
            self.tim.egr.write(|w| w.ug().update());
            self.clear_update_interrupt_flag();
            self.tim.cr1.modify(|_, w| w.cen().enabled());
        }
        fn wait(&mut self) -> nb::Result<(), Void> {
            if self.tim.sr.read().uif().is_clear() {
                Err(nb::Error::WouldBlock)
            } else {
                self.clear_update_interrupt_flag();
                Ok(())
            }
        }
    }
    impl Timer<TIM3> {
        #[doc = " Configures a TIM peripheral as a periodic count down timer"]
        pub fn tim3<T>(tim: TIM3, timeout: T, clocks: Clocks, apb1: &mut APB1) -> Self
        where
            T: Into<Hertz>,
        {
            apb1.enr().modify(|_, w| w.tim3en().enabled());
            apb1.rstr().modify(|_, w| w.tim3rst().reset());
            apb1.rstr().modify(|_, w| w.tim3rst().clear_bit());
            let mut timer = Timer { clocks, tim };
            timer.start(timeout);
            timer
        }
        #[doc = " Starts listening for an `event`"]
        pub fn listen(&mut self, event: Event) {
            match event {
                Event::Update => self.tim.dier.write(|w| w.uie().enabled()),
            }
        }
        #[doc = " Stops listening for an `event`"]
        pub fn unlisten(&mut self, event: Event) {
            match event {
                Event::Update => self.tim.dier.write(|w| w.uie().disabled()),
            }
        }
        #[doc = " Stops the timer"]
        pub fn stop(&mut self) {
            self.tim.cr1.modify(|_, w| w.cen().disabled());
        }
        #[doc = " Clears Update Interrupt Flag"]
        pub fn clear_update_interrupt_flag(&mut self) {
            self.tim.sr.modify(|_, w| w.uif().clear());
        }
        #[doc = " Releases the TIM peripheral"]
        pub fn release(mut self) -> TIM3 {
            self.stop();
            self.tim
        }
    }
    impl PclkSrc for TIM4 {
        fn get_clk(clocks: &Clocks) -> Hertz {
            clocks.pclk1()
        }
    }
    impl Periodic for Timer<TIM4> {}
    impl CountDown for Timer<TIM4> {
        type Time = Hertz;
        fn start<T>(&mut self, timeout: T)
        where
            T: Into<Hertz>,
        {
            self.stop();
            let frequency = timeout.into().0;
            let timer_clock = TIM4::get_clk(&self.clocks);
            let ticks = timer_clock.0 * if self.clocks.ppre1() == 1 { 1 } else { 2 } / frequency;
            let psc = u16::try_from((ticks - 1) / (1 << 16)).ok().unwrap();
            self.tim.psc.write(|w| w.psc().bits(psc));
            let arr = u16::try_from(ticks / u32::from(psc + 1)).ok().unwrap();
            self.tim.arr.write(|w| unsafe { w.bits(u32::from(arr)) });
            self.tim.egr.write(|w| w.ug().update());
            self.clear_update_interrupt_flag();
            self.tim.cr1.modify(|_, w| w.cen().enabled());
        }
        fn wait(&mut self) -> nb::Result<(), Void> {
            if self.tim.sr.read().uif().is_clear() {
                Err(nb::Error::WouldBlock)
            } else {
                self.clear_update_interrupt_flag();
                Ok(())
            }
        }
    }
    impl Timer<TIM4> {
        #[doc = " Configures a TIM peripheral as a periodic count down timer"]
        pub fn tim4<T>(tim: TIM4, timeout: T, clocks: Clocks, apb1: &mut APB1) -> Self
        where
            T: Into<Hertz>,
        {
            apb1.enr().modify(|_, w| w.tim4en().enabled());
            apb1.rstr().modify(|_, w| w.tim4rst().reset());
            apb1.rstr().modify(|_, w| w.tim4rst().clear_bit());
            let mut timer = Timer { clocks, tim };
            timer.start(timeout);
            timer
        }
        #[doc = " Starts listening for an `event`"]
        pub fn listen(&mut self, event: Event) {
            match event {
                Event::Update => self.tim.dier.write(|w| w.uie().enabled()),
            }
        }
        #[doc = " Stops listening for an `event`"]
        pub fn unlisten(&mut self, event: Event) {
            match event {
                Event::Update => self.tim.dier.write(|w| w.uie().disabled()),
            }
        }
        #[doc = " Stops the timer"]
        pub fn stop(&mut self) {
            self.tim.cr1.modify(|_, w| w.cen().disabled());
        }
        #[doc = " Clears Update Interrupt Flag"]
        pub fn clear_update_interrupt_flag(&mut self) {
            self.tim.sr.modify(|_, w| w.uif().clear());
        }
        #[doc = " Releases the TIM peripheral"]
        pub fn release(mut self) -> TIM4 {
            self.stop();
            self.tim
        }
    }
    impl PclkSrc for TIM6 {
        fn get_clk(clocks: &Clocks) -> Hertz {
            clocks.pclk1()
        }
    }
    impl Periodic for Timer<TIM6> {}
    impl CountDown for Timer<TIM6> {
        type Time = Hertz;
        fn start<T>(&mut self, timeout: T)
        where
            T: Into<Hertz>,
        {
            self.stop();
            let frequency = timeout.into().0;
            let timer_clock = TIM6::get_clk(&self.clocks);
            let ticks = timer_clock.0 * if self.clocks.ppre1() == 1 { 1 } else { 2 } / frequency;
            let psc = u16::try_from((ticks - 1) / (1 << 16)).ok().unwrap();
            self.tim.psc.write(|w| w.psc().bits(psc));
            let arr = u16::try_from(ticks / u32::from(psc + 1)).ok().unwrap();
            self.tim.arr.write(|w| unsafe { w.bits(u32::from(arr)) });
            self.tim.egr.write(|w| w.ug().update());
            self.clear_update_interrupt_flag();
            self.tim.cr1.modify(|_, w| w.cen().enabled());
        }
        fn wait(&mut self) -> nb::Result<(), Void> {
            if self.tim.sr.read().uif().is_clear() {
                Err(nb::Error::WouldBlock)
            } else {
                self.clear_update_interrupt_flag();
                Ok(())
            }
        }
    }
    impl Timer<TIM6> {
        #[doc = " Configures a TIM peripheral as a periodic count down timer"]
        pub fn tim6<T>(tim: TIM6, timeout: T, clocks: Clocks, apb1: &mut APB1) -> Self
        where
            T: Into<Hertz>,
        {
            apb1.enr().modify(|_, w| w.tim6en().enabled());
            apb1.rstr().modify(|_, w| w.tim6rst().reset());
            apb1.rstr().modify(|_, w| w.tim6rst().clear_bit());
            let mut timer = Timer { clocks, tim };
            timer.start(timeout);
            timer
        }
        #[doc = " Starts listening for an `event`"]
        pub fn listen(&mut self, event: Event) {
            match event {
                Event::Update => self.tim.dier.write(|w| w.uie().enabled()),
            }
        }
        #[doc = " Stops listening for an `event`"]
        pub fn unlisten(&mut self, event: Event) {
            match event {
                Event::Update => self.tim.dier.write(|w| w.uie().disabled()),
            }
        }
        #[doc = " Stops the timer"]
        pub fn stop(&mut self) {
            self.tim.cr1.modify(|_, w| w.cen().disabled());
        }
        #[doc = " Clears Update Interrupt Flag"]
        pub fn clear_update_interrupt_flag(&mut self) {
            self.tim.sr.modify(|_, w| w.uif().clear());
        }
        #[doc = " Releases the TIM peripheral"]
        pub fn release(mut self) -> TIM6 {
            self.stop();
            self.tim
        }
    }
    impl PclkSrc for TIM7 {
        fn get_clk(clocks: &Clocks) -> Hertz {
            clocks.pclk1()
        }
    }
    impl Periodic for Timer<TIM7> {}
    impl CountDown for Timer<TIM7> {
        type Time = Hertz;
        fn start<T>(&mut self, timeout: T)
        where
            T: Into<Hertz>,
        {
            self.stop();
            let frequency = timeout.into().0;
            let timer_clock = TIM7::get_clk(&self.clocks);
            let ticks = timer_clock.0 * if self.clocks.ppre1() == 1 { 1 } else { 2 } / frequency;
            let psc = u16::try_from((ticks - 1) / (1 << 16)).ok().unwrap();
            self.tim.psc.write(|w| w.psc().bits(psc));
            let arr = u16::try_from(ticks / u32::from(psc + 1)).ok().unwrap();
            self.tim.arr.write(|w| unsafe { w.bits(u32::from(arr)) });
            self.tim.egr.write(|w| w.ug().update());
            self.clear_update_interrupt_flag();
            self.tim.cr1.modify(|_, w| w.cen().enabled());
        }
        fn wait(&mut self) -> nb::Result<(), Void> {
            if self.tim.sr.read().uif().is_clear() {
                Err(nb::Error::WouldBlock)
            } else {
                self.clear_update_interrupt_flag();
                Ok(())
            }
        }
    }
    impl Timer<TIM7> {
        #[doc = " Configures a TIM peripheral as a periodic count down timer"]
        pub fn tim7<T>(tim: TIM7, timeout: T, clocks: Clocks, apb1: &mut APB1) -> Self
        where
            T: Into<Hertz>,
        {
            apb1.enr().modify(|_, w| w.tim7en().enabled());
            apb1.rstr().modify(|_, w| w.tim7rst().reset());
            apb1.rstr().modify(|_, w| w.tim7rst().clear_bit());
            let mut timer = Timer { clocks, tim };
            timer.start(timeout);
            timer
        }
        #[doc = " Starts listening for an `event`"]
        pub fn listen(&mut self, event: Event) {
            match event {
                Event::Update => self.tim.dier.write(|w| w.uie().enabled()),
            }
        }
        #[doc = " Stops listening for an `event`"]
        pub fn unlisten(&mut self, event: Event) {
            match event {
                Event::Update => self.tim.dier.write(|w| w.uie().disabled()),
            }
        }
        #[doc = " Stops the timer"]
        pub fn stop(&mut self) {
            self.tim.cr1.modify(|_, w| w.cen().disabled());
        }
        #[doc = " Clears Update Interrupt Flag"]
        pub fn clear_update_interrupt_flag(&mut self) {
            self.tim.sr.modify(|_, w| w.uif().clear());
        }
        #[doc = " Releases the TIM peripheral"]
        pub fn release(mut self) -> TIM7 {
            self.stop();
            self.tim
        }
    }
    impl PclkSrc for TIM8 {
        fn get_clk(clocks: &Clocks) -> Hertz {
            clocks.pclk2()
        }
    }
    impl Periodic for Timer<TIM8> {}
    impl CountDown for Timer<TIM8> {
        type Time = Hertz;
        fn start<T>(&mut self, timeout: T)
        where
            T: Into<Hertz>,
        {
            self.stop();
            let frequency = timeout.into().0;
            let timer_clock = TIM8::get_clk(&self.clocks);
            let ticks = timer_clock.0 * if self.clocks.ppre1() == 1 { 1 } else { 2 } / frequency;
            let psc = u16::try_from((ticks - 1) / (1 << 16)).ok().unwrap();
            self.tim.psc.write(|w| w.psc().bits(psc));
            let arr = u16::try_from(ticks / u32::from(psc + 1)).ok().unwrap();
            self.tim.arr.write(|w| unsafe { w.bits(u32::from(arr)) });
            self.tim.egr.write(|w| w.ug().update());
            self.clear_update_interrupt_flag();
            self.tim.cr1.modify(|_, w| w.cen().enabled());
        }
        fn wait(&mut self) -> nb::Result<(), Void> {
            if self.tim.sr.read().uif().is_clear() {
                Err(nb::Error::WouldBlock)
            } else {
                self.clear_update_interrupt_flag();
                Ok(())
            }
        }
    }
    impl Timer<TIM8> {
        #[doc = " Configures a TIM peripheral as a periodic count down timer"]
        pub fn tim8<T>(tim: TIM8, timeout: T, clocks: Clocks, apb2: &mut APB2) -> Self
        where
            T: Into<Hertz>,
        {
            apb2.enr().modify(|_, w| w.tim8en().enabled());
            apb2.rstr().modify(|_, w| w.tim8rst().reset());
            apb2.rstr().modify(|_, w| w.tim8rst().clear_bit());
            let mut timer = Timer { clocks, tim };
            timer.start(timeout);
            timer
        }
        #[doc = " Starts listening for an `event`"]
        pub fn listen(&mut self, event: Event) {
            match event {
                Event::Update => self.tim.dier.write(|w| w.uie().enabled()),
            }
        }
        #[doc = " Stops listening for an `event`"]
        pub fn unlisten(&mut self, event: Event) {
            match event {
                Event::Update => self.tim.dier.write(|w| w.uie().disabled()),
            }
        }
        #[doc = " Stops the timer"]
        pub fn stop(&mut self) {
            self.tim.cr1.modify(|_, w| w.cen().disabled());
        }
        #[doc = " Clears Update Interrupt Flag"]
        pub fn clear_update_interrupt_flag(&mut self) {
            self.tim.sr.modify(|_, w| w.uif().clear());
        }
        #[doc = " Releases the TIM peripheral"]
        pub fn release(mut self) -> TIM8 {
            self.stop();
            self.tim
        }
    }
    impl PclkSrc for TIM15 {
        fn get_clk(clocks: &Clocks) -> Hertz {
            clocks.pclk2()
        }
    }
    impl Periodic for Timer<TIM15> {}
    impl CountDown for Timer<TIM15> {
        type Time = Hertz;
        fn start<T>(&mut self, timeout: T)
        where
            T: Into<Hertz>,
        {
            self.stop();
            let frequency = timeout.into().0;
            let timer_clock = TIM15::get_clk(&self.clocks);
            let ticks = timer_clock.0 * if self.clocks.ppre1() == 1 { 1 } else { 2 } / frequency;
            let psc = u16::try_from((ticks - 1) / (1 << 16)).ok().unwrap();
            self.tim.psc.write(|w| w.psc().bits(psc));
            let arr = u16::try_from(ticks / u32::from(psc + 1)).ok().unwrap();
            self.tim.arr.write(|w| unsafe { w.bits(u32::from(arr)) });
            self.tim.egr.write(|w| w.ug().update());
            self.clear_update_interrupt_flag();
            self.tim.cr1.modify(|_, w| w.cen().enabled());
        }
        fn wait(&mut self) -> nb::Result<(), Void> {
            if self.tim.sr.read().uif().is_clear() {
                Err(nb::Error::WouldBlock)
            } else {
                self.clear_update_interrupt_flag();
                Ok(())
            }
        }
    }
    impl Timer<TIM15> {
        #[doc = " Configures a TIM peripheral as a periodic count down timer"]
        pub fn tim15<T>(tim: TIM15, timeout: T, clocks: Clocks, apb2: &mut APB2) -> Self
        where
            T: Into<Hertz>,
        {
            apb2.enr().modify(|_, w| w.tim15en().enabled());
            apb2.rstr().modify(|_, w| w.tim15rst().reset());
            apb2.rstr().modify(|_, w| w.tim15rst().clear_bit());
            let mut timer = Timer { clocks, tim };
            timer.start(timeout);
            timer
        }
        #[doc = " Starts listening for an `event`"]
        pub fn listen(&mut self, event: Event) {
            match event {
                Event::Update => self.tim.dier.write(|w| w.uie().enabled()),
            }
        }
        #[doc = " Stops listening for an `event`"]
        pub fn unlisten(&mut self, event: Event) {
            match event {
                Event::Update => self.tim.dier.write(|w| w.uie().disabled()),
            }
        }
        #[doc = " Stops the timer"]
        pub fn stop(&mut self) {
            self.tim.cr1.modify(|_, w| w.cen().disabled());
        }
        #[doc = " Clears Update Interrupt Flag"]
        pub fn clear_update_interrupt_flag(&mut self) {
            self.tim.sr.modify(|_, w| w.uif().clear());
        }
        #[doc = " Releases the TIM peripheral"]
        pub fn release(mut self) -> TIM15 {
            self.stop();
            self.tim
        }
    }
    impl PclkSrc for TIM16 {
        fn get_clk(clocks: &Clocks) -> Hertz {
            clocks.pclk2()
        }
    }
    impl Periodic for Timer<TIM16> {}
    impl CountDown for Timer<TIM16> {
        type Time = Hertz;
        fn start<T>(&mut self, timeout: T)
        where
            T: Into<Hertz>,
        {
            self.stop();
            let frequency = timeout.into().0;
            let timer_clock = TIM16::get_clk(&self.clocks);
            let ticks = timer_clock.0 * if self.clocks.ppre1() == 1 { 1 } else { 2 } / frequency;
            let psc = u16::try_from((ticks - 1) / (1 << 16)).ok().unwrap();
            self.tim.psc.write(|w| w.psc().bits(psc));
            let arr = u16::try_from(ticks / u32::from(psc + 1)).ok().unwrap();
            self.tim.arr.write(|w| unsafe { w.bits(u32::from(arr)) });
            self.tim.egr.write(|w| w.ug().update());
            self.clear_update_interrupt_flag();
            self.tim.cr1.modify(|_, w| w.cen().enabled());
        }
        fn wait(&mut self) -> nb::Result<(), Void> {
            if self.tim.sr.read().uif().is_clear() {
                Err(nb::Error::WouldBlock)
            } else {
                self.clear_update_interrupt_flag();
                Ok(())
            }
        }
    }
    impl Timer<TIM16> {
        #[doc = " Configures a TIM peripheral as a periodic count down timer"]
        pub fn tim16<T>(tim: TIM16, timeout: T, clocks: Clocks, apb2: &mut APB2) -> Self
        where
            T: Into<Hertz>,
        {
            apb2.enr().modify(|_, w| w.tim16en().enabled());
            apb2.rstr().modify(|_, w| w.tim16rst().reset());
            apb2.rstr().modify(|_, w| w.tim16rst().clear_bit());
            let mut timer = Timer { clocks, tim };
            timer.start(timeout);
            timer
        }
        #[doc = " Starts listening for an `event`"]
        pub fn listen(&mut self, event: Event) {
            match event {
                Event::Update => self.tim.dier.write(|w| w.uie().enabled()),
            }
        }
        #[doc = " Stops listening for an `event`"]
        pub fn unlisten(&mut self, event: Event) {
            match event {
                Event::Update => self.tim.dier.write(|w| w.uie().disabled()),
            }
        }
        #[doc = " Stops the timer"]
        pub fn stop(&mut self) {
            self.tim.cr1.modify(|_, w| w.cen().disabled());
        }
        #[doc = " Clears Update Interrupt Flag"]
        pub fn clear_update_interrupt_flag(&mut self) {
            self.tim.sr.modify(|_, w| w.uif().clear());
        }
        #[doc = " Releases the TIM peripheral"]
        pub fn release(mut self) -> TIM16 {
            self.stop();
            self.tim
        }
    }
    impl PclkSrc for TIM17 {
        fn get_clk(clocks: &Clocks) -> Hertz {
            clocks.pclk2()
        }
    }
    impl Periodic for Timer<TIM17> {}
    impl CountDown for Timer<TIM17> {
        type Time = Hertz;
        fn start<T>(&mut self, timeout: T)
        where
            T: Into<Hertz>,
        {
            self.stop();
            let frequency = timeout.into().0;
            let timer_clock = TIM17::get_clk(&self.clocks);
            let ticks = timer_clock.0 * if self.clocks.ppre1() == 1 { 1 } else { 2 } / frequency;
            let psc = u16::try_from((ticks - 1) / (1 << 16)).ok().unwrap();
            self.tim.psc.write(|w| w.psc().bits(psc));
            let arr = u16::try_from(ticks / u32::from(psc + 1)).ok().unwrap();
            self.tim.arr.write(|w| unsafe { w.bits(u32::from(arr)) });
            self.tim.egr.write(|w| w.ug().update());
            self.clear_update_interrupt_flag();
            self.tim.cr1.modify(|_, w| w.cen().enabled());
        }
        fn wait(&mut self) -> nb::Result<(), Void> {
            if self.tim.sr.read().uif().is_clear() {
                Err(nb::Error::WouldBlock)
            } else {
                self.clear_update_interrupt_flag();
                Ok(())
            }
        }
    }
    impl Timer<TIM17> {
        #[doc = " Configures a TIM peripheral as a periodic count down timer"]
        pub fn tim17<T>(tim: TIM17, timeout: T, clocks: Clocks, apb2: &mut APB2) -> Self
        where
            T: Into<Hertz>,
        {
            apb2.enr().modify(|_, w| w.tim17en().enabled());
            apb2.rstr().modify(|_, w| w.tim17rst().reset());
            apb2.rstr().modify(|_, w| w.tim17rst().clear_bit());
            let mut timer = Timer { clocks, tim };
            timer.start(timeout);
            timer
        }
        #[doc = " Starts listening for an `event`"]
        pub fn listen(&mut self, event: Event) {
            match event {
                Event::Update => self.tim.dier.write(|w| w.uie().enabled()),
            }
        }
        #[doc = " Stops listening for an `event`"]
        pub fn unlisten(&mut self, event: Event) {
            match event {
                Event::Update => self.tim.dier.write(|w| w.uie().disabled()),
            }
        }
        #[doc = " Stops the timer"]
        pub fn stop(&mut self) {
            self.tim.cr1.modify(|_, w| w.cen().disabled());
        }
        #[doc = " Clears Update Interrupt Flag"]
        pub fn clear_update_interrupt_flag(&mut self) {
            self.tim.sr.modify(|_, w| w.uif().clear());
        }
        #[doc = " Releases the TIM peripheral"]
        pub fn release(mut self) -> TIM17 {
            self.stop();
            self.tim
        }
    }
    impl PclkSrc for TIM20 {
        fn get_clk(clocks: &Clocks) -> Hertz {
            clocks.pclk2()
        }
    }
    impl Periodic for Timer<TIM20> {}
    impl CountDown for Timer<TIM20> {
        type Time = Hertz;
        fn start<T>(&mut self, timeout: T)
        where
            T: Into<Hertz>,
        {
            self.stop();
            let frequency = timeout.into().0;
            let timer_clock = TIM20::get_clk(&self.clocks);
            let ticks = timer_clock.0 * if self.clocks.ppre1() == 1 { 1 } else { 2 } / frequency;
            let psc = u16::try_from((ticks - 1) / (1 << 16)).ok().unwrap();
            self.tim.psc.write(|w| w.psc().bits(psc));
            let arr = u16::try_from(ticks / u32::from(psc + 1)).ok().unwrap();
            self.tim.arr.write(|w| unsafe { w.bits(u32::from(arr)) });
            self.tim.egr.write(|w| w.ug().update());
            self.clear_update_interrupt_flag();
            self.tim.cr1.modify(|_, w| w.cen().enabled());
        }
        fn wait(&mut self) -> nb::Result<(), Void> {
            if self.tim.sr.read().uif().is_clear() {
                Err(nb::Error::WouldBlock)
            } else {
                self.clear_update_interrupt_flag();
                Ok(())
            }
        }
    }
    impl Timer<TIM20> {
        #[doc = " Configures a TIM peripheral as a periodic count down timer"]
        pub fn tim20<T>(tim: TIM20, timeout: T, clocks: Clocks, apb2: &mut APB2) -> Self
        where
            T: Into<Hertz>,
        {
            apb2.enr().modify(|_, w| w.tim20en().enabled());
            apb2.rstr().modify(|_, w| w.tim20rst().reset());
            apb2.rstr().modify(|_, w| w.tim20rst().clear_bit());
            let mut timer = Timer { clocks, tim };
            timer.start(timeout);
            timer
        }
        #[doc = " Starts listening for an `event`"]
        pub fn listen(&mut self, event: Event) {
            match event {
                Event::Update => self.tim.dier.write(|w| w.uie().enabled()),
            }
        }
        #[doc = " Stops listening for an `event`"]
        pub fn unlisten(&mut self, event: Event) {
            match event {
                Event::Update => self.tim.dier.write(|w| w.uie().disabled()),
            }
        }
        #[doc = " Stops the timer"]
        pub fn stop(&mut self) {
            self.tim.cr1.modify(|_, w| w.cen().disabled());
        }
        #[doc = " Clears Update Interrupt Flag"]
        pub fn clear_update_interrupt_flag(&mut self) {
            self.tim.sr.modify(|_, w| w.uif().clear());
        }
        #[doc = " Releases the TIM peripheral"]
        pub fn release(mut self) -> TIM20 {
            self.stop();
            self.tim
        }
    }
}
#[cfg(feature = "stm32f303")]
pub mod adc {
    #![doc = " API for the ADC (Analog to Digital Converter)"]
    #![doc = ""]
    #![doc = " # Examples"]
    #![doc = ""]
    #![doc = " Check out [examles/adc.rs]."]
    #![doc = ""]
    #![doc = " It can be built for the STM32F3Discovery running"]
    #![doc = " `cargo build --example adc --features=stm32f303xc`"]
    #![doc = ""]
    #![doc = " [examples/adc.rs]: https://github.com/stm32-rs/stm32f3xx-hal/blob/v0.6.0/examples/adc.rs"]
    use crate::{
        gpio::Analog,
        rcc::{Clocks, AHB},
    };
    use cortex_m::asm;
    use embedded_hal::adc::{Channel, OneShot};
    use crate::{
        gpio::{gpioa, gpiob, gpioc},
        pac::{ADC1, ADC1_2, ADC2},
    };
    use stm32f3::stm32f303::{adc1::cfgr::ALIGN_A, adc1_2::ccr::CKMODE_A};
    const MAX_ADVREGEN_STARTUP_US: u32 = 10;
    #[cfg(any(
        feature = "stm32f303xb",
        feature = "stm32f303xc",
        feature = "stm32f303xd",
        feature = "stm32f303xe",
    ))]
    use crate::{
        gpio::{gpiod, gpioe, gpiof},
        pac::{ADC3, ADC3_4, ADC4},
    };
    #[doc = " Analog Digital Converter Peripheral"]
    pub struct Adc<ADC> {
        #[doc = " ADC Register"]
        pub rb: ADC,
        clocks: Clocks,
        ckmode: CkMode,
        operation_mode: Option<OperationMode>,
    }
    #[doc = " ADC sampling time"]
    #[doc = ""]
    #[doc = " Each channel can be sampled with a different sample time."]
    #[doc = " There is always an overhead of 13 ADC clock cycles."]
    #[doc = " E.g. For Sampletime T_19 the total conversion time (in ADC clock cycles) is"]
    #[doc = " 13 + 19 = 32 ADC Clock Cycles"]
    pub enum SampleTime {
        #[doc = " 1.5 ADC clock cycles"]
        T_1,
        #[doc = " 2.5 ADC clock cycles"]
        T_2,
        #[doc = " 4.5 ADC clock cycles"]
        T_4,
        #[doc = " 7.5 ADC clock cycles"]
        T_7,
        #[doc = " 19.5 ADC clock cycles"]
        T_19,
        #[doc = " 61.5 ADC clock cycles"]
        T_61,
        #[doc = " 181.5 ADC clock cycles"]
        T_181,
        #[doc = " 601.5 ADC clock cycles"]
        T_601,
    }
    impl Default for SampleTime {
        #[doc = " T_1 is also the reset value."]
        fn default() -> Self {
            SampleTime::T_1
        }
    }
    impl SampleTime {
        #[doc = " Conversion to bits for SMP"]
        fn bitcode(&self) -> u8 {
            match self {
                SampleTime::T_1 => 0b000,
                SampleTime::T_2 => 0b001,
                SampleTime::T_4 => 0b010,
                SampleTime::T_7 => 0b011,
                SampleTime::T_19 => 0b100,
                SampleTime::T_61 => 0b101,
                SampleTime::T_181 => 0b110,
                SampleTime::T_601 => 0b111,
            }
        }
    }
    #[doc = " ADC operation mode"]
    pub enum OperationMode {
        #[doc = " OneShot Mode"]
        OneShot,
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::clone::Clone for OperationMode {
        #[inline]
        fn clone(&self) -> OperationMode {
            {
                *self
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::marker::Copy for OperationMode {}
    impl ::core::marker::StructuralPartialEq for OperationMode {}
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::cmp::PartialEq for OperationMode {
        #[inline]
        fn eq(&self, other: &OperationMode) -> bool {
            match (&*self, &*other) {
                _ => true,
            }
        }
    }
    #[doc = " ADC CkMode"]
    pub enum CkMode {
        #[doc = " Use AHB clock rcc_hclk3. In this case rcc_hclk must equal sys_d1cpre_ck"]
        SYNCDIV1 = 1,
        #[doc = " Use AHB clock rcc_hclk3 divided by 2"]
        SYNCDIV2 = 2,
        #[doc = " Use AHB clock rcc_hclk3 divided by 4"]
        SYNCDIV4 = 4,
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::clone::Clone for CkMode {
        #[inline]
        fn clone(&self) -> CkMode {
            {
                *self
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::marker::Copy for CkMode {}
    impl ::core::marker::StructuralPartialEq for CkMode {}
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::cmp::PartialEq for CkMode {
        #[inline]
        fn eq(&self, other: &CkMode) -> bool {
            {
                let __self_vi = ::core::intrinsics::discriminant_value(&*self);
                let __arg_1_vi = ::core::intrinsics::discriminant_value(&*other);
                if true && __self_vi == __arg_1_vi {
                    match (&*self, &*other) {
                        _ => true,
                    }
                } else {
                    false
                }
            }
        }
    }
    impl Default for CkMode {
        fn default() -> Self {
            CkMode::SYNCDIV2
        }
    }
    impl From<CkMode> for CKMODE_A {
        fn from(ckmode: CkMode) -> Self {
            match ckmode {
                CkMode::SYNCDIV1 => CKMODE_A::SYNCDIV1,
                CkMode::SYNCDIV2 => CKMODE_A::SYNCDIV2,
                CkMode::SYNCDIV4 => CKMODE_A::SYNCDIV4,
            }
        }
    }
    #[doc = " ADC data register alignment"]
    pub enum Align {
        #[doc = " Right alignment of output data"]
        Right,
        #[doc = " Left alignment of output data"]
        Left,
    }
    impl Default for Align {
        fn default() -> Self {
            Align::Right
        }
    }
    impl From<Align> for ALIGN_A {
        fn from(align: Align) -> ALIGN_A {
            match align {
                Align::Right => ALIGN_A::RIGHT,
                Align::Left => ALIGN_A::LEFT,
            }
        }
    }
    impl Channel<ADC1> for gpioa::PA0<Analog> {
        type ID = u8;
        fn channel() -> u8 {
            1
        }
    }
    impl Channel<ADC1> for gpioa::PA1<Analog> {
        type ID = u8;
        fn channel() -> u8 {
            2
        }
    }
    impl Channel<ADC1> for gpioa::PA2<Analog> {
        type ID = u8;
        fn channel() -> u8 {
            3
        }
    }
    impl Channel<ADC1> for gpioa::PA3<Analog> {
        type ID = u8;
        fn channel() -> u8 {
            4
        }
    }
    impl Channel<ADC1> for gpioc::PC0<Analog> {
        type ID = u8;
        fn channel() -> u8 {
            6
        }
    }
    impl Channel<ADC1> for gpioc::PC1<Analog> {
        type ID = u8;
        fn channel() -> u8 {
            7
        }
    }
    impl Channel<ADC1> for gpioc::PC2<Analog> {
        type ID = u8;
        fn channel() -> u8 {
            8
        }
    }
    impl Channel<ADC1> for gpioc::PC3<Analog> {
        type ID = u8;
        fn channel() -> u8 {
            9
        }
    }
    impl Channel<ADC1> for gpiof::PF4<Analog> {
        type ID = u8;
        fn channel() -> u8 {
            5
        }
    }
    impl Channel<ADC1> for gpiof::PF2<Analog> {
        type ID = u8;
        fn channel() -> u8 {
            10
        }
    }
    impl Channel<ADC2> for gpioa::PA4<Analog> {
        type ID = u8;
        fn channel() -> u8 {
            1
        }
    }
    impl Channel<ADC2> for gpioa::PA5<Analog> {
        type ID = u8;
        fn channel() -> u8 {
            2
        }
    }
    impl Channel<ADC2> for gpioa::PA6<Analog> {
        type ID = u8;
        fn channel() -> u8 {
            3
        }
    }
    impl Channel<ADC2> for gpioa::PA7<Analog> {
        type ID = u8;
        fn channel() -> u8 {
            4
        }
    }
    impl Channel<ADC2> for gpioc::PC4<Analog> {
        type ID = u8;
        fn channel() -> u8 {
            5
        }
    }
    impl Channel<ADC2> for gpioc::PC0<Analog> {
        type ID = u8;
        fn channel() -> u8 {
            6
        }
    }
    impl Channel<ADC2> for gpioc::PC1<Analog> {
        type ID = u8;
        fn channel() -> u8 {
            7
        }
    }
    impl Channel<ADC2> for gpioc::PC2<Analog> {
        type ID = u8;
        fn channel() -> u8 {
            8
        }
    }
    impl Channel<ADC2> for gpioc::PC3<Analog> {
        type ID = u8;
        fn channel() -> u8 {
            9
        }
    }
    impl Channel<ADC2> for gpioc::PC5<Analog> {
        type ID = u8;
        fn channel() -> u8 {
            11
        }
    }
    impl Channel<ADC2> for gpiob::PB2<Analog> {
        type ID = u8;
        fn channel() -> u8 {
            12
        }
    }
    impl Channel<ADC2> for gpiof::PF2<Analog> {
        type ID = u8;
        fn channel() -> u8 {
            10
        }
    }
    impl Channel<ADC3> for gpiob::PB1<Analog> {
        type ID = u8;
        fn channel() -> u8 {
            1
        }
    }
    impl Channel<ADC3> for gpioe::PE9<Analog> {
        type ID = u8;
        fn channel() -> u8 {
            2
        }
    }
    impl Channel<ADC3> for gpioe::PE13<Analog> {
        type ID = u8;
        fn channel() -> u8 {
            3
        }
    }
    impl Channel<ADC3> for gpiob::PB13<Analog> {
        type ID = u8;
        fn channel() -> u8 {
            5
        }
    }
    impl Channel<ADC3> for gpioe::PE8<Analog> {
        type ID = u8;
        fn channel() -> u8 {
            6
        }
    }
    impl Channel<ADC3> for gpiod::PD10<Analog> {
        type ID = u8;
        fn channel() -> u8 {
            7
        }
    }
    impl Channel<ADC3> for gpiod::PD11<Analog> {
        type ID = u8;
        fn channel() -> u8 {
            8
        }
    }
    impl Channel<ADC3> for gpiod::PD12<Analog> {
        type ID = u8;
        fn channel() -> u8 {
            9
        }
    }
    impl Channel<ADC3> for gpiod::PD13<Analog> {
        type ID = u8;
        fn channel() -> u8 {
            10
        }
    }
    impl Channel<ADC3> for gpiod::PD14<Analog> {
        type ID = u8;
        fn channel() -> u8 {
            11
        }
    }
    impl Channel<ADC3> for gpiob::PB0<Analog> {
        type ID = u8;
        fn channel() -> u8 {
            12
        }
    }
    impl Channel<ADC3> for gpioe::PE7<Analog> {
        type ID = u8;
        fn channel() -> u8 {
            13
        }
    }
    impl Channel<ADC3> for gpioe::PE10<Analog> {
        type ID = u8;
        fn channel() -> u8 {
            14
        }
    }
    impl Channel<ADC3> for gpioe::PE11<Analog> {
        type ID = u8;
        fn channel() -> u8 {
            15
        }
    }
    impl Channel<ADC3> for gpioe::PE12<Analog> {
        type ID = u8;
        fn channel() -> u8 {
            16
        }
    }
    impl Channel<ADC4> for gpioe::PE14<Analog> {
        type ID = u8;
        fn channel() -> u8 {
            1
        }
    }
    impl Channel<ADC4> for gpioe::PE15<Analog> {
        type ID = u8;
        fn channel() -> u8 {
            2
        }
    }
    impl Channel<ADC4> for gpiob::PB12<Analog> {
        type ID = u8;
        fn channel() -> u8 {
            3
        }
    }
    impl Channel<ADC4> for gpiob::PB14<Analog> {
        type ID = u8;
        fn channel() -> u8 {
            4
        }
    }
    impl Channel<ADC4> for gpiob::PB15<Analog> {
        type ID = u8;
        fn channel() -> u8 {
            5
        }
    }
    impl Channel<ADC4> for gpioe::PE8<Analog> {
        type ID = u8;
        fn channel() -> u8 {
            6
        }
    }
    impl Channel<ADC4> for gpiod::PD10<Analog> {
        type ID = u8;
        fn channel() -> u8 {
            7
        }
    }
    impl Channel<ADC4> for gpiod::PD11<Analog> {
        type ID = u8;
        fn channel() -> u8 {
            8
        }
    }
    impl Channel<ADC4> for gpiod::PD12<Analog> {
        type ID = u8;
        fn channel() -> u8 {
            9
        }
    }
    impl Channel<ADC4> for gpiod::PD13<Analog> {
        type ID = u8;
        fn channel() -> u8 {
            10
        }
    }
    impl Channel<ADC4> for gpiod::PD14<Analog> {
        type ID = u8;
        fn channel() -> u8 {
            11
        }
    }
    impl Channel<ADC4> for gpiod::PD8<Analog> {
        type ID = u8;
        fn channel() -> u8 {
            12
        }
    }
    impl Channel<ADC4> for gpiod::PD9<Analog> {
        type ID = u8;
        fn channel() -> u8 {
            13
        }
    }
    impl Adc<ADC1> {
        #[doc = " Returns true iff"]
        #[doc = "     the clock can be enabled with the given settings"]
        #[doc = "  or the clock was already enabled with the same settings"]
        fn enable_clock(&self, ahb: &mut AHB, adc_common: &mut ADC1_2) -> bool {
            if ahb.enr().read().adc12en().is_enabled() {
                return (adc_common.ccr.read().ckmode().variant() == self.ckmode.into());
            }
            ahb.enr().modify(|_, w| w.adc12en().enabled());
            adc_common
                .ccr
                .modify(|_, w| w.ckmode().variant(self.ckmode.into()));
            true
        }
    }
    impl Adc<ADC1> {
        #[doc = " Init a new ADC"]
        #[doc = ""]
        #[doc = " Enables the clock, performs a calibration and enables the ADC"]
        #[doc = ""]
        #[doc = " # Panics"]
        #[doc = " If one of the following occurs:"]
        #[doc = " * the clocksetting is not well defined."]
        #[doc = " * the clock was already enabled with a different setting"]
        #[doc = ""]
        pub fn adc1(
            rb: ADC1,
            adc_common: &mut ADC1_2,
            ahb: &mut AHB,
            ckmode: CkMode,
            clocks: Clocks,
        ) -> Self {
            let mut this_adc = Self {
                rb,
                clocks,
                ckmode,
                operation_mode: None,
            };
            if !(this_adc.clocks_welldefined(clocks)) {
                ::core::panicking::panic("Clock settings not well defined");
            }
            if !(this_adc.enable_clock(ahb, adc_common)) {
                ::core::panicking::panic("Clock already enabled with a different setting");
            }
            this_adc.set_align(Align::default());
            this_adc.calibrate();
            this_adc.wait_adc_clk_cycles(4);
            this_adc.enable();
            this_adc
        }
        #[doc = " Software can use CkMode::SYNCDIV1 only if"]
        #[doc = " hclk and sysclk are the same. (see reference manual 15.3.3)"]
        fn clocks_welldefined(&self, clocks: Clocks) -> bool {
            if (self.ckmode == CkMode::SYNCDIV1) {
                clocks.hclk().0 == clocks.sysclk().0
            } else {
                true
            }
        }
        #[doc = " sets up adc in one shot mode for a single channel"]
        pub fn setup_oneshot(&mut self) {
            self.rb.cr.modify(|_, w| w.adstp().stop());
            self.rb.isr.modify(|_, w| w.ovr().clear());
            self.rb
                .cfgr
                .modify(|_, w| w.cont().single().ovrmod().preserve());
            self.set_sequence_len(1);
            self.operation_mode = Some(OperationMode::OneShot);
        }
        fn set_sequence_len(&mut self, len: u8) {
            if !(len - 1 < 16) {
                ::core::panicking::panic("ADC sequence length must be in 1..=16")
            };
            self.rb.sqr1.modify(|_, w| w.l().bits(len - 1));
        }
        fn set_align(&self, align: Align) {
            self.rb.cfgr.modify(|_, w| w.align().variant(align.into()));
        }
        fn enable(&mut self) {
            self.rb.cr.modify(|_, w| w.aden().enable());
            while self.rb.isr.read().adrdy().is_not_ready() {}
        }
        fn disable(&mut self) {
            self.rb.cr.modify(|_, w| w.addis().disable());
        }
        #[doc = " Calibrate according to 15.3.8 in the Reference Manual"]
        fn calibrate(&mut self) {
            if !self.rb.cr.read().advregen().is_enabled() {
                self.advregen_enable();
                self.wait_advregen_startup();
            }
            self.disable();
            self.rb
                .cr
                .modify(|_, w| w.adcaldif().single_ended().adcal().calibration());
            while self.rb.cr.read().adcal().is_calibration() {}
        }
        fn wait_adc_clk_cycles(&self, cycles: u32) {
            let adc_clk_cycle = self.clocks.hclk().0 / (self.ckmode as u32);
            asm::delay(adc_clk_cycle * cycles);
        }
        fn advregen_enable(&mut self) {
            self.rb.cr.modify(|_, w| w.advregen().intermediate());
            self.rb.cr.modify(|_, w| w.advregen().enabled());
        }
        #[doc = " wait for the advregen to startup."]
        #[doc = ""]
        #[doc = " This is based on the MAX_ADVREGEN_STARTUP_US of the device."]
        fn wait_advregen_startup(&self) {
            asm::delay((MAX_ADVREGEN_STARTUP_US * 1_000_000) / self.clocks.sysclk().0);
        }
        #[doc = " busy ADC read"]
        fn convert_one(&mut self, chan: u8) -> u16 {
            self.ensure_oneshot();
            self.set_chan_smps(chan, SampleTime::default());
            self.select_single_chan(chan);
            self.rb.cr.modify(|_, w| w.adstart().start());
            while self.rb.isr.read().eos().is_not_complete() {}
            self.rb.isr.modify(|_, w| w.eos().clear());
            return self.rb.dr.read().rdata().bits();
        }
        fn ensure_oneshot(&mut self) {
            if self.operation_mode != Some(OperationMode::OneShot) {
                self.setup_oneshot();
            }
        }
        #[doc = " This should only be invoked with the defined channels for the particular"]
        #[doc = " device. (See Pin/Channel mapping above)"]
        fn select_single_chan(&self, chan: u8) {
            self.rb.sqr1.modify(|_, w| unsafe { w.sq1().bits(chan) });
        }
        #[doc = " Note: only allowed when ADSTART = 0"]
        fn set_chan_smps(&self, chan: u8, smp: SampleTime) {
            match chan {
                1 => self.rb.smpr1.modify(|_, w| w.smp1().bits(smp.bitcode())),
                2 => self.rb.smpr1.modify(|_, w| w.smp2().bits(smp.bitcode())),
                3 => self.rb.smpr1.modify(|_, w| w.smp3().bits(smp.bitcode())),
                4 => self.rb.smpr1.modify(|_, w| w.smp4().bits(smp.bitcode())),
                5 => self.rb.smpr1.modify(|_, w| w.smp5().bits(smp.bitcode())),
                6 => self.rb.smpr1.modify(|_, w| w.smp6().bits(smp.bitcode())),
                7 => self.rb.smpr1.modify(|_, w| w.smp7().bits(smp.bitcode())),
                8 => self.rb.smpr1.modify(|_, w| w.smp8().bits(smp.bitcode())),
                9 => self.rb.smpr1.modify(|_, w| w.smp9().bits(smp.bitcode())),
                11 => self.rb.smpr2.modify(|_, w| w.smp10().bits(smp.bitcode())),
                12 => self.rb.smpr2.modify(|_, w| w.smp12().bits(smp.bitcode())),
                13 => self.rb.smpr2.modify(|_, w| w.smp13().bits(smp.bitcode())),
                14 => self.rb.smpr2.modify(|_, w| w.smp14().bits(smp.bitcode())),
                15 => self.rb.smpr2.modify(|_, w| w.smp15().bits(smp.bitcode())),
                16 => self.rb.smpr2.modify(|_, w| w.smp16().bits(smp.bitcode())),
                17 => self.rb.smpr2.modify(|_, w| w.smp17().bits(smp.bitcode())),
                18 => self.rb.smpr2.modify(|_, w| w.smp18().bits(smp.bitcode())),
                _ => ::core::panicking::panic("internal error: entered unreachable code"),
            };
        }
    }
    impl<WORD, PIN> OneShot<ADC1, WORD, PIN> for Adc<ADC1>
    where
        WORD: From<u16>,
        PIN: Channel<ADC1, ID = u8>,
    {
        type Error = ();
        fn read(&mut self, _pin: &mut PIN) -> nb::Result<WORD, Self::Error> {
            let res = self.convert_one(PIN::channel());
            return Ok(res.into());
        }
    }
    impl Adc<ADC2> {
        #[doc = " Returns true iff"]
        #[doc = "     the clock can be enabled with the given settings"]
        #[doc = "  or the clock was already enabled with the same settings"]
        fn enable_clock(&self, ahb: &mut AHB, adc_common: &mut ADC1_2) -> bool {
            if ahb.enr().read().adc12en().is_enabled() {
                return (adc_common.ccr.read().ckmode().variant() == self.ckmode.into());
            }
            ahb.enr().modify(|_, w| w.adc12en().enabled());
            adc_common
                .ccr
                .modify(|_, w| w.ckmode().variant(self.ckmode.into()));
            true
        }
    }
    impl Adc<ADC2> {
        #[doc = " Init a new ADC"]
        #[doc = ""]
        #[doc = " Enables the clock, performs a calibration and enables the ADC"]
        #[doc = ""]
        #[doc = " # Panics"]
        #[doc = " If one of the following occurs:"]
        #[doc = " * the clocksetting is not well defined."]
        #[doc = " * the clock was already enabled with a different setting"]
        #[doc = ""]
        pub fn adc2(
            rb: ADC2,
            adc_common: &mut ADC1_2,
            ahb: &mut AHB,
            ckmode: CkMode,
            clocks: Clocks,
        ) -> Self {
            let mut this_adc = Self {
                rb,
                clocks,
                ckmode,
                operation_mode: None,
            };
            if !(this_adc.clocks_welldefined(clocks)) {
                ::core::panicking::panic("Clock settings not well defined");
            }
            if !(this_adc.enable_clock(ahb, adc_common)) {
                ::core::panicking::panic("Clock already enabled with a different setting");
            }
            this_adc.set_align(Align::default());
            this_adc.calibrate();
            this_adc.wait_adc_clk_cycles(4);
            this_adc.enable();
            this_adc
        }
        #[doc = " Software can use CkMode::SYNCDIV1 only if"]
        #[doc = " hclk and sysclk are the same. (see reference manual 15.3.3)"]
        fn clocks_welldefined(&self, clocks: Clocks) -> bool {
            if (self.ckmode == CkMode::SYNCDIV1) {
                clocks.hclk().0 == clocks.sysclk().0
            } else {
                true
            }
        }
        #[doc = " sets up adc in one shot mode for a single channel"]
        pub fn setup_oneshot(&mut self) {
            self.rb.cr.modify(|_, w| w.adstp().stop());
            self.rb.isr.modify(|_, w| w.ovr().clear());
            self.rb
                .cfgr
                .modify(|_, w| w.cont().single().ovrmod().preserve());
            self.set_sequence_len(1);
            self.operation_mode = Some(OperationMode::OneShot);
        }
        fn set_sequence_len(&mut self, len: u8) {
            if !(len - 1 < 16) {
                ::core::panicking::panic("ADC sequence length must be in 1..=16")
            };
            self.rb.sqr1.modify(|_, w| w.l().bits(len - 1));
        }
        fn set_align(&self, align: Align) {
            self.rb.cfgr.modify(|_, w| w.align().variant(align.into()));
        }
        fn enable(&mut self) {
            self.rb.cr.modify(|_, w| w.aden().enable());
            while self.rb.isr.read().adrdy().is_not_ready() {}
        }
        fn disable(&mut self) {
            self.rb.cr.modify(|_, w| w.addis().disable());
        }
        #[doc = " Calibrate according to 15.3.8 in the Reference Manual"]
        fn calibrate(&mut self) {
            if !self.rb.cr.read().advregen().is_enabled() {
                self.advregen_enable();
                self.wait_advregen_startup();
            }
            self.disable();
            self.rb
                .cr
                .modify(|_, w| w.adcaldif().single_ended().adcal().calibration());
            while self.rb.cr.read().adcal().is_calibration() {}
        }
        fn wait_adc_clk_cycles(&self, cycles: u32) {
            let adc_clk_cycle = self.clocks.hclk().0 / (self.ckmode as u32);
            asm::delay(adc_clk_cycle * cycles);
        }
        fn advregen_enable(&mut self) {
            self.rb.cr.modify(|_, w| w.advregen().intermediate());
            self.rb.cr.modify(|_, w| w.advregen().enabled());
        }
        #[doc = " wait for the advregen to startup."]
        #[doc = ""]
        #[doc = " This is based on the MAX_ADVREGEN_STARTUP_US of the device."]
        fn wait_advregen_startup(&self) {
            asm::delay((MAX_ADVREGEN_STARTUP_US * 1_000_000) / self.clocks.sysclk().0);
        }
        #[doc = " busy ADC read"]
        fn convert_one(&mut self, chan: u8) -> u16 {
            self.ensure_oneshot();
            self.set_chan_smps(chan, SampleTime::default());
            self.select_single_chan(chan);
            self.rb.cr.modify(|_, w| w.adstart().start());
            while self.rb.isr.read().eos().is_not_complete() {}
            self.rb.isr.modify(|_, w| w.eos().clear());
            return self.rb.dr.read().rdata().bits();
        }
        fn ensure_oneshot(&mut self) {
            if self.operation_mode != Some(OperationMode::OneShot) {
                self.setup_oneshot();
            }
        }
        #[doc = " This should only be invoked with the defined channels for the particular"]
        #[doc = " device. (See Pin/Channel mapping above)"]
        fn select_single_chan(&self, chan: u8) {
            self.rb.sqr1.modify(|_, w| unsafe { w.sq1().bits(chan) });
        }
        #[doc = " Note: only allowed when ADSTART = 0"]
        fn set_chan_smps(&self, chan: u8, smp: SampleTime) {
            match chan {
                1 => self.rb.smpr1.modify(|_, w| w.smp1().bits(smp.bitcode())),
                2 => self.rb.smpr1.modify(|_, w| w.smp2().bits(smp.bitcode())),
                3 => self.rb.smpr1.modify(|_, w| w.smp3().bits(smp.bitcode())),
                4 => self.rb.smpr1.modify(|_, w| w.smp4().bits(smp.bitcode())),
                5 => self.rb.smpr1.modify(|_, w| w.smp5().bits(smp.bitcode())),
                6 => self.rb.smpr1.modify(|_, w| w.smp6().bits(smp.bitcode())),
                7 => self.rb.smpr1.modify(|_, w| w.smp7().bits(smp.bitcode())),
                8 => self.rb.smpr1.modify(|_, w| w.smp8().bits(smp.bitcode())),
                9 => self.rb.smpr1.modify(|_, w| w.smp9().bits(smp.bitcode())),
                11 => self.rb.smpr2.modify(|_, w| w.smp10().bits(smp.bitcode())),
                12 => self.rb.smpr2.modify(|_, w| w.smp12().bits(smp.bitcode())),
                13 => self.rb.smpr2.modify(|_, w| w.smp13().bits(smp.bitcode())),
                14 => self.rb.smpr2.modify(|_, w| w.smp14().bits(smp.bitcode())),
                15 => self.rb.smpr2.modify(|_, w| w.smp15().bits(smp.bitcode())),
                16 => self.rb.smpr2.modify(|_, w| w.smp16().bits(smp.bitcode())),
                17 => self.rb.smpr2.modify(|_, w| w.smp17().bits(smp.bitcode())),
                18 => self.rb.smpr2.modify(|_, w| w.smp18().bits(smp.bitcode())),
                _ => ::core::panicking::panic("internal error: entered unreachable code"),
            };
        }
    }
    impl<WORD, PIN> OneShot<ADC2, WORD, PIN> for Adc<ADC2>
    where
        WORD: From<u16>,
        PIN: Channel<ADC2, ID = u8>,
    {
        type Error = ();
        fn read(&mut self, _pin: &mut PIN) -> nb::Result<WORD, Self::Error> {
            let res = self.convert_one(PIN::channel());
            return Ok(res.into());
        }
    }
    impl Adc<ADC3> {
        #[doc = " Returns true iff"]
        #[doc = "     the clock can be enabled with the given settings"]
        #[doc = "  or the clock was already enabled with the same settings"]
        fn enable_clock(&self, ahb: &mut AHB, adc_common: &mut ADC3_4) -> bool {
            if ahb.enr().read().adc34en().is_enabled() {
                return (adc_common.ccr.read().ckmode().variant() == self.ckmode.into());
            }
            ahb.enr().modify(|_, w| w.adc34en().enabled());
            adc_common
                .ccr
                .modify(|_, w| w.ckmode().variant(self.ckmode.into()));
            true
        }
    }
    impl Adc<ADC3> {
        #[doc = " Init a new ADC"]
        #[doc = ""]
        #[doc = " Enables the clock, performs a calibration and enables the ADC"]
        #[doc = ""]
        #[doc = " # Panics"]
        #[doc = " If one of the following occurs:"]
        #[doc = " * the clocksetting is not well defined."]
        #[doc = " * the clock was already enabled with a different setting"]
        #[doc = ""]
        pub fn adc3(
            rb: ADC3,
            adc_common: &mut ADC3_4,
            ahb: &mut AHB,
            ckmode: CkMode,
            clocks: Clocks,
        ) -> Self {
            let mut this_adc = Self {
                rb,
                clocks,
                ckmode,
                operation_mode: None,
            };
            if !(this_adc.clocks_welldefined(clocks)) {
                ::core::panicking::panic("Clock settings not well defined");
            }
            if !(this_adc.enable_clock(ahb, adc_common)) {
                ::core::panicking::panic("Clock already enabled with a different setting");
            }
            this_adc.set_align(Align::default());
            this_adc.calibrate();
            this_adc.wait_adc_clk_cycles(4);
            this_adc.enable();
            this_adc
        }
        #[doc = " Software can use CkMode::SYNCDIV1 only if"]
        #[doc = " hclk and sysclk are the same. (see reference manual 15.3.3)"]
        fn clocks_welldefined(&self, clocks: Clocks) -> bool {
            if (self.ckmode == CkMode::SYNCDIV1) {
                clocks.hclk().0 == clocks.sysclk().0
            } else {
                true
            }
        }
        #[doc = " sets up adc in one shot mode for a single channel"]
        pub fn setup_oneshot(&mut self) {
            self.rb.cr.modify(|_, w| w.adstp().stop());
            self.rb.isr.modify(|_, w| w.ovr().clear());
            self.rb
                .cfgr
                .modify(|_, w| w.cont().single().ovrmod().preserve());
            self.set_sequence_len(1);
            self.operation_mode = Some(OperationMode::OneShot);
        }
        fn set_sequence_len(&mut self, len: u8) {
            if !(len - 1 < 16) {
                ::core::panicking::panic("ADC sequence length must be in 1..=16")
            };
            self.rb.sqr1.modify(|_, w| w.l().bits(len - 1));
        }
        fn set_align(&self, align: Align) {
            self.rb.cfgr.modify(|_, w| w.align().variant(align.into()));
        }
        fn enable(&mut self) {
            self.rb.cr.modify(|_, w| w.aden().enable());
            while self.rb.isr.read().adrdy().is_not_ready() {}
        }
        fn disable(&mut self) {
            self.rb.cr.modify(|_, w| w.addis().disable());
        }
        #[doc = " Calibrate according to 15.3.8 in the Reference Manual"]
        fn calibrate(&mut self) {
            if !self.rb.cr.read().advregen().is_enabled() {
                self.advregen_enable();
                self.wait_advregen_startup();
            }
            self.disable();
            self.rb
                .cr
                .modify(|_, w| w.adcaldif().single_ended().adcal().calibration());
            while self.rb.cr.read().adcal().is_calibration() {}
        }
        fn wait_adc_clk_cycles(&self, cycles: u32) {
            let adc_clk_cycle = self.clocks.hclk().0 / (self.ckmode as u32);
            asm::delay(adc_clk_cycle * cycles);
        }
        fn advregen_enable(&mut self) {
            self.rb.cr.modify(|_, w| w.advregen().intermediate());
            self.rb.cr.modify(|_, w| w.advregen().enabled());
        }
        #[doc = " wait for the advregen to startup."]
        #[doc = ""]
        #[doc = " This is based on the MAX_ADVREGEN_STARTUP_US of the device."]
        fn wait_advregen_startup(&self) {
            asm::delay((MAX_ADVREGEN_STARTUP_US * 1_000_000) / self.clocks.sysclk().0);
        }
        #[doc = " busy ADC read"]
        fn convert_one(&mut self, chan: u8) -> u16 {
            self.ensure_oneshot();
            self.set_chan_smps(chan, SampleTime::default());
            self.select_single_chan(chan);
            self.rb.cr.modify(|_, w| w.adstart().start());
            while self.rb.isr.read().eos().is_not_complete() {}
            self.rb.isr.modify(|_, w| w.eos().clear());
            return self.rb.dr.read().rdata().bits();
        }
        fn ensure_oneshot(&mut self) {
            if self.operation_mode != Some(OperationMode::OneShot) {
                self.setup_oneshot();
            }
        }
        #[doc = " This should only be invoked with the defined channels for the particular"]
        #[doc = " device. (See Pin/Channel mapping above)"]
        fn select_single_chan(&self, chan: u8) {
            self.rb.sqr1.modify(|_, w| unsafe { w.sq1().bits(chan) });
        }
        #[doc = " Note: only allowed when ADSTART = 0"]
        fn set_chan_smps(&self, chan: u8, smp: SampleTime) {
            match chan {
                1 => self.rb.smpr1.modify(|_, w| w.smp1().bits(smp.bitcode())),
                2 => self.rb.smpr1.modify(|_, w| w.smp2().bits(smp.bitcode())),
                3 => self.rb.smpr1.modify(|_, w| w.smp3().bits(smp.bitcode())),
                4 => self.rb.smpr1.modify(|_, w| w.smp4().bits(smp.bitcode())),
                5 => self.rb.smpr1.modify(|_, w| w.smp5().bits(smp.bitcode())),
                6 => self.rb.smpr1.modify(|_, w| w.smp6().bits(smp.bitcode())),
                7 => self.rb.smpr1.modify(|_, w| w.smp7().bits(smp.bitcode())),
                8 => self.rb.smpr1.modify(|_, w| w.smp8().bits(smp.bitcode())),
                9 => self.rb.smpr1.modify(|_, w| w.smp9().bits(smp.bitcode())),
                11 => self.rb.smpr2.modify(|_, w| w.smp10().bits(smp.bitcode())),
                12 => self.rb.smpr2.modify(|_, w| w.smp12().bits(smp.bitcode())),
                13 => self.rb.smpr2.modify(|_, w| w.smp13().bits(smp.bitcode())),
                14 => self.rb.smpr2.modify(|_, w| w.smp14().bits(smp.bitcode())),
                15 => self.rb.smpr2.modify(|_, w| w.smp15().bits(smp.bitcode())),
                16 => self.rb.smpr2.modify(|_, w| w.smp16().bits(smp.bitcode())),
                17 => self.rb.smpr2.modify(|_, w| w.smp17().bits(smp.bitcode())),
                18 => self.rb.smpr2.modify(|_, w| w.smp18().bits(smp.bitcode())),
                _ => ::core::panicking::panic("internal error: entered unreachable code"),
            };
        }
    }
    impl<WORD, PIN> OneShot<ADC3, WORD, PIN> for Adc<ADC3>
    where
        WORD: From<u16>,
        PIN: Channel<ADC3, ID = u8>,
    {
        type Error = ();
        fn read(&mut self, _pin: &mut PIN) -> nb::Result<WORD, Self::Error> {
            let res = self.convert_one(PIN::channel());
            return Ok(res.into());
        }
    }
    impl Adc<ADC4> {
        #[doc = " Returns true iff"]
        #[doc = "     the clock can be enabled with the given settings"]
        #[doc = "  or the clock was already enabled with the same settings"]
        fn enable_clock(&self, ahb: &mut AHB, adc_common: &mut ADC3_4) -> bool {
            if ahb.enr().read().adc34en().is_enabled() {
                return (adc_common.ccr.read().ckmode().variant() == self.ckmode.into());
            }
            ahb.enr().modify(|_, w| w.adc34en().enabled());
            adc_common
                .ccr
                .modify(|_, w| w.ckmode().variant(self.ckmode.into()));
            true
        }
    }
    impl Adc<ADC4> {
        #[doc = " Init a new ADC"]
        #[doc = ""]
        #[doc = " Enables the clock, performs a calibration and enables the ADC"]
        #[doc = ""]
        #[doc = " # Panics"]
        #[doc = " If one of the following occurs:"]
        #[doc = " * the clocksetting is not well defined."]
        #[doc = " * the clock was already enabled with a different setting"]
        #[doc = ""]
        pub fn adc4(
            rb: ADC4,
            adc_common: &mut ADC3_4,
            ahb: &mut AHB,
            ckmode: CkMode,
            clocks: Clocks,
        ) -> Self {
            let mut this_adc = Self {
                rb,
                clocks,
                ckmode,
                operation_mode: None,
            };
            if !(this_adc.clocks_welldefined(clocks)) {
                ::core::panicking::panic("Clock settings not well defined");
            }
            if !(this_adc.enable_clock(ahb, adc_common)) {
                ::core::panicking::panic("Clock already enabled with a different setting");
            }
            this_adc.set_align(Align::default());
            this_adc.calibrate();
            this_adc.wait_adc_clk_cycles(4);
            this_adc.enable();
            this_adc
        }
        #[doc = " Software can use CkMode::SYNCDIV1 only if"]
        #[doc = " hclk and sysclk are the same. (see reference manual 15.3.3)"]
        fn clocks_welldefined(&self, clocks: Clocks) -> bool {
            if (self.ckmode == CkMode::SYNCDIV1) {
                clocks.hclk().0 == clocks.sysclk().0
            } else {
                true
            }
        }
        #[doc = " sets up adc in one shot mode for a single channel"]
        pub fn setup_oneshot(&mut self) {
            self.rb.cr.modify(|_, w| w.adstp().stop());
            self.rb.isr.modify(|_, w| w.ovr().clear());
            self.rb
                .cfgr
                .modify(|_, w| w.cont().single().ovrmod().preserve());
            self.set_sequence_len(1);
            self.operation_mode = Some(OperationMode::OneShot);
        }
        fn set_sequence_len(&mut self, len: u8) {
            if !(len - 1 < 16) {
                ::core::panicking::panic("ADC sequence length must be in 1..=16")
            };
            self.rb.sqr1.modify(|_, w| w.l().bits(len - 1));
        }
        fn set_align(&self, align: Align) {
            self.rb.cfgr.modify(|_, w| w.align().variant(align.into()));
        }
        fn enable(&mut self) {
            self.rb.cr.modify(|_, w| w.aden().enable());
            while self.rb.isr.read().adrdy().is_not_ready() {}
        }
        fn disable(&mut self) {
            self.rb.cr.modify(|_, w| w.addis().disable());
        }
        #[doc = " Calibrate according to 15.3.8 in the Reference Manual"]
        fn calibrate(&mut self) {
            if !self.rb.cr.read().advregen().is_enabled() {
                self.advregen_enable();
                self.wait_advregen_startup();
            }
            self.disable();
            self.rb
                .cr
                .modify(|_, w| w.adcaldif().single_ended().adcal().calibration());
            while self.rb.cr.read().adcal().is_calibration() {}
        }
        fn wait_adc_clk_cycles(&self, cycles: u32) {
            let adc_clk_cycle = self.clocks.hclk().0 / (self.ckmode as u32);
            asm::delay(adc_clk_cycle * cycles);
        }
        fn advregen_enable(&mut self) {
            self.rb.cr.modify(|_, w| w.advregen().intermediate());
            self.rb.cr.modify(|_, w| w.advregen().enabled());
        }
        #[doc = " wait for the advregen to startup."]
        #[doc = ""]
        #[doc = " This is based on the MAX_ADVREGEN_STARTUP_US of the device."]
        fn wait_advregen_startup(&self) {
            asm::delay((MAX_ADVREGEN_STARTUP_US * 1_000_000) / self.clocks.sysclk().0);
        }
        #[doc = " busy ADC read"]
        fn convert_one(&mut self, chan: u8) -> u16 {
            self.ensure_oneshot();
            self.set_chan_smps(chan, SampleTime::default());
            self.select_single_chan(chan);
            self.rb.cr.modify(|_, w| w.adstart().start());
            while self.rb.isr.read().eos().is_not_complete() {}
            self.rb.isr.modify(|_, w| w.eos().clear());
            return self.rb.dr.read().rdata().bits();
        }
        fn ensure_oneshot(&mut self) {
            if self.operation_mode != Some(OperationMode::OneShot) {
                self.setup_oneshot();
            }
        }
        #[doc = " This should only be invoked with the defined channels for the particular"]
        #[doc = " device. (See Pin/Channel mapping above)"]
        fn select_single_chan(&self, chan: u8) {
            self.rb.sqr1.modify(|_, w| unsafe { w.sq1().bits(chan) });
        }
        #[doc = " Note: only allowed when ADSTART = 0"]
        fn set_chan_smps(&self, chan: u8, smp: SampleTime) {
            match chan {
                1 => self.rb.smpr1.modify(|_, w| w.smp1().bits(smp.bitcode())),
                2 => self.rb.smpr1.modify(|_, w| w.smp2().bits(smp.bitcode())),
                3 => self.rb.smpr1.modify(|_, w| w.smp3().bits(smp.bitcode())),
                4 => self.rb.smpr1.modify(|_, w| w.smp4().bits(smp.bitcode())),
                5 => self.rb.smpr1.modify(|_, w| w.smp5().bits(smp.bitcode())),
                6 => self.rb.smpr1.modify(|_, w| w.smp6().bits(smp.bitcode())),
                7 => self.rb.smpr1.modify(|_, w| w.smp7().bits(smp.bitcode())),
                8 => self.rb.smpr1.modify(|_, w| w.smp8().bits(smp.bitcode())),
                9 => self.rb.smpr1.modify(|_, w| w.smp9().bits(smp.bitcode())),
                11 => self.rb.smpr2.modify(|_, w| w.smp10().bits(smp.bitcode())),
                12 => self.rb.smpr2.modify(|_, w| w.smp12().bits(smp.bitcode())),
                13 => self.rb.smpr2.modify(|_, w| w.smp13().bits(smp.bitcode())),
                14 => self.rb.smpr2.modify(|_, w| w.smp14().bits(smp.bitcode())),
                15 => self.rb.smpr2.modify(|_, w| w.smp15().bits(smp.bitcode())),
                16 => self.rb.smpr2.modify(|_, w| w.smp16().bits(smp.bitcode())),
                17 => self.rb.smpr2.modify(|_, w| w.smp17().bits(smp.bitcode())),
                18 => self.rb.smpr2.modify(|_, w| w.smp18().bits(smp.bitcode())),
                _ => ::core::panicking::panic("internal error: entered unreachable code"),
            };
        }
    }
    impl<WORD, PIN> OneShot<ADC4, WORD, PIN> for Adc<ADC4>
    where
        WORD: From<u16>,
        PIN: Channel<ADC4, ID = u8>,
    {
        type Error = ();
        fn read(&mut self, _pin: &mut PIN) -> nb::Result<WORD, Self::Error> {
            let res = self.convert_one(PIN::channel());
            return Ok(res.into());
        }
    }
}
#[cfg(any(feature = "stm32f302", feature = "stm32f303"))]
pub mod dma {
    #![doc = " Direct memory access (DMA) controller"]
    #![doc = ""]
    #![doc = " Currently DMA is only supported for STM32F303 MCUs."]
    #![doc = ""]
    #![doc = " An example how to use DMA for serial, can be found at [examples/serial_dma.rs]"]
    #![doc = ""]
    #![doc = " [examples/serial_dma.rs]: https://github.com/stm32-rs/stm32f3xx-hal/blob/v0.6.0/examples/serial_dma.rs"]
    pub use embedded_dma::{ReadBuffer, WriteBuffer};
    use crate::{
        pac::{self, dma1::ch::cr},
        rcc::AHB,
        serial,
    };
    use core::{
        convert::TryFrom,
        mem,
        sync::atomic::{self, Ordering},
    };
    #[doc = " Extension trait to split a DMA peripheral into independent channels"]
    pub trait DmaExt {
        #[doc = " The type to split the DMA into"]
        type Channels;
        #[doc = " Split the DMA into independent channels"]
        fn split(self, ahb: &mut AHB) -> Self::Channels;
    }
    #[doc = " Trait implemented by DMA targets."]
    pub trait Target {
        #[doc = " Enable DMA on the target"]
        fn enable_dma(&mut self) {}
        #[doc = " Disable DMA on the target"]
        fn disable_dma(&mut self) {}
    }
    #[doc = " An in-progress one-shot DMA transfer"]
    pub struct Transfer<B, C: Channel, T: Target> {
        inner: Option<TransferInner<B, C, T>>,
    }
    impl<B, C: Channel, T: Target> Transfer<B, C, T> {
        #[doc = " Start a DMA write transfer."]
        #[doc = ""]
        #[doc = " # Panics"]
        #[doc = ""]
        #[doc = " Panics if the buffer is longer than 65535 words."]
        pub fn start_write(mut buffer: B, mut channel: C, target: T) -> Self
        where
            B: WriteBuffer + 'static,
            T: OnChannel<C>,
        {
            let (ptr, len) = unsafe { buffer.write_buffer() };
            let len = u16::try_from(len).ok().expect("buffer is too large");
            unsafe { channel.set_memory_address(ptr as u32, Increment::Enable) };
            channel.set_transfer_length(len);
            channel.set_word_size::<B::Word>();
            channel.set_direction(Direction::FromPeripheral);
            unsafe { Self::start(buffer, channel, target) }
        }
        #[doc = " Start a DMA read transfer."]
        #[doc = ""]
        #[doc = " # Panics"]
        #[doc = ""]
        #[doc = " Panics if the buffer is longer than 65535 words."]
        pub fn start_read(buffer: B, mut channel: C, target: T) -> Self
        where
            B: ReadBuffer + 'static,
            T: OnChannel<C>,
        {
            let (ptr, len) = unsafe { buffer.read_buffer() };
            let len = u16::try_from(len).ok().expect("buffer is too large");
            unsafe { channel.set_memory_address(ptr as u32, Increment::Enable) };
            channel.set_transfer_length(len);
            channel.set_word_size::<B::Word>();
            channel.set_direction(Direction::FromMemory);
            unsafe { Self::start(buffer, channel, target) }
        }
        #[doc = " # Safety"]
        #[doc = ""]
        #[doc = " Callers must ensure that:"]
        #[doc = ""]
        #[doc = " - the given buffer will be valid for the duration of the transfer"]
        #[doc = " - the DMA channel is configured correctly for the given target and buffer"]
        unsafe fn start(buffer: B, mut channel: C, mut target: T) -> Self
        where
            T: OnChannel<C>,
        {
            if !!channel.is_enabled() {
                ::core::panicking::panic("assertion failed: !channel.is_enabled()")
            };
            atomic::compiler_fence(Ordering::Release);
            target.enable_dma();
            channel.enable();
            Self {
                inner: Some(TransferInner {
                    buffer,
                    channel,
                    target,
                }),
            }
        }
        #[doc = " Is this transfer complete?"]
        pub fn is_complete(&self) -> bool {
            let inner = self.inner.as_ref().unwrap();
            inner.channel.event_occurred(Event::TransferComplete)
        }
        #[doc = " Stop this transfer and return ownership over its parts"]
        pub fn stop(mut self) -> (B, C, T) {
            let mut inner = self.inner.take().unwrap();
            inner.stop();
            (inner.buffer, inner.channel, inner.target)
        }
        #[doc = " Block until this transfer is done and return ownership over its parts"]
        pub fn wait(self) -> (B, C, T) {
            while !self.is_complete() {}
            self.stop()
        }
    }
    impl<B, C: Channel, T: Target> Drop for Transfer<B, C, T> {
        fn drop(&mut self) {
            if let Some(inner) = self.inner.as_mut() {
                inner.stop();
            }
        }
    }
    #[doc = " This only exists so we can implement `Drop` for `Transfer`."]
    struct TransferInner<B, C, T> {
        buffer: B,
        channel: C,
        target: T,
    }
    impl<B, C: Channel, T: Target> TransferInner<B, C, T> {
        #[doc = " Stop this transfer"]
        fn stop(&mut self) {
            self.channel.disable();
            self.target.disable_dma();
            atomic::compiler_fence(Ordering::SeqCst);
        }
    }
    #[doc = " DMA address increment mode"]
    pub enum Increment {
        #[doc = " Enable increment"]
        Enable,
        #[doc = " Disable increment"]
        Disable,
    }
    impl From<Increment> for cr::PINC_A {
        fn from(inc: Increment) -> Self {
            match inc {
                Increment::Enable => cr::PINC_A::ENABLED,
                Increment::Disable => cr::PINC_A::DISABLED,
            }
        }
    }
    #[doc = " Channel priority level"]
    pub enum Priority {
        #[doc = " Low"]
        Low,
        #[doc = " Medium"]
        Medium,
        #[doc = " High"]
        High,
        #[doc = " Very high"]
        VeryHigh,
    }
    impl From<Priority> for cr::PL_A {
        fn from(prio: Priority) -> Self {
            match prio {
                Priority::Low => cr::PL_A::LOW,
                Priority::Medium => cr::PL_A::MEDIUM,
                Priority::High => cr::PL_A::HIGH,
                Priority::VeryHigh => cr::PL_A::VERYHIGH,
            }
        }
    }
    #[doc = " DMA transfer direction"]
    pub enum Direction {
        #[doc = " From memory to peripheral"]
        FromMemory,
        #[doc = " From peripheral to memory"]
        FromPeripheral,
    }
    impl From<Direction> for cr::DIR_A {
        fn from(dir: Direction) -> Self {
            match dir {
                Direction::FromMemory => cr::DIR_A::FROMMEMORY,
                Direction::FromPeripheral => cr::DIR_A::FROMPERIPHERAL,
            }
        }
    }
    #[doc = " DMA events"]
    pub enum Event {
        #[doc = " First half of a transfer is done"]
        HalfTransfer,
        #[doc = " Transfer is complete"]
        TransferComplete,
        #[doc = " A transfer error occurred"]
        TransferError,
        #[doc = " Any of the above events occurred"]
        Any,
    }
    #[doc = " Trait implemented by all DMA channels"]
    pub trait Channel: private::Channel {
        #[doc = " Is the interrupt flag for the given event set?"]
        fn event_occurred(&self, event: Event) -> bool;
        #[doc = " Clear the interrupt flag for the given event."]
        #[doc = ""]
        #[doc = " Passing `Event::Any` clears all interrupt flags."]
        #[doc = ""]
        #[doc = " Note that the the global interrupt flag is not automatically cleared"]
        #[doc = " even when all other flags are cleared. The only way to clear it is to"]
        #[doc = " call this method with `Event::Any`."]
        fn clear_event(&mut self, event: Event);
        #[doc = " Reset the control registers of this channel."]
        #[doc = " This stops any ongoing transfers."]
        fn reset(&mut self) {
            self.ch().cr.reset();
            self.ch().ndtr.reset();
            self.ch().par.reset();
            self.ch().mar.reset();
            self.clear_event(Event::Any);
        }
        #[doc = " Set the base address of the peripheral data register from/to which the"]
        #[doc = " data will be read/written."]
        #[doc = ""]
        #[doc = " Only call this method on disabled channels."]
        #[doc = ""]
        #[doc = " # Panics"]
        #[doc = ""]
        #[doc = " Panics if this channel is enabled."]
        #[doc = ""]
        #[doc = " # Safety"]
        #[doc = ""]
        #[doc = " Callers must ensure the given address is the address of a peripheral"]
        #[doc = " register that supports DMA."]
        unsafe fn set_peripheral_address(&mut self, address: u32, inc: Increment) {
            if !!self.is_enabled() {
                ::core::panicking::panic("assertion failed: !self.is_enabled()")
            };
            self.ch().par.write(|w| w.pa().bits(address));
            self.ch().cr.modify(|_, w| w.pinc().variant(inc.into()));
        }
        #[doc = " Set the base address of the memory area from/to which"]
        #[doc = " the data will be read/written."]
        #[doc = ""]
        #[doc = " Only call this method on disabled channels."]
        #[doc = ""]
        #[doc = " # Panics"]
        #[doc = ""]
        #[doc = " Panics if this channel is enabled."]
        #[doc = ""]
        #[doc = " # Safety"]
        #[doc = ""]
        #[doc = " Callers must ensure the given address is a valid memory address"]
        #[doc = " that will remain valid as long as at is used by DMA."]
        unsafe fn set_memory_address(&mut self, address: u32, inc: Increment) {
            if !!self.is_enabled() {
                ::core::panicking::panic("assertion failed: !self.is_enabled()")
            };
            self.ch().mar.write(|w| w.ma().bits(address));
            self.ch().cr.modify(|_, w| w.minc().variant(inc.into()));
        }
        #[doc = " Set the number of words to transfer."]
        #[doc = ""]
        #[doc = " Only call this method on disabled channels."]
        #[doc = ""]
        #[doc = " # Panics"]
        #[doc = ""]
        #[doc = " Panics if this channel is enabled."]
        fn set_transfer_length(&mut self, len: u16) {
            if !!self.is_enabled() {
                ::core::panicking::panic("assertion failed: !self.is_enabled()")
            };
            self.ch().ndtr.write(|w| w.ndt().bits(len));
        }
        #[doc = " Set the word size."]
        #[doc = ""]
        #[doc = " # Panics"]
        #[doc = ""]
        #[doc = " Panics if the word size is not one of 8, 16, or 32 bits."]
        fn set_word_size<W>(&mut self) {
            use cr::PSIZE_A::*;
            let psize = match mem::size_of::<W>() {
                1 => BITS8,
                2 => BITS16,
                4 => BITS32,
                s => ::core::panicking::panic_fmt(::core::fmt::Arguments::new_v1(
                    &["unsupported word size: "],
                    &match (&s,) {
                        (arg0,) => [::core::fmt::ArgumentV1::new(arg0, ::core::fmt::Debug::fmt)],
                    },
                )),
            };
            self.ch().cr.modify(|_, w| {
                w.psize().variant(psize);
                w.msize().variant(psize)
            });
        }
        #[doc = " Set the priority level of this channel"]
        fn set_priority_level(&mut self, priority: Priority) {
            let pl = priority.into();
            self.ch().cr.modify(|_, w| w.pl().variant(pl));
        }
        #[doc = " Set the transfer direction"]
        fn set_direction(&mut self, direction: Direction) {
            let dir = direction.into();
            self.ch().cr.modify(|_, w| w.dir().variant(dir));
        }
        #[doc = " Enable the interrupt for the given event"]
        fn listen(&mut self, event: Event) {
            use Event::*;
            match event {
                HalfTransfer => self.ch().cr.modify(|_, w| w.htie().enabled()),
                TransferComplete => self.ch().cr.modify(|_, w| w.tcie().enabled()),
                TransferError => self.ch().cr.modify(|_, w| w.teie().enabled()),
                Any => self.ch().cr.modify(|_, w| {
                    w.htie().enabled();
                    w.tcie().enabled();
                    w.teie().enabled()
                }),
            }
        }
        #[doc = " Disable the interrupt for the given event"]
        fn unlisten(&mut self, event: Event) {
            use Event::*;
            match event {
                HalfTransfer => self.ch().cr.modify(|_, w| w.htie().disabled()),
                TransferComplete => self.ch().cr.modify(|_, w| w.tcie().disabled()),
                TransferError => self.ch().cr.modify(|_, w| w.teie().disabled()),
                Any => self.ch().cr.modify(|_, w| {
                    w.htie().disabled();
                    w.tcie().disabled();
                    w.teie().disabled()
                }),
            }
        }
        #[doc = " Start a transfer"]
        fn enable(&mut self) {
            self.clear_event(Event::Any);
            self.ch().cr.modify(|_, w| w.en().enabled());
        }
        #[doc = " Stop the current transfer"]
        fn disable(&mut self) {
            self.ch().cr.modify(|_, w| w.en().disabled());
        }
        #[doc = " Is there a transfer in progress on this channel?"]
        fn is_enabled(&self) -> bool {
            self.ch().cr.read().en().is_enabled()
        }
    }
    mod private {
        use crate::pac;
        #[doc = " Channel methods private to this module"]
        pub trait Channel {
            #[doc = " Return the register block for this channel"]
            fn ch(&self) -> &pac::dma1::CH;
        }
    }
    #[doc = "All associated types, traits and methods of the `DMA1` peripheral."]
    pub mod dma1 {
        use super::*;
        use crate::pac::DMA1;
        impl DmaExt for DMA1 {
            type Channels = Channels;
            fn split(self, ahb: &mut AHB) -> Channels {
                ahb.enr().modify(|_, w| w.dma1en().set_bit());
                let mut channels = Channels {
                    ch1: C1 { _0: () },
                    ch2: C2 { _0: () },
                    ch3: C3 { _0: () },
                    ch4: C4 { _0: () },
                    ch5: C5 { _0: () },
                    ch6: C6 { _0: () },
                    ch7: C7 { _0: () },
                };
                channels.reset();
                channels
            }
        }
        #[doc = " DMA channels"]
        pub struct Channels {
            #[doc = " Channel"]
            pub ch1: C1,
            #[doc = " Channel"]
            pub ch2: C2,
            #[doc = " Channel"]
            pub ch3: C3,
            #[doc = " Channel"]
            pub ch4: C4,
            #[doc = " Channel"]
            pub ch5: C5,
            #[doc = " Channel"]
            pub ch6: C6,
            #[doc = " Channel"]
            pub ch7: C7,
        }
        impl Channels {
            #[doc = " Reset the control registers of all channels."]
            #[doc = " This stops any ongoing transfers."]
            fn reset(&mut self) {
                self.ch1.reset();
                self.ch2.reset();
                self.ch3.reset();
                self.ch4.reset();
                self.ch5.reset();
                self.ch6.reset();
                self.ch7.reset();
            }
        }
        #[doc = " Singleton that represents a DMA channel"]
        pub struct C1 {
            _0: (),
        }
        impl private::Channel for C1 {
            fn ch(&self) -> &pac::dma1::CH {
                unsafe { &(*DMA1::ptr()).ch1 }
            }
        }
        impl Channel for C1 {
            fn event_occurred(&self, event: Event) -> bool {
                use Event::*;
                let flags = unsafe { (*DMA1::ptr()).isr.read() };
                match event {
                    HalfTransfer => flags.htif1().bit_is_set(),
                    TransferComplete => flags.tcif1().bit_is_set(),
                    TransferError => flags.teif1().bit_is_set(),
                    Any => flags.gif1().bit_is_set(),
                }
            }
            fn clear_event(&mut self, event: Event) {
                use Event::*;
                unsafe {
                    &(*DMA1::ptr()).ifcr.write(|w| match event {
                        HalfTransfer => w.chtif1().set_bit(),
                        TransferComplete => w.ctcif1().set_bit(),
                        TransferError => w.cteif1().set_bit(),
                        Any => w.cgif1().set_bit(),
                    });
                }
            }
        }
        #[doc = " Singleton that represents a DMA channel"]
        pub struct C2 {
            _0: (),
        }
        impl private::Channel for C2 {
            fn ch(&self) -> &pac::dma1::CH {
                unsafe { &(*DMA1::ptr()).ch2 }
            }
        }
        impl Channel for C2 {
            fn event_occurred(&self, event: Event) -> bool {
                use Event::*;
                let flags = unsafe { (*DMA1::ptr()).isr.read() };
                match event {
                    HalfTransfer => flags.htif2().bit_is_set(),
                    TransferComplete => flags.tcif2().bit_is_set(),
                    TransferError => flags.teif2().bit_is_set(),
                    Any => flags.gif2().bit_is_set(),
                }
            }
            fn clear_event(&mut self, event: Event) {
                use Event::*;
                unsafe {
                    &(*DMA1::ptr()).ifcr.write(|w| match event {
                        HalfTransfer => w.chtif2().set_bit(),
                        TransferComplete => w.ctcif2().set_bit(),
                        TransferError => w.cteif2().set_bit(),
                        Any => w.cgif2().set_bit(),
                    });
                }
            }
        }
        #[doc = " Singleton that represents a DMA channel"]
        pub struct C3 {
            _0: (),
        }
        impl private::Channel for C3 {
            fn ch(&self) -> &pac::dma1::CH {
                unsafe { &(*DMA1::ptr()).ch3 }
            }
        }
        impl Channel for C3 {
            fn event_occurred(&self, event: Event) -> bool {
                use Event::*;
                let flags = unsafe { (*DMA1::ptr()).isr.read() };
                match event {
                    HalfTransfer => flags.htif3().bit_is_set(),
                    TransferComplete => flags.tcif3().bit_is_set(),
                    TransferError => flags.teif3().bit_is_set(),
                    Any => flags.gif3().bit_is_set(),
                }
            }
            fn clear_event(&mut self, event: Event) {
                use Event::*;
                unsafe {
                    &(*DMA1::ptr()).ifcr.write(|w| match event {
                        HalfTransfer => w.chtif3().set_bit(),
                        TransferComplete => w.ctcif3().set_bit(),
                        TransferError => w.cteif3().set_bit(),
                        Any => w.cgif3().set_bit(),
                    });
                }
            }
        }
        #[doc = " Singleton that represents a DMA channel"]
        pub struct C4 {
            _0: (),
        }
        impl private::Channel for C4 {
            fn ch(&self) -> &pac::dma1::CH {
                unsafe { &(*DMA1::ptr()).ch4 }
            }
        }
        impl Channel for C4 {
            fn event_occurred(&self, event: Event) -> bool {
                use Event::*;
                let flags = unsafe { (*DMA1::ptr()).isr.read() };
                match event {
                    HalfTransfer => flags.htif4().bit_is_set(),
                    TransferComplete => flags.tcif4().bit_is_set(),
                    TransferError => flags.teif4().bit_is_set(),
                    Any => flags.gif4().bit_is_set(),
                }
            }
            fn clear_event(&mut self, event: Event) {
                use Event::*;
                unsafe {
                    &(*DMA1::ptr()).ifcr.write(|w| match event {
                        HalfTransfer => w.chtif4().set_bit(),
                        TransferComplete => w.ctcif4().set_bit(),
                        TransferError => w.cteif4().set_bit(),
                        Any => w.cgif4().set_bit(),
                    });
                }
            }
        }
        #[doc = " Singleton that represents a DMA channel"]
        pub struct C5 {
            _0: (),
        }
        impl private::Channel for C5 {
            fn ch(&self) -> &pac::dma1::CH {
                unsafe { &(*DMA1::ptr()).ch5 }
            }
        }
        impl Channel for C5 {
            fn event_occurred(&self, event: Event) -> bool {
                use Event::*;
                let flags = unsafe { (*DMA1::ptr()).isr.read() };
                match event {
                    HalfTransfer => flags.htif5().bit_is_set(),
                    TransferComplete => flags.tcif5().bit_is_set(),
                    TransferError => flags.teif5().bit_is_set(),
                    Any => flags.gif5().bit_is_set(),
                }
            }
            fn clear_event(&mut self, event: Event) {
                use Event::*;
                unsafe {
                    &(*DMA1::ptr()).ifcr.write(|w| match event {
                        HalfTransfer => w.chtif5().set_bit(),
                        TransferComplete => w.ctcif5().set_bit(),
                        TransferError => w.cteif5().set_bit(),
                        Any => w.cgif5().set_bit(),
                    });
                }
            }
        }
        #[doc = " Singleton that represents a DMA channel"]
        pub struct C6 {
            _0: (),
        }
        impl private::Channel for C6 {
            fn ch(&self) -> &pac::dma1::CH {
                unsafe { &(*DMA1::ptr()).ch6 }
            }
        }
        impl Channel for C6 {
            fn event_occurred(&self, event: Event) -> bool {
                use Event::*;
                let flags = unsafe { (*DMA1::ptr()).isr.read() };
                match event {
                    HalfTransfer => flags.htif6().bit_is_set(),
                    TransferComplete => flags.tcif6().bit_is_set(),
                    TransferError => flags.teif6().bit_is_set(),
                    Any => flags.gif6().bit_is_set(),
                }
            }
            fn clear_event(&mut self, event: Event) {
                use Event::*;
                unsafe {
                    &(*DMA1::ptr()).ifcr.write(|w| match event {
                        HalfTransfer => w.chtif6().set_bit(),
                        TransferComplete => w.ctcif6().set_bit(),
                        TransferError => w.cteif6().set_bit(),
                        Any => w.cgif6().set_bit(),
                    });
                }
            }
        }
        #[doc = " Singleton that represents a DMA channel"]
        pub struct C7 {
            _0: (),
        }
        impl private::Channel for C7 {
            fn ch(&self) -> &pac::dma1::CH {
                unsafe { &(*DMA1::ptr()).ch7 }
            }
        }
        impl Channel for C7 {
            fn event_occurred(&self, event: Event) -> bool {
                use Event::*;
                let flags = unsafe { (*DMA1::ptr()).isr.read() };
                match event {
                    HalfTransfer => flags.htif7().bit_is_set(),
                    TransferComplete => flags.tcif7().bit_is_set(),
                    TransferError => flags.teif7().bit_is_set(),
                    Any => flags.gif7().bit_is_set(),
                }
            }
            fn clear_event(&mut self, event: Event) {
                use Event::*;
                unsafe {
                    &(*DMA1::ptr()).ifcr.write(|w| match event {
                        HalfTransfer => w.chtif7().set_bit(),
                        TransferComplete => w.ctcif7().set_bit(),
                        TransferError => w.cteif7().set_bit(),
                        Any => w.cgif7().set_bit(),
                    });
                }
            }
        }
    }
    #[doc = "All associated types, traits and methods of the `DMA2` peripheral."]
    pub mod dma2 {
        use super::*;
        use crate::pac::DMA2;
        impl DmaExt for DMA2 {
            type Channels = Channels;
            fn split(self, ahb: &mut AHB) -> Channels {
                ahb.enr().modify(|_, w| w.dma2en().set_bit());
                let mut channels = Channels {
                    ch1: C1 { _0: () },
                    ch2: C2 { _0: () },
                    ch3: C3 { _0: () },
                    ch4: C4 { _0: () },
                    ch5: C5 { _0: () },
                };
                channels.reset();
                channels
            }
        }
        #[doc = " DMA channels"]
        pub struct Channels {
            #[doc = " Channel"]
            pub ch1: C1,
            #[doc = " Channel"]
            pub ch2: C2,
            #[doc = " Channel"]
            pub ch3: C3,
            #[doc = " Channel"]
            pub ch4: C4,
            #[doc = " Channel"]
            pub ch5: C5,
        }
        impl Channels {
            #[doc = " Reset the control registers of all channels."]
            #[doc = " This stops any ongoing transfers."]
            fn reset(&mut self) {
                self.ch1.reset();
                self.ch2.reset();
                self.ch3.reset();
                self.ch4.reset();
                self.ch5.reset();
            }
        }
        #[doc = " Singleton that represents a DMA channel"]
        pub struct C1 {
            _0: (),
        }
        impl private::Channel for C1 {
            fn ch(&self) -> &pac::dma1::CH {
                unsafe { &(*DMA2::ptr()).ch1 }
            }
        }
        impl Channel for C1 {
            fn event_occurred(&self, event: Event) -> bool {
                use Event::*;
                let flags = unsafe { (*DMA2::ptr()).isr.read() };
                match event {
                    HalfTransfer => flags.htif1().bit_is_set(),
                    TransferComplete => flags.tcif1().bit_is_set(),
                    TransferError => flags.teif1().bit_is_set(),
                    Any => flags.gif1().bit_is_set(),
                }
            }
            fn clear_event(&mut self, event: Event) {
                use Event::*;
                unsafe {
                    &(*DMA2::ptr()).ifcr.write(|w| match event {
                        HalfTransfer => w.chtif1().set_bit(),
                        TransferComplete => w.ctcif1().set_bit(),
                        TransferError => w.cteif1().set_bit(),
                        Any => w.cgif1().set_bit(),
                    });
                }
            }
        }
        #[doc = " Singleton that represents a DMA channel"]
        pub struct C2 {
            _0: (),
        }
        impl private::Channel for C2 {
            fn ch(&self) -> &pac::dma1::CH {
                unsafe { &(*DMA2::ptr()).ch2 }
            }
        }
        impl Channel for C2 {
            fn event_occurred(&self, event: Event) -> bool {
                use Event::*;
                let flags = unsafe { (*DMA2::ptr()).isr.read() };
                match event {
                    HalfTransfer => flags.htif2().bit_is_set(),
                    TransferComplete => flags.tcif2().bit_is_set(),
                    TransferError => flags.teif2().bit_is_set(),
                    Any => flags.gif2().bit_is_set(),
                }
            }
            fn clear_event(&mut self, event: Event) {
                use Event::*;
                unsafe {
                    &(*DMA2::ptr()).ifcr.write(|w| match event {
                        HalfTransfer => w.chtif2().set_bit(),
                        TransferComplete => w.ctcif2().set_bit(),
                        TransferError => w.cteif2().set_bit(),
                        Any => w.cgif2().set_bit(),
                    });
                }
            }
        }
        #[doc = " Singleton that represents a DMA channel"]
        pub struct C3 {
            _0: (),
        }
        impl private::Channel for C3 {
            fn ch(&self) -> &pac::dma1::CH {
                unsafe { &(*DMA2::ptr()).ch3 }
            }
        }
        impl Channel for C3 {
            fn event_occurred(&self, event: Event) -> bool {
                use Event::*;
                let flags = unsafe { (*DMA2::ptr()).isr.read() };
                match event {
                    HalfTransfer => flags.htif3().bit_is_set(),
                    TransferComplete => flags.tcif3().bit_is_set(),
                    TransferError => flags.teif3().bit_is_set(),
                    Any => flags.gif3().bit_is_set(),
                }
            }
            fn clear_event(&mut self, event: Event) {
                use Event::*;
                unsafe {
                    &(*DMA2::ptr()).ifcr.write(|w| match event {
                        HalfTransfer => w.chtif3().set_bit(),
                        TransferComplete => w.ctcif3().set_bit(),
                        TransferError => w.cteif3().set_bit(),
                        Any => w.cgif3().set_bit(),
                    });
                }
            }
        }
        #[doc = " Singleton that represents a DMA channel"]
        pub struct C4 {
            _0: (),
        }
        impl private::Channel for C4 {
            fn ch(&self) -> &pac::dma1::CH {
                unsafe { &(*DMA2::ptr()).ch4 }
            }
        }
        impl Channel for C4 {
            fn event_occurred(&self, event: Event) -> bool {
                use Event::*;
                let flags = unsafe { (*DMA2::ptr()).isr.read() };
                match event {
                    HalfTransfer => flags.htif4().bit_is_set(),
                    TransferComplete => flags.tcif4().bit_is_set(),
                    TransferError => flags.teif4().bit_is_set(),
                    Any => flags.gif4().bit_is_set(),
                }
            }
            fn clear_event(&mut self, event: Event) {
                use Event::*;
                unsafe {
                    &(*DMA2::ptr()).ifcr.write(|w| match event {
                        HalfTransfer => w.chtif4().set_bit(),
                        TransferComplete => w.ctcif4().set_bit(),
                        TransferError => w.cteif4().set_bit(),
                        Any => w.cgif4().set_bit(),
                    });
                }
            }
        }
        #[doc = " Singleton that represents a DMA channel"]
        pub struct C5 {
            _0: (),
        }
        impl private::Channel for C5 {
            fn ch(&self) -> &pac::dma1::CH {
                unsafe { &(*DMA2::ptr()).ch5 }
            }
        }
        impl Channel for C5 {
            fn event_occurred(&self, event: Event) -> bool {
                use Event::*;
                let flags = unsafe { (*DMA2::ptr()).isr.read() };
                match event {
                    HalfTransfer => flags.htif5().bit_is_set(),
                    TransferComplete => flags.tcif5().bit_is_set(),
                    TransferError => flags.teif5().bit_is_set(),
                    Any => flags.gif5().bit_is_set(),
                }
            }
            fn clear_event(&mut self, event: Event) {
                use Event::*;
                unsafe {
                    &(*DMA2::ptr()).ifcr.write(|w| match event {
                        HalfTransfer => w.chtif5().set_bit(),
                        TransferComplete => w.ctcif5().set_bit(),
                        TransferError => w.cteif5().set_bit(),
                        Any => w.cgif5().set_bit(),
                    });
                }
            }
        }
    }
    #[doc = " Marker trait mapping DMA targets to their channels"]
    #[doc = ""]
    #[doc = " # Safety"]
    #[doc = ""]
    #[doc = " `C` must be the correct DMA channel for the peripheral implementing"]
    #[doc = " this trait."]
    pub unsafe trait OnChannel<C: Channel>: Target {}
    unsafe impl OnChannel<dma1::C5> for serial::Rx<pac::USART1> {}
    unsafe impl OnChannel<dma1::C4> for serial::Tx<pac::USART1> {}
    unsafe impl OnChannel<dma1::C6> for serial::Rx<pac::USART2> {}
    unsafe impl OnChannel<dma1::C7> for serial::Tx<pac::USART2> {}
    unsafe impl OnChannel<dma1::C3> for serial::Rx<pac::USART3> {}
    unsafe impl OnChannel<dma1::C2> for serial::Tx<pac::USART3> {}
}
#[cfg(all(
    feature = "stm32-usbd",
    any(
        feature = "stm32f303xb",
        feature = "stm32f303xc",
        feature = "stm32f303xd",
        feature = "stm32f303xe",
    )
))]
pub mod usb {
    #![doc = " USB peripheral"]
    #![doc = ""]
    #![doc = " Requires the `stm32-usbd` feature and one of the `stm32f303x*` features."]
    #![doc = ""]
    #![doc = " See [examples/usb_serial.rs] for a usage example."]
    #![doc = ""]
    #![doc = " [examples/usb_serial.rs]: https://github.com/stm32-rs/stm32f3xx-hal/blob/v0.6.0/examples/usb_serial.rs"]
    use crate::pac::{RCC, USB};
    use stm32_usbd::UsbPeripheral;
    use crate::gpio::gpioa::{PA11, PA12};
    use crate::gpio::AF14;
    pub use stm32_usbd::UsbBus;
    #[doc = " USB Peripheral"]
    #[doc = ""]
    #[doc = " Constructs the peripheral, which"]
    #[doc = " than gets passed to the [`UsbBus`]."]
    pub struct Peripheral {
        #[doc = " USB Register Block"]
        pub usb: USB,
        #[doc = " Data Negativ Pin"]
        pub pin_dm: PA11<AF14>,
        #[doc = " Data Positiv Pin"]
        pub pin_dp: PA12<AF14>,
    }
    unsafe impl Sync for Peripheral {}
    unsafe impl UsbPeripheral for Peripheral {
        const REGISTERS: *const () = USB::ptr() as *const ();
        const DP_PULL_UP_FEATURE: bool = false;
        const EP_MEMORY: *const () = 0x4000_6000 as _;
        #[cfg(any(feature = "stm32f303xb", feature = "stm32f303xc"))]
        const EP_MEMORY_SIZE: usize = 512;
        fn enable() {
            let rcc = unsafe { &*RCC::ptr() };
            cortex_m::interrupt::free(|_| {
                rcc.apb1enr.modify(|_, w| w.usben().enabled());
                rcc.apb1rstr.modify(|_, w| w.usbrst().reset());
                rcc.apb1rstr.modify(|_, w| w.usbrst().clear_bit());
            });
        }
        fn startup_delay() {
            cortex_m::asm::delay(72);
        }
    }
    #[doc = " Type of the UsbBus"]
    #[doc = ""]
    #[doc = " As this MCU family has only USB peripheral,"]
    #[doc = " this is the only possible concrete type construction."]
    pub type UsbBusType = UsbBus<Peripheral>;
}
#[cfg(feature = "device-selected")]
pub mod watchdog {
    #![doc = " Watchdog"]
    #![doc = ""]
    #![doc = " A usage example of the watchdog can be found at [examples/can.rs]"]
    #![doc = ""]
    #![doc = " [examples/can.rs]: https://github.com/stm32-rs/stm32f3xx-hal/blob/v0.6.0/examples/can.rs"]
    use crate::hal::watchdog::{Watchdog, WatchdogEnable};
    use crate::pac::{DBGMCU, IWDG};
    use crate::time::MilliSeconds;
    const LSI_KHZ: u32 = 40;
    const MAX_PR: u8 = 8;
    const MAX_RL: u16 = 0x1000;
    #[doc = " Independent Watchdog Peripheral"]
    pub struct IndependentWatchDog {
        iwdg: IWDG,
    }
    impl IndependentWatchDog {
        #[doc = " Creates a new [`IndependentWatchDog`] without starting it."]
        #[doc = ""]
        #[doc = " Call [`start`](WatchdogEnable::start) to start the watchdog."]
        #[doc = ""]
        #[doc = " See [`WatchdogEnable`] and [`Watchdog`] for more info."]
        pub fn new(iwdg: IWDG) -> Self {
            IndependentWatchDog { iwdg }
        }
        #[doc = " Set the watchdog to stop when a breakpoint is hit while debugging"]
        pub fn stop_on_debug(&self, dbg: &DBGMCU, stop: bool) {
            dbg.apb1_fz.modify(|_, w| w.dbg_iwdg_stop().bit(stop));
        }
        fn setup(&self, timeout_ms: u32) {
            let mut pr = 0;
            while pr < MAX_PR && Self::timeout_period(pr, MAX_RL) < timeout_ms {
                pr += 1;
            }
            let max_period = Self::timeout_period(pr, MAX_RL);
            let max_rl = u32::from(MAX_RL);
            let rl = (timeout_ms * max_rl / max_period).min(max_rl) as u16;
            self.access_registers(|iwdg| {
                iwdg.pr.modify(|_, w| w.pr().bits(pr));
                iwdg.rlr.modify(|_, w| w.rl().bits(rl));
            });
        }
        fn is_pr_updating(&self) -> bool {
            self.iwdg.sr.read().pvu().bit()
        }
        #[doc = " Returns the interval in ms"]
        pub fn interval(&self) -> MilliSeconds {
            while self.is_pr_updating() {}
            let pr = self.iwdg.pr.read().pr().bits();
            let rl = self.iwdg.rlr.read().rl().bits();
            let ms = Self::timeout_period(pr, rl);
            MilliSeconds(ms)
        }
        #[doc = " pr: Prescaler divider bits, rl: reload value"]
        #[doc = ""]
        #[doc = " Returns ms"]
        fn timeout_period(pr: u8, rl: u16) -> u32 {
            let divider: u32 = match pr {
                0b000 => 4,
                0b001 => 8,
                0b010 => 16,
                0b011 => 32,
                0b100 => 64,
                0b101 => 128,
                0b110 => 256,
                0b111 => 256,
                _ => ::core::panicking::panic("Invalid IWDG prescaler divider"),
            };
            (u32::from(rl) + 1) * divider / LSI_KHZ
        }
        fn access_registers<A, F: FnMut(&IWDG) -> A>(&self, mut f: F) -> A {
            self.iwdg.kr.write(|w| w.key().enable());
            let a = f(&self.iwdg);
            self.iwdg.kr.write(|w| w.key().reset());
            a
        }
    }
    impl WatchdogEnable for IndependentWatchDog {
        type Time = MilliSeconds;
        fn start<T: Into<Self::Time>>(&mut self, period: T) {
            self.setup(period.into().0);
            self.iwdg.kr.write(|w| w.key().start());
        }
    }
    impl Watchdog for IndependentWatchDog {
        fn feed(&mut self) {
            self.iwdg.kr.write(|w| w.key().reset());
        }
    }
}
